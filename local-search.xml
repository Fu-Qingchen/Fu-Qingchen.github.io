<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【本科毕业设计·全文】一种直角坐标式船舶系泊辅助机械臂设计与分析</title>
    <link href="/2022/05/17/WHUT/GraduationDesign_WHUT_Archive/"/>
    <url>/2022/05/17/WHUT/GraduationDesign_WHUT_Archive/</url>
    
    <content type="html"><![CDATA[<p>放在这留作纪念，不过为了放抄袭故意设置了一些<strong>明显错误</strong>。</p><span id="more"></span><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>​        全球经济的不断发展，对港口的智能化提出越来越多的要求。目前，系泊作为港口的一道重要工序，绝大多港口仍使用传统的缆绳系缆。这种方法效率低，危险性高，船舶还会随着海浪运动，给装卸造成不必要的麻烦。21 世纪以来，一种自动系泊系统被发明出来，该系统使用带有真空吸盘的机械臂对船舶进行固定，极大的提升了船舶系泊的效率和安全性。这种自动系泊系统在国外已经发展成熟，然而在国内仍处于起步阶段。<br>​        在此背景下，本文设计了一种直角坐标式船舶系泊辅助机械臂，该机械臂主要控制机械臂末端真空吸盘的位置。当船舶靠近时，码头上的机械臂组控制真空吸盘与船舶表面贴合，真空吸盘的吸附力将船舶固定，实现系泊操作。当船舶到达机械臂的极限时，机械臂组会以步进移动的方式改变自己的位置。<br>​        该机械臂主要由驱动装置、支承装置、传动装置和真空吸盘四个部分组成。支承装置采用钢结构焊接而成，传动装置由摇板、竖直传动模块和纵向传动模块模块组成，其中竖直传动模块采用内、外门架和链轮链条结构实现行程的倍增。本文根据设计构型对机械臂运动学、动力学进行分析，详细描述了系泊机械臂各个部分的设计计算和选型，并使用 ANSYS 软件对机械臂关键结构进行分析改进，然后对该结构经济性能进行分析，最终得到了一个经济可靠的设计方案。</p><p><strong>关键词</strong>：自动系泊系统；结构设计；直角坐标机械臂；有限元分析</p><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>​        The continuous development of the global economy puts more requirements on the intelligence of ports today. At present, mooring is an important process in ports, and most ports still use traditional cable mooring, which is inefficient and dangerous, and the ship will move with the waves, causing unnecessary trouble for loading and unloading. Since the 21st century, an automatic mooring system has been invented. This system uses manipulators with vacuum chucks to fix the ship, which greatly improves the efficiency and safety of the ship mooring. This automatic mooring system has developed well abroad, but it is still in its infancy in China.</p><p>​        Under this background, this paper designed a cartesian coordinate manipulator to assist ship mooring. The manipulator controls the position of the vacuum chucks, which is at the end of it. When the ship approaches, the manipulators on the wharf controls the vacuum chucks to fit the surface of the ship, and the suction force of the vacuum chucks fixes the ship to realize the mooring operation. When the ship reaches the limit of the manipulators, the manipulators will change its position by stepping.</p><p>​        The manipulator is mainly composed of the driving device, the supporting devices, the transmission devices, and vacuum chucks. The support device is welded with steel structure. The transmission device is composed of a rocking plate, vertical transmission module, and longitudinal transmission module, in which the vertical transmission module uses the inner and outer gantry and sprocket chain structure to double the stroke. Firstly, this paper analyzes the kinematics and dynamics of the manipulator according to the design configuration. Secondly, it describes the  calculation and selection of each part of the mooring manipulator in detail. Thirdly, it uses ANSYS software to analyze and improve on the key structure of the manipulator. Fourthly, it analyzes the economic performance of the structure. Finally, an economical and reliable design was obtained.</p><p><strong>Key Words：</strong> automated mooring system; structural design; cartesian coordinate manipulator; finite element analysis</p><h1 id="第-1-章-绪论"><a href="#第-1-章-绪论" class="headerlink" title="第 1 章 绪论"></a>第 1 章 绪论</h1><h2 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h2><p>​        港口是国家重要的综合交通枢纽，也是经济发展的战略资源和重要支撑，在国家政治领域、经济领域、文化领域等都起着重要作用。根据交通运输部等九部门制定的《关于建设世界一流港口的指导意见》[1]，到 2025 年，世界一流港口建设取得重要进展，主要港口绿色、智慧、安全发展实现重大突破；到 2035 年，全国港口发展水平整体跃升，引领全球港口绿色发展、智慧发展。这对港口基础设施的建设提出了更高的要求。</p><p>​        系泊是港口码头使用过程中的一道重要工序，是指用系缆设备使船停于泊位的作业过程，系泊时间的长短直接影响港口装卸搬运的效率。目前，世界各地大多数港口仍然使用缆绳系缆。传统的缆绳系泊方式系缆作业难度大、耗时长。一般情况下，系泊一条万吨级的船舶需要 12 根缆绳，耗时 30~40min[2]，遇到更大型的船舶，缆绳的质量、数量和消耗的时间还要增加。另外，传统系缆作业容易发生意外，据不完全统计，每年发生在带缆作业时的人身伤亡事故高达上百起。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20220517140902.png" alt=""></p><p>​        除了直接影响系泊效率和危害人生安全，传统的缆绳系泊方式还具有诸多额外影响。通过缆绳系泊的船舶很难完全固定，在外海波浪和附近船只航行产生波浪的联合作用下，船舶会产生较大的移动，严重影响港口起重机装卸作业效率，增加船舶停靠时间，使得港口经济效益降低，甚至发生断缆等事故。为此，港口不得不修筑防波堤，这无疑增加了码头的建造成本。此外，为了满足带缆角度需要，要求泊位长度大于设计船型一定长度（如图 1.2），无形中占据了码头靠泊的空间，对泊位利用率造成一定影响，此部分码头的工程造价也相当可观。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517140935441.png" alt="image-20220517140935441"></p><p>​        为解决以上问题，需要设计一种用于辅助船舶系泊的码头系泊机械臂，这种机械臂能够实现三自由度直角坐标运动，通过驱动真空吸盘实现靠泊船舶的自动系泊。强大的真空吸附力使船舶紧紧的固定在码头，同时每一个真空吸盘可以有多个自由度，以适应船体表面。机械臂的机械结构需要抵御因波浪、排水、搬卸货物引起的运动。</p><h2 id="国内外研究现状"><a href="#国内外研究现状" class="headerlink" title="国内外研究现状"></a>国内外研究现状</h2><h3 id="国内现状"><a href="#国内现状" class="headerlink" title="国内现状"></a>国内现状</h3><p>​        国内码头仍然采用传统的缆绳系泊方式，尚无自动系泊装置的应用。自动系泊装置的设计基本由国外企业垄断，国内虽然有一部分企业申请了相关专利[3]，不过尚无应用，仅有部分介绍性文章[4]。</p><h3 id="国外现状"><a href="#国外现状" class="headerlink" title="国外现状"></a>国外现状</h3><p>​        目前，自动系泊系统在国外是一个成熟的技术。1999 年，世界上第一台新型自动系泊系统在新西兰问世，经过多年的实践与完善，已在国外有不少成功的案例，英标 BS6349-4: 2014 也介绍了此系统。</p><p>​        该系统主要包括吸盘、机械连杆装置、垂直传动装置和控制系统。该系统利用吸附力代替缆绳拉力限制船舶位移，机械连杆控制真空吸盘在水平方向的纵向和横向运动，进而控制船舶的纵移、横移和回转共 3 个方向的运动量。垂直传动装置一般采用轨道，主要针对潮差变化很大的码头和船闸等，自动系泊系统可根据水位自行调节吸附高度[5]。</p><p>​        国外设计此类装置的企业主要有 Cavotec，Trelleborg，Mampaey 以及 MacGreg 等，其主要性能参数对比汇总如下表所示。</p><div class="table-container"><table><thead><tr><th>名称</th><th>负载能力/kN</th><th>工作范围/mm</th><th>运行功率/kW</th></tr></thead><tbody><tr><td>Cavotec</td><td>(200~400)×100</td><td>1000×1000×400</td><td>20~50</td></tr><tr><td>Trelleborg</td><td>200×(-)</td><td>2100×1000×500</td><td>7</td></tr><tr><td>Mampaey</td><td>130×320</td><td>300×1600×450</td><td>30</td></tr></tbody></table></div><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517141112145.png" alt="image-20220517141112145"></p><p>​        Cavotec 是一家总部位于瑞士的工程集团，该公司生产的 MoorMaster™ 应用广泛，已在全球 50 个地区安装了超过 275 台[6]。MoorMaster™ 系列产品属于真空吸盘式自动系泊系统，可在几秒内吸住和释放船舶，提供单台 2 吨的吸力。2007 年，他们将此装置应用于船闸中，节省通航时间并为工作人员提供安全的环境；2016 年，他们与芬兰瓦锡兰公司合作开发首个无线充电自动系泊系统，有效降低实物连线的维护成本。</p><p>​        Trelleborg 是一家瑞典企业，其生产的 AutoMoor 是一种真空吸盘式自动系泊系统[7]。他们的 SmartPort 平台可以将众多港口设施互联互通，进一步提高港口效率。此外，他们还为大型船舶设计了单台吸力高达 40 吨的双吸盘装置。</p><p>​        Mampaey 公司开发的 intelligent Docklocking System® 是一种磁力式自动系泊系统[8]。该系统主要应用于燃料船的靠泊，该装置由液压缸带动永磁体移动，并在表面覆盖一层耐磨材料。该装置能够将其自身折叠，减小占用空间。</p><p>​        MacGregor 开发了一种机械式的自动系泊装置，与上述装置不同，该装置需要在船舶船身安装与之相匹配的装置[9]。</p><h2 id="研究意义"><a href="#研究意义" class="headerlink" title="研究意义"></a>研究意义</h2><p>​        随着全球经济的不断发展，海上物流的需求不断增加，对船舶周期加快的要求也越来 越高，低效、安全系数比较低的传统系泊方式逐渐无法适应，因此急需一种更高效、更安 全的系泊方式。自动系泊系统（如图 1.4 ）是一种很好的解决方案，该系统无需缆绳即可完 成系泊操作，能够有效解决上述的多种问题，它具有以下几种现实意义：</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517141205779.png" alt="image-20220517141205779"></p><p>​        （1）为船员提供了更加安全的工作环境：自动系泊系统采用吸盘代替绳索，使得工作人员可以通过远程控制系统操作，消除了船员和码头上带缆工人的安全威胁，为他们提供了一个更加安全可靠的工作环境。同时，通过对机械臂上液压装置的压力检测，可以对系泊状态进行实时监控，保证了工作人员可以了解系泊状态。</p><p>​        （2）使得港口作业更加高效：自动系泊系统由于无需调整前后系缆使得缆绳受力均匀，只需要控制机械臂到达指定位置并吸附船体，使得系泊操作难度大大降低，系泊时间也大大减小，由小时级减小到分钟级。同时，由于吸附力使船舶紧紧的固定在码头，系泊船舶的运动量比缆绳系缆小，船上货物的位置比较稳定，货物装卸效率提高。缩短了船舶系泊与等待的时间，提高了码头的使用率。</p><p>​        （3）减少港口建设与运营成本：由于机械臂真空吸盘吸附于船舶的中间部分，因此船首和船尾可以伸出码头，同时也无需为揽桩预留多余的空间，码头靠泊空间得以减小，码头利用率增加，相当于减少了码头的工程建设成本。同时，由于只需要工作人员操纵机械臂，大大减少了码头运营的人力成本。</p><h2 id="主要设计内容"><a href="#主要设计内容" class="headerlink" title="主要设计内容"></a>主要设计内容</h2><p>​        本设计的目的是为船舶系泊提供一种新型解决方案，设计出符合要求的船舶系泊辅助机械臂，建立相关模型后对其关键机构进行有限元分析。</p><p>​        这种机械臂能够实现三自由度直角坐标运动，通过驱动真空吸盘实现靠泊船舶的自动系泊，外观合理美观，性能良好，比传统系泊方式高效、安全以及节能。</p><p>​        设计主要内容可以分为以下部分，全文的结构组织框图如图 1.5 所示：</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20220517141345.png" alt=""></p><p>​        （1）机械臂的总体方案设计：对本项目需要完成的系泊任务以及工作环境进行分析，确定机械臂的性能指标，包括工作区间、负载能力、重复定位精度等，并提出可行的系泊机械臂总体方案。</p><p>​        （2）机械臂的运动学和动力学分析：使用 D-H 参数法建立机械臂的运动学模型，利用牛顿—欧拉迭代方程建立机械臂动力学模型，计算各个关节所需驱动力。</p><p>​        （3）机械臂的结构设计：对机械臂进行执行元件的选型，运用 SolidWorks 软件对系泊机械臂支承装置、传动装置和真空吸盘进行结构设计。</p><p>​        （4）机械臂的分析与优化：对所设计系泊机械臂通过 ANSYS 软件进行有限元分析，分析其是否满足设计要求，对不满足的零部件进行改进。对机械臂进行经济性分析。</p><h1 id="第-2-章-总体方案设计"><a href="#第-2-章-总体方案设计" class="headerlink" title="第 2 章 总体方案设计"></a>第 2 章 总体方案设计</h1><p>​        本章主要进行船舶辅助系泊机械臂的总体方案设计。系泊机械臂的设计主要需要考虑到船舶的运动与风力、水流等外负载。本章首先对系泊作业工作状况进行分析，明确系泊机械臂的工作原理；然后对系泊机械臂工作行程、负载能力和定位精度进行分析与确定；最后，确定了系泊机械臂的总体设计方案。</p><h2 id="自动系泊系统工作原理"><a href="#自动系泊系统工作原理" class="headerlink" title="自动系泊系统工作原理"></a>自动系泊系统工作原理</h2><h3 id="船舶运动及外载荷分析"><a href="#船舶运动及外载荷分析" class="headerlink" title="船舶运动及外载荷分析"></a>船舶运动及外载荷分析</h3><p>​        船舶停靠在码头上后主要受到风力和水流的作用。除此之外还受到潮汐、排水、装卸货物等外在环境的影响。在外力作用下，船舶可进行纵荡、横荡、垂荡、横摇、纵摇、首摇 6 个自由度的运动，如图 2.1 所示。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517141618046.png" alt="image-20220517141618046"></p><p>​        对于船舶系泊，垂荡不会对货物的装卸产生影响，因此无需进行考虑。同时，在大型船舶满载的情况下，由于船舶惯性较大，船舶横摇和纵摇幅度较小，对系统影响小，可以忽略不计。根据以上分析，船舶在系泊作业中主要受到 <em>x</em> 和 <em>y</em> 方向上的力，系泊机械臂主要承受这两个方向的负载。根据 Mampaey 公司的计算分析，对于一艘长 134.9m，排水 11562m³ 的船舶，当风沿 45° 时船舶所需拉力取最大值，<em>x</em> 和 <em>y</em> 方向最大拉力约为 35kN 和 150kN。</p><h3 id="自动系泊系统工作状态"><a href="#自动系泊系统工作状态" class="headerlink" title="自动系泊系统工作状态"></a>自动系泊系统工作状态</h3><p>​        自动系泊系统采用液压传动，通过真空吸盘产生的吸附力代替缆绳的拉力。系泊作业时，机械臂有两种工作状态：</p><p>​        （1）船舶系泊前：机械臂控制真空吸盘到达预期位置，以接合船只的平面部分。真空吸盘的真空泵启动，根据船舶的类型和等级，使其吸附力达到适宜的真空级别。为了方便说明，参考国外同类产品技术资料[10]，定义各方向如图 2.2 所示。此时机械臂控制在横向、竖直方向和纵向三个方向上的移动。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517141653324.png" alt="image-20220517141653324"></p><p>​        （2）船舶系泊中：一旦真空吸盘吸附在船体上时，真空吸盘被抽真空，以实现船只的固定。真空吸盘上竖直方向的控制关闭，即允许船舶和真空吸盘沿竖直方向自由移动，其余方向对船舶施加力使其固定。同时，控制系统开始对横向和纵向位置进行检测，若超出定位精度，液压缸将施加恢复力使得船舶固定。</p><p>​        机械臂的每个真空吸盘可以有多个自由度，使其有一定程度的被动转动，能够与船舶表面更好的贴合。例如船只左舷和右舷之间的载荷差异，可使船身表面有一定的转动。当机械臂运行至极限位置时，控制系统将以步进的方式交替移动各个机械臂，当负载过大无法步进时，系统会向船只及岸上人员发送警报；当受到外力使船舶有与机械臂分离或相对滑动的运动趋势时，并且这种力大于真空吸盘吸附力时，系统可提高真空吸盘内的真空度，从而提高真空吸盘与船只的保持强度，来保证船舶的安全系泊。</p><h2 id="系泊机械臂关键参数的确定"><a href="#系泊机械臂关键参数的确定" class="headerlink" title="系泊机械臂关键参数的确定"></a>系泊机械臂关键参数的确定</h2><h3 id="系泊机械臂工作行程的确定"><a href="#系泊机械臂工作行程的确定" class="headerlink" title="系泊机械臂工作行程的确定"></a>系泊机械臂工作行程的确定</h3><p>​        （1）横向：港口码头设有护舷，以防止船舶冲撞损坏码头，系泊机械臂的横向伸出时应超过护舷长度，以便真空吸盘与船体贴合。同时，为了方便机械臂的维修与管理，机械臂缩回时应留在码头。因此，系泊机械臂的横向行程应为 500mm。</p><p>​        （2）竖直方向：虽然竖直方向需要考虑潮汐、装卸货物、压排水的影响，需要足够的工作行程。不过，当其运行至极限位置时，机械臂群可以以步进的方式重新定位。因此系泊机械臂的竖直方向行程应为 1000mm。</p><p>​        （3）纵向：机械臂对纵向移动要求较低，无需较大的行程，因此系泊机械臂的纵向行程应为 500mm。</p><h3 id="系泊机械臂负载能力的确定"><a href="#系泊机械臂负载能力的确定" class="headerlink" title="系泊机械臂负载能力的确定"></a>系泊机械臂负载能力的确定</h3><p>​        船舶系泊时需要一组机械臂进行配合。假设每隔 15m 设置一个机械臂，对于一艘 134.9m 长的船只，需要 8 只机械臂为船只提供拉力。</p><p>​        （1）横向：横向为主要受力方向，系泊机械臂真空吸盘需要克服使船舶有与机械臂分离的横向力，根据上述分析，参考国外公司产品性能参数，横向最大负载可设为 200kN。</p><p>​        （2）竖直方向：竖直方向虽然正常工作时不受载，但是在到达临界位置时机械臂交替步进时会承受一定的拉力，为安全起见，取其负载为 25kN。</p><p>​        （3）纵向：系泊机械臂真空吸盘还需要克服使吸盘与船体相对滑动的纵向力。根据上述分析，参考国外公司产品性能参数，纵向最大负载可设为 100kN。</p><h3 id="系泊机械臂定位精度的确定"><a href="#系泊机械臂定位精度的确定" class="headerlink" title="系泊机械臂定位精度的确定"></a>系泊机械臂定位精度的确定</h3><p>​        系泊机械臂传动机构使真空吸盘到达指定位置，与船只进行贴合，其定位精度对船舶系泊影响较小，因此系泊机械臂的对定位精度无很高要求。参考国外各公司产品性能参数（如下表），取各个方向定位精度为 40mm。</p><div class="table-container"><table><thead><tr><th>参数</th><th>横向</th><th>竖直方向</th><th>纵向</th></tr></thead><tbody><tr><td>工作行程/mm</td><td>500</td><td>1000</td><td>500</td></tr><tr><td>负载能力/kN</td><td>200</td><td>25</td><td>100</td></tr><tr><td>定位精度/mm</td><td>40</td><td>40</td><td>40</td></tr></tbody></table></div><h2 id="系泊机械臂的构型设计"><a href="#系泊机械臂的构型设计" class="headerlink" title="系泊机械臂的构型设计"></a>系泊机械臂的构型设计</h2><p>​        系泊机械臂采用直角坐标机械臂，各个关节独立控制，在控制上比较简单。机械臂提供三个自由度，构型为 PPP。系泊机械臂主要由驱动装置、支承装置、传动装置和真空吸盘组成。由于处于重载环境，因此采用液压驱动。传动装置能够在横向、竖直方向和纵向实现真空吸盘的定位。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517141725009.png" alt="image-20220517141725009"></p><p>​        结合实际工况要求，并参考相关设计案例[11-12]，拟采用如图 2.3 所示设计方案。系泊机械臂支承装置采用框架式钢结构，由型钢连接而成。横向液压缸固定在支承装置上进行伸缩运动，驱动真空吸盘沿横向运动。此液压缸末端连接导轨，导轨由液压缸连接链条驱动，使真空吸盘沿竖直方向运动。由于竖直方向受力较小，行程较大，为了缩小装置体积，拟采用含有动滑轮的增程机构。链条末端固定一双杆液压缸，以实现真空吸盘的纵向移动。传动装置与真空吸盘通过外球面球轴承连接，使得真空吸盘可以绕横向、竖直方向和纵向进行一定角度的转动。</p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>​        本章针对系泊机械臂的负载和工作原理进行分析，明确了系泊机械臂的工况要求和实现功能；根据其工作特点，确定了其横向、竖直方向和纵向三个方向的工作行程、负载能力和定位精度等关键参数；最后，对机械臂构型和主要执行机构及其动作的实现进行了讨论和确定。</p><h1 id="第-3-章-运动学、动力学分析"><a href="#第-3-章-运动学、动力学分析" class="headerlink" title="第 3 章 运动学、动力学分析"></a>第 3 章 运动学、动力学分析</h1><p>​        运动学是机械臂位置、姿态运动和轨迹规划的基础，从而可以设计出能够完成指定任务的机械臂。动力学可以得到机械臂作业末端要求的输出力和各关节驱动力之间的关系，是机械臂控制中必须考虑的问题。</p><h2 id="系泊机械臂运动学分析"><a href="#系泊机械臂运动学分析" class="headerlink" title="系泊机械臂运动学分析"></a>系泊机械臂运动学分析</h2><p>​        机器人运动学研究机械臂的运动特性，而不考虑使机械臂运动产生的力，包括正运动学和逆运动学两类基本问题。</p><h3 id="系泊机械臂正运动学分析"><a href="#系泊机械臂正运动学分析" class="headerlink" title="系泊机械臂正运动学分析"></a>系泊机械臂正运动学分析</h3><p>​        系泊机械臂可以看作一段固定在码头、通过一系列连杆由关节串联形成的运动链，本文采用 Craig 提出的改进 D-H 参数法建立系泊机械臂的数学模型。由于横向液压缸既有移动又有转动，同时竖直方向液压缸关节轴方向固定，为方便计算，将其简化为两个移动关节。各连杆坐标系的分布如图 3.1 所示。改进 D-H 参数法使用 4×4 的齐次变换矩阵描述相邻连杆上坐标系的变换关系，继而推导出机械臂末端执行器真空吸盘相对于工具台坐标系 {<em>S</em>} 的位姿关系。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517141911864.png" alt="image-20220517141911864"></p><p>​        根据图 3.1 各连杆坐标系的分布关系，系泊机械臂的 D-H 参数如下表所示。</p><div class="table-container"><table><thead><tr><th>连杆 $i$</th><th>$a_{i-1}$/mm</th><th>$α_{i-1}$/°</th><th>$d_i$/mm</th><th>$θ_i$/°</th></tr></thead><tbody><tr><td>$1_V$</td><td>0</td><td>0</td><td>$d_1\sinθ_1$</td><td>0</td></tr><tr><td>$1_H$</td><td>0</td><td>-90</td><td>$*d_1\cosθ_1$</td><td>0</td></tr><tr><td>2</td><td>0</td><td>-90</td><td>$d_2$</td><td>-90</td></tr><tr><td>3</td><td>0</td><td>90</td><td>$d_3$</td><td>0</td></tr></tbody></table></div><p>​        表中各个变量意义如下所示：</p><p>​        $a_i$——杆长，沿 $X_i$ 轴，从 $Z_i$ 移动到 $Z_{i+1}$ 的距离；</p><p>​        $α_i$——扭转角，绕 $X_i$ 轴，从 $Z_i$ 旋转到 $Z_{i+1}$ 的角度；</p><p>​        $d_i$——偏距，沿 $Z_i$ 轴，从 $X_{i-1}$ 移动到 $X_i$ 的距离；</p><p>​        $θ_i$——关节角，绕 $Z_i$ 轴，从 $X_{i-1}$ 旋转到 $X_i$ 的角度。</p><p>​        根据改进的 D-H 参数法，相邻杆件坐标变换关系通式为</p><script type="math/tex; mode=display">{ }_{i}^{i-1} T=\left[\begin{array}{cccc}\cos \theta_{i} & -\sin \theta_{i} & 0 & a_{i-1} \\\sin \theta_{i} \cos \alpha_{i-1} & \cos \theta_{i} \cos \alpha_{i-1} & -\sin \alpha_{i-1} & -\sin \alpha_{i-1} d_{i} \\\sin \theta_{i} \sin \alpha_{i-1} & \cos \theta_{i} \sin \alpha_{i-1} & \cos \alpha_{i-1} & \cos \alpha_{i-1} d_{i} \\0 & 0 & 0 & 1\end{array}\right]</script><p>​        将 D-H 参数表中数据带入式 $(1)$ 可以分别求得  ，因此系泊机械臂在基坐标系 {<em>B</em>} 下的正运动学方程为</p><script type="math/tex; mode=display">{ }_{3}^{0} T={ }_{1_{\mathrm{v}}}^{0} T_{1_{\mathrm{H}}}^{1_{\mathrm{v}}} T_{2}^{1_{\mathrm{H}}} T_{3}^{2} T=\left[\begin{array}{cccc}0 & 0 & -1 & -d_{3} \\1 & 0 & 0 & d_{1} \cos \theta_{1} \\0 & -1 & 0 & d_{1} \sin \theta_{1}-d_{2} \\0 & 0 & 0 & 1\end{array}\right]</script><p>​        系泊机械臂腕部坐标系 {<em>W</em>} 相对于工具台坐标系 {<em>S</em>} 的变换方程为</p><script type="math/tex; mode=display">{ }_{W}^{S} T={ }_{B}^{S} T_{W}^{B} T={ }_{B}^{S} T_{3}^{0} T=\left[\begin{array}{cccc}1 & 0 & 0 & d_{1} \cos \theta_{1} \\0 & -1 & 0 & L+d_{1} \sin \theta_{1}-d_{2} \\0 & 0 & -1 & -d_{3} \\0 & 0 & 0 & 1\end{array}\right]</script><p>​        由于系泊机械臂只有 3 个自由度，即 $θ_1$ 可以由 $d_1$ 表示，对平行四连杆机构进行分析，可以得到机构简图如图 3.2 所示。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517142008714.png" alt="image-20220517142008714"></p><p>​        以横向液压缸底座为原点建立坐标系，可以写出 <em>A</em> 和 <em>B</em> 点的坐标，利用这两点的距离公式建立等式</p><script type="math/tex; mode=display">(l_1-d_1\cos\theta_1)^2+(h-d_1\sin\theta_1)^2=l_2^2</script><p>式中    $l_1$——机械臂液压缸底座到支承装置外边缘的距离；</p><p>​            $h$——横向液压缸活塞杆到竖直方向液压缸导槽结构的距离；</p><p>​            $l_2$——机械臂摇板长度。</p><p>​        将 $θ_1$ 用 $d_1$ 表示可以得到</p><script type="math/tex; mode=display">\begin{aligned}\theta_{1}=& 2 \operatorname{atan}(( l _ { 1 } ^ { 2 } + 2 l _ { 1 } d _ { 1 } + d _ { 1 } ^ { 2 } + h ^ { 2 } - l _ { 2 } ^ { 2 } ) ^ { - 1 } (2 d_{1} h-(-l_{1}^{4}+2 l_{1}^{2} d_{1}^{2}\\&-2 l_{1}^{2} h^{2}+2 l_{1}^{2} l_{2}^{2}-d_{1}^{4}+2 d_{1}^{2} h^{2}+2 d_{1}^{2} l_{2}^{2}-h^{4}+2 h^{2} l_{2}^{2}-l_{2}^{4})^{0.5}))\end{aligned}</script><h3 id="系泊机械臂逆运动学析"><a href="#系泊机械臂逆运动学析" class="headerlink" title="系泊机械臂逆运动学析"></a>系泊机械臂逆运动学析</h3><p>​        机器人逆运动学的求解方法主要有封闭解法和数值解法两种。封闭解法根据在末端执行器位姿，给出每个关节变量的数学函数表达式，包含代数解法和几何解法。数值法则用递推算法给出关节变量的具体数值。由于该机械臂封闭解法表达式十分复杂，本文使用数值解法进行求解。</p><p>​        已知基坐标系下机械臂末端执行器位置 $[p_x,p_y,p_z]^T$，求关节截距 $[d_1,d_2,d_3]^T$ 。</p><p>​        式 $(3)$ 中变换矩阵第 4 列为机械臂末端执行器的位置矢量，因此有</p><script type="math/tex; mode=display">p_x=&d_1\cos\theta\\p_y=&L+d_1\sin\theta_1-d_2\\p_z=&-d_3</script><p>​        根据式 $(5)$ 和式 $(6)$，构造迭代算法，其程序框图如图 3.3 所示</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517142052719.png" alt="image-20220517142052719"></p><h3 id="系泊机械臂关节速度求解"><a href="#系泊机械臂关节速度求解" class="headerlink" title="系泊机械臂关节速度求解"></a>系泊机械臂关节速度求解</h3><p>​        机械臂每一个连杆的运动都与它的相邻连杆有关。根据相邻杆件的分析，可以得到杆间速度传递公式为</p><script type="math/tex; mode=display">\begin{array}{c}{ }^{i+1} \omega_{i+1}={ }_{i}^{i+1} R^{i} \omega_{i} \\{ }^{i+1} v_{i+1}={ }_{i}^{i+1} R\left({ }^{i} v_{i}+{ }^{i} \omega_{i} \times{ }^{i} P_{i+1}\right)+\dot{d}_{i+1}{ }^{i+1} \hat{Z}_{i+1}\end{array}</script><p>式中    ${ }_{i}^{i+1} R$——由 <em>i</em> 到 <em>i</em>+1 旋转变换矩阵；</p><p>​            ${ }^{i} P_{i+1}$——{<em>i</em>} 坐标系下 {<em>i</em>+1} 坐标系原点的坐标。</p><p>​        由式 $(7)$ 可以推导出工作台坐标系下关节速度和机械臂末端速度的关系</p><script type="math/tex; mode=display">{ }^{S} v=\left[\begin{array}{c}{ }^{S} v_{x} \\{ }^{S} v_{y} \\{ }^{S} v_{z}\end{array}\right]=\left[\begin{array}{c}\dot{d}_{1} \cos \theta_{1}-d_{1} \sin \theta_{1} \\\dot{d}_{1} \sin \theta_{1}+d_{1} \cos \theta_{1}-\dot{d}_{2} \\-\dot{d}_{3}\end{array}\right]</script><h3 id="系泊机械臂运动学仿真"><a href="#系泊机械臂运动学仿真" class="headerlink" title="系泊机械臂运动学仿真"></a>系泊机械臂运动学仿真</h3><p>​        为验证系泊机械臂正、逆运动学的正确性，使用 python 库 manim 进行运动学仿真。首先为偏距 $d_1$，$d_2$，$d_3$ 规划了运动轨迹，如图 3.4 所示。通过正运动学求解，得到机械臂各关节在工作空间的运动轨迹，如图 3.5 所示，$d_3$ 旁圆点为由正运动学计算得到的空间采样点。然后，将正运动学得到的机械臂末端执行器位姿带入逆运动学表达式中，解得每个采样带点对应的偏距，将其与规划值进行比较，结果如下表所示。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517144453344.png" alt="image-20220517144453344"></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517144509554.png" alt="image-20220517144509554"></p><div class="table-container"><table><thead><tr><th>$d_1$ 设计值/m</th><th>$d_1$ 计算值/m</th><th>$d_2$ 设计值/m</th><th>$d_2$ 计算值/m</th><th>$d_3$ 计算值/m</th><th>$d_3$ 计算值/m</th></tr></thead><tbody><tr><td>1.004089</td><td>1.0031</td><td>0.003578</td><td>0.003574</td><td>0.003067</td><td>0.003067</td></tr><tr><td>1.012316</td><td>1.0114</td><td>0.010776</td><td>0.010765</td><td>0.009237</td><td>0.009237</td></tr><tr><td>1.027364</td><td>1.0264</td><td>0.023943</td><td>0.023917</td><td>0.020523</td><td>0.020523</td></tr><tr><td>1.054215</td><td>1.0533</td><td>0.047438</td><td>0.047389</td><td>0.040661</td><td>0.040661</td></tr><tr><td>1.100072</td><td>1.0991</td><td>0.087563</td><td>0.087466</td><td>0.075054</td><td>0.075054</td></tr><tr><td>1.172822</td><td>1.1719</td><td>0.151219</td><td>0.151058</td><td>0.129616</td><td>0.129616</td></tr><tr><td>1.275741</td><td>1.2748</td><td>0.241273</td><td>0.241007</td><td>0.206806</td><td>0.206806</td></tr><tr><td>1.400000</td><td>1.399</td><td>0.350000</td><td>0.349577</td><td>0.300000</td><td>0.300000</td></tr><tr><td>1.524259</td><td>1.5233</td><td>0.458727</td><td>0.458176</td><td>0.393194</td><td>0.393194</td></tr><tr><td>1.627178</td><td>1.6261</td><td>0.548781</td><td>0.548015</td><td>0.470384</td><td>0.470384</td></tr><tr><td>1.699928</td><td>1.6988</td><td>0.612437</td><td>0.611517</td><td>0.524946</td><td>0.524946</td></tr><tr><td>1.745785</td><td>1.7447</td><td>0.652562</td><td>0.651600</td><td>0.559339</td><td>0.559339</td></tr><tr><td>1.772636</td><td>1.7715</td><td>0.676057</td><td>0.675000</td><td>0.579477</td><td>0.579477</td></tr><tr><td>1.787684</td><td>1.7865</td><td>0.689224</td><td>0.688093</td><td>0.590763</td><td>0.590763</td></tr><tr><td>1.795911</td><td>1.7948</td><td>0.696422</td><td>0.695346</td><td>0.596933</td><td>0.596933</td></tr></tbody></table></div><p>​        误差在允许范围内，符合设计要求，验证了机械臂正逆运动学求解的正确性。</p><h2 id="系泊机械臂动力学分析"><a href="#系泊机械臂动力学分析" class="headerlink" title="系泊机械臂动力学分析"></a>系泊机械臂动力学分析</h2><p>​        动力学主要研究产生运动所需要的力。本文使用牛顿—欧拉法，该算法由两部分组成。第一部分是对每个连杆应用牛顿—欧拉方程，从连杆 0 到连杆 <em>n</em>-1 向外迭代计算连杆的速度和加速度。第二部分是从连杆 <em>n</em> 到连杆 1 向内迭代计算连杆间的相互作用力和力矩以及驱动力和力矩。该算法的计算公式为</p><script type="math/tex; mode=display">\begin{array}{l}i: 0 \rightarrow 2\\{ }^{i+1} \dot{\omega}_{i+1}=&{ }_{i}^{i+1} R^{i} \dot{\omega}_{i}\\{ }^{i+1} \dot{v}_{i+1}=&{ }_{i}^{i+1} R\left({ }^{i} \dot{\omega}_{i} \times{ }^{i} P_{i+1}+{ }^{i} \omega_{i} \times\left({ }^{i} \omega_{i} \times{ }^{i} P_{i+1}\right)+{ }^{i} \dot{v}_{i}\right)\\&+2{ }^{i+1} \omega_{i+1} \times \dot{d}_{i+1}{ }^{i+1} \hat{Z}_{i+1}+\ddot{d}_{i+1}{ }^{i+1} \hat{Z}_{i+1}\\{ }^{i+1} \dot{v}_{C_{i+1}}=&{ }^{i+1} \dot{\omega}_{i+1} \times{ }^{i+1} P_{C_{i+1}}+{ }^{i+1} \omega_{i+1} \times\left({ }^{i+1} \omega_{i+1}+{ }^{i+1} P_{C_{l+1}}\right)\\&+{ }^{i+1} \dot{v}_{i+1}\\{ }^{i+1} F_{i+1}=&m_{i+1}{ }^{i+1} \dot{v}_{C_{i+1}}\\i: 3 \rightarrow 1_V\\{ }^{i} f_{i} =&{ }_{i+1}^{i} R^{i+1} f_{i+1}+{ }^{i} F_{i} \\\tau_{i}=&{ }^{i} f_{i}^{T i} \hat{Z}_{i}\end{array}</script><p>式中    ${ }^{i+1} \dot{v}_{C_{i+1}}$——{<em>i</em>+1} 坐标系下连杆质心加速度和质心矢量；</p><p>​            ${ }^{i} P_{i+1}$——{<em>i</em>+1} 坐标系下连杆质心矢量；</p><p>​            ${ }^{i+1} F_{i+1}$——为作用在 <em>i</em>+1 连杆上的惯性力，${ }^{i}f_{i}$为连杆 <em>i</em>-1 作用在连杆 <em>i</em> 上的力，$\tau_i$ 为关节驱动力。</p><p>​        假设各连杆质量均匀分布，其质量为 $m_{1V}$、$m_{1H}$、$m_2$  和 $m_3$，考虑重力因素有­­­  ${}^0\dot v_0=-g\hat Y_0$ ，机械臂末端执行器真空吸盘受外力  ，由式 $(9)$得关节驱动力</p><script type="math/tex; mode=display">\left[\begin{array}{c}\tau_1\\\tau_2\\\tau_3\\\end{array}\right]=\left[\begin{array}{c}\sqrt{\tau_{1V}^2+\tau_{1H}^2}\\\tau_2\\\tau_3\\\end{array}\right]</script><p>式中    $\tau_{1 \mathrm{~V}} =-f_{y}+\left(m_{1 \mathrm{~V}}+m_{1 \mathrm{H}}+m_{2}+m_{3}\right)\left(\ddot{d}_{1} \sin \theta_{1}+2 \dot{d}_{1} \cos \theta_{1}-d_{1} \sin \theta_{1}+g\right)$</p><p>​            $\tau_{1 \mathrm{H}}=f_{x}-\left(m_{1 \mathrm{H}}+m_{2}+m_{3}\right)\left(-\ddot{d}_{1} \cos \theta_{1}+2 \dot{d}_{1} \sin \theta_{1}+d_{1} \cos \theta_{1}\right)$</p><p>​            $\tau_{2}=f_{y}+\left(m_{2}+m_{3}\right)\left(\ddot{d}_{2}-\ddot{d}_{1} \sin \theta_{1}-2 \dot{d}_{1} \cos \theta_{1}+d_{1} \sin \theta_{1}-g\right)$</p><p>​            $\tau_{3} =f_{z}+m_{3} \ddot{d}_{3}$</p><p>​        系泊机械臂支承装置在工具台坐标系 {<em>S</em>} 下需要承受的力 ${}^SF_N = [{}^SF_{Nx}\ {}^SF_{Ny}\ {}^SF_{Nz}]^T$为</p><script type="math/tex; mode=display">{ }^{S} F_{N}={ }_{B}^{S} R^{B} F_{N}={ }_{B}^{S} F^{0} F_{N}=\left[\begin{array}{c}\tau_{1 \mathrm{H}} \\\tau_{1 \mathrm{~V}}-\tau_{2}+f_{y} \\-\tau_{3}\end{array}\right]</script><h2 id="本章小结-1"><a href="#本章小结-1" class="headerlink" title="本章小结"></a>本章小结</h2><p>​        本章首先使用改进 D-H 参数法对系泊机械臂建立数学模型，完成正、逆运动学计算以及关节速度的求解。然后利用 python 库 manim 对正、逆运动学结果进行仿真，验证其正确性。最后使用牛顿­—欧拉法建立了机械臂的动力学模型，求解得到机械臂关节驱动力的动力学方程以及机械臂支承装置需要承受的力。</p><h1 id="第-4-章-结构设计"><a href="#第-4-章-结构设计" class="headerlink" title="第 4 章 结构设计"></a>第 4 章 结构设计</h1><p>​        本章将选择系泊机械臂三个关节对应的执行元件，对主体机构以及其他零部件进行结构设计及受力分析，确定其具体结构和详细尺寸，并使用 SolidWorks 进行三维建模，绘制装配图、零件图。</p><h2 id="执行元件的选择"><a href="#执行元件的选择" class="headerlink" title="执行元件的选择"></a>执行元件的选择</h2><p>​        系泊机械臂的三个关节均采用液压传动。与其他传动方式相比，液压传动具有以下优点：（1）液压传动能够输出大推力和大转矩，系泊机械臂系泊船只时需要承受很大的负载，液压传动承载能力大，同时很容易可以实现过载保护，而其他传动方式往往受到限制；（2）液压传动实现直线运动简单且易控，电气技术实现直线运动繁琐且昂贵的，而液压传动操作简单，同时在控制方面很便捷，容易实现自动化；（3）液压传动平稳可靠，可大范围无级调速。</p><p>​        机械臂需要实现双向运动，同时考虑到机械结构形式。横向设置两个液压缸，均为双作用单杆活塞缸，使用耳环连接的方式安装；竖直方向设置一个双作用单杆活塞缸，使用法兰连接；纵向设置一个双杆活塞缸，采用底座型的安装方式。</p><h3 id="系统压力的确定"><a href="#系统压力的确定" class="headerlink" title="系统压力的确定"></a>系统压力的确定</h3><p>​        系统在工作时，基本上处于静止状态，横向和纵向惯性力 $F_g$ 和摩擦力 $F_f$ 可以忽略不记，竖直方向只受惯性力和摩擦力。由于竖直方向采用含动滑轮的增程机构，液压缸负载需要增加一倍。三个方向的最大拉力分别取为 $F_{Nx}$ = 200kN、$F_{Nz}$ = 100kN，为安全起见，取 $F_{Ny}$ = 50kN。液压缸的工作负载为</p><script type="math/tex; mode=display">F_R=\frac{F_N+F_f+F_g}{n\eta}</script><p>式中    <em>n</em>——液压缸数量；</p><p>​            <em>η</em>——传动效率，取 <em>η</em> = 0.85。</p><p>​        由式 $(12)$，三个关节液压缸工作负载分别为 118kN、59kN 和 118kN。</p><p>​        根据《现代机械设计手册》液压传动与控制部分[16]的相关理论，按照负载和设备类型选择工作压力，系泊机械臂属于重型机械，该机械常用系统工作压力为 20~30MPa ，由于系泊机械臂位置固定、尺寸不受限，因此压力选择低一些，并综合考虑液压设备的尺寸和重量、元件强度、容积效率、系统可靠性、系统使用寿命等各方面因素，选择系统压力为 <em>p</em> = 25MPa。</p><h3 id="执行元件几何参数的确定"><a href="#执行元件几何参数的确定" class="headerlink" title="执行元件几何参数的确定"></a>执行元件几何参数的确定</h3><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517154346514.png" alt="image-20220517154346514"></p><p>​        （1）缸筒内径</p><p>​        缸筒内径即活塞外径，是液压缸的主要参数，根据液压缸推力要求计算缸筒内径。为得到所要求的推力 $F_R$ ，应使</p><script type="math/tex; mode=display">pA\eta_{cm}=F_R</script><p>式中    <em>p</em>——作用在活塞上的有效压力（Pa），<em>p</em>应比液压缸额定压力小，取 <em>p</em> = 20MPa；</p><p>​            <em>A</em>——液压缸的有效工作面积 （m$^2$），<em>A</em> = $πD^2/4$；</p><p>​            $η_{cm}$——液压缸的机械效率，取 $η_{cm}$ = 0.95； </p><p>​            $F_R$ ——液压缸推力（N）。</p><p>​        计算得缸筒内径 <em>D</em> 为</p><script type="math/tex; mode=display">D=\sqrt{\frac{4F_R}{\pi p\eta_{cm}}}=\left[\begin{array}{c}89\\63\\89\end{array}\right]\text{mm}</script><p>​        为安全起见，适当增加缸筒内径并圆整为标准值为 100mm、80mm 和 100mm。</p><p>​        （2）活塞杆直径</p><p>​        设计要求不涉及到速度比，因此按照活塞杆受力状况来确定。活塞杆主要受到拉力作用，有时也会受到压力，活塞杆直径 <em>d</em> = 0.3~0.5<em>D</em>，为安全起见，适当增加活塞杆直径并圆整为标准值，得活塞杆直径分别均为 56mm。由于三者均为长行程液压缸，因此需要进行稳定性校核[17]。</p><p>​        按材料力学理论，当一受压直杆的轴向载荷 <em>F</em> 超过临界受压载荷 $F_K$ 时，即可能失去原有直线状态的平衡，称为失稳。对液压缸，其稳定条件为</p><script type="math/tex; mode=display">F\le\frac{F_K}{n_K}</script><p>式中   $n_K$ ——稳定安全系数，取 $n_K$ = 2。</p><p>​        当细长比 $l/k&gt;m\sqrt n$，用欧拉公式计算临界载荷 $F_K$。即</p><script type="math/tex; mode=display">F_{\mathrm{K}}=\frac{n \pi^{2} E J}{l^{2}}</script><p>​        当细长比 $l/k\le m\sqrt n$，用戈登·兰金公式计算临界载荷 $F_K$。即</p><script type="math/tex; mode=display">F_{\mathrm{K}}=\frac{f A}{1+\frac{a}{n}\left(\frac{l}{K}\right)^{2}}</script><p>式中    <em>l­</em> ——活塞杆计算长度；</p><p>​            <em>E</em>——材料弹性模量，<em>E</em> = 2.1×10$^{11}$Pa；</p><p>​            <em>J</em>——活塞杆横截面转动惯量，<em>J</em> = <em>πd</em>$^4$/64；</p><p>​            <em>K</em>——活塞杆横截面回转半径，<em>K</em> = <em>d</em>/4；</p><p>​            <em>m</em>——柔性系数，活塞杆为 304 不锈钢，取 <em>m</em> = 90；</p><p>​            <em>n</em>——端点安装系数，安装方式为两端铰接，取 <em>n =</em> 1；</p><p>​            <em>f</em>——材料强度实验值，活塞杆为 304 不锈钢，取 <em>f</em> = 340MPa；</p><p>​            A ——活塞杆横截面面积；</p><p>​            <em>a</em> ——实验常量，取 <em>a</em> = 1/7500。</p><p>​        根据稳定条件，横向液压缸由戈登·兰金公式计算得 $F_K$ = 832kN，竖直方向液压缸由欧拉公式计算得 $F_K$ = 454kN，纵向液压缸由欧拉公式计算得 $F_K$ = 445kN，活塞杆直径符合稳定性要求。</p><p>​        （3）实际有效面积</p><p>​        对于无杆腔，有</p><script type="math/tex; mode=display">A_1=\frac{\pi D^2}{4}</script><p>​        对于有杆腔，有</p><script type="math/tex; mode=display">A_1=\frac{\pi (D^2-d^2)}{4}</script><p>​        横向、竖直方向和纵向的液压缸的几何参数如下表所示。</p><div class="table-container"><table><thead><tr><th>液压缸</th><th>数量</th><th>行程/mm</th><th>缸筒内径/mm</th><th>活塞杆直径/mm</th><th>$A_1$/m$^2$</th><th>$A_2$/m$^2$</th></tr></thead><tbody><tr><td>横向</td><td>2</td><td>500</td><td>100</td><td>56</td><td>0.0079</td><td>0.0054</td></tr><tr><td>竖直方向</td><td>1</td><td>500</td><td>80</td><td>56</td><td>0.0050</td><td>0.0026</td></tr><tr><td>纵向</td><td>1</td><td>500</td><td>100</td><td>56</td><td>0.0054</td><td>0.0054</td></tr></tbody></table></div><h3 id="执行元件最大流量的确定"><a href="#执行元件最大流量的确定" class="headerlink" title="执行元件最大流量的确定"></a>执行元件最大流量的确定</h3><p>对液压缸，有</p><script type="math/tex; mode=display">q_\max=Av_\max</script><p>式中    $q_\max$——液压缸所需最大流量；</p><p>​            $v_\max$——活塞杆最大运动速度。</p><p>​        液压缸在空载情况下达到最大速度，速度取值空间比较大，本文以较大速度 $v_\max$ = 0.1m/s 进行计算，横向、竖直方向和纵向的最大流量分别为</p><h3 id="执行元件型号的确定"><a href="#执行元件型号的确定" class="headerlink" title="执行元件型号的确定"></a>执行元件型号的确定</h3><p>​        对比市场分析，选用博世力士乐公司的重载型液压缸，横向液压缸、竖直方向液压缸和纵向液压缸的产品型号分别为 CSH1MP5/100/56/500A3X、CSH3MF4/80/56/500A3X 和 CGH1MS2/100/56/500A3X。</p><h2 id="支承装置的设计"><a href="#支承装置的设计" class="headerlink" title="支承装置的设计"></a>支承装置的设计</h2><p>​        支承装置是系泊机械臂的重要组成部分，它是整台机械臂的骨架，用以装置起机械臂的传动、液压设备，承受作用在系泊机械臂上的各种载荷。系泊机械臂为重载设备，主要承受拉力，大部分杆件属于拉弯构件，部分杆间属于受弯构件。</p><p>​        支承装置属于典型的钢结构，按照 GB 50017-2017《钢结构设计标准》[18]进行设计，其设计基本包括 4 个部分：①结构方案设计，包括结构选型、构件布置；②材料选用及截面选择；③结构的极限状态验算；④结构、构件及连接的设计。</p><p>​        在实际设计中，支承装置结构形式和截面需要在不断优化和修改后确定，流程如图 4.2 所示。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517155648064.png" alt="image-20220517155648064"></p><h3 id="支承装置的总体设计"><a href="#支承装置的总体设计" class="headerlink" title="支承装置的总体设计"></a>支承装置的总体设计</h3><p>​        为了减轻装置的质量，支承装置采用框架式结构。根据支承装置内外零部件的形状和尺寸、配置情况、安装与拆卸等要求，参考同类设计产品，初步确定支承装置的形状和尺寸如图 4.3 所示。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517155717022.png" alt="image-20220517155717022"></p><p>​        该结构由 <em>ACEDB</em> 和 <em>A</em>′<em>C</em>′<em>E</em>′<em>D</em>′<em>B</em>′ 两刚架通过 <em>CC</em>′、<em>DD</em>′、<em>EE</em>′、<em>BD</em>′、<em>B</em>′<em>D</em>、<em>D</em>′<em>E</em> 和 <em>DE</em>′ 焊接而成，<em>C</em> 和 <em>C</em>′为放置横向液压缸的地方，<em>C</em>、<em>C</em>′、<em>D</em>、<em>D</em>′、<em>E</em> 和 <em>E</em>′承受与外界连接的拉力。根据前面的分析与计算，在临界条件下，各方向液压缸达到最大拉力，<em>C</em> 和 <em>C</em>′ 各将承受横向 100kN 的拉力，<em>D</em>、<em>D</em>′、<em>E</em>、<em>E</em>′ 各将承受纵向 25kN 的拉力。</p><h3 id="支承装置的受力分析"><a href="#支承装置的受力分析" class="headerlink" title="支承装置的受力分析"></a>支承装置的受力分析</h3><p>​        （1）支承装置外载荷分析</p><p>​        系泊机械臂受到的基本载荷主要有自重载荷 <em>P</em>G、横向工作载荷 <em>P</em>X、纵向工作载荷 <em>P</em>Z和风载荷 <em>P</em>W。其中，由于机械臂本身体积较小，机械臂垂直于风向的有效迎风面积较小，同时，横向工作载荷和纵向工作载荷很大，风载荷可忽略不计。载荷组合为 <em>P</em>G + <em>P</em>X + <em>P</em>Z。</p><p>​        （2）支承装置的内力计算</p><p>​        由于该结构为多次超静定结构，直接求解十分复杂，因此使用三维钢结构分析和设计软件 STAAD.Pro 进行求解。选择梁单元代替杆系，根据图 4.3 建立结构的几何模型，初选钢材，设置结构的约束和荷载，进行分析和图形后处理，得到结构支反力、轴力、弯矩和剪力，各杆件受力如下表所示，绘图如图 4.4 所示。</p><div class="table-container"><table><thead><tr><th>杆件</th><th>构件类型</th><th>轴力<em>N</em>/kN</th><th>剪力<em>Q</em>/kN</th><th><em>Mx</em>/(kN·m)</th><th><em>My</em>/(kN·m)</th></tr></thead><tbody><tr><td><em>BE</em>、<em>B</em>′<em>E</em>′</td><td>拉（压）弯构件</td><td>55.62</td><td>1.99</td><td>1.39</td><td>4.38</td></tr><tr><td><em>CC</em>′</td><td>受弯构件</td><td>5.14</td><td>19.57</td><td>9.75</td><td>0.42</td></tr><tr><td><em>AC</em>、<em>A</em>′<em>C</em>′</td><td>拉（压）弯构件</td><td>106.36</td><td>2.31</td><td>8.97</td><td>7.66</td></tr><tr><td><em>CD</em>、<em>C</em>′<em>D</em>′</td><td>受弯构件</td><td>8.82</td><td>16.75</td><td>13.17</td><td>10.74</td></tr><tr><td><em>BC</em>、<em>B</em>′<em>C</em>′</td><td>拉（压）弯构件</td><td>143.09</td><td>1.50</td><td>1.61</td><td>2.72</td></tr><tr><td><em>CE</em>、<em>C</em>′<em>E</em>′</td><td>拉（压）弯构件</td><td>1.33</td><td>0.57</td><td>0.67</td><td>2.29</td></tr><tr><td><em>B</em>′<em>D</em>、<em>BD</em>′</td><td>拉（压）弯构件</td><td>46.38</td><td>0.71</td><td>1.33</td><td>2.43</td></tr><tr><td><em>EG</em>、<em>E</em>′<em>G</em></td><td>拉（压）弯构件</td><td>50.48</td><td>0.09</td><td>2.38</td><td>4.09</td></tr><tr><td><em>EE</em>′</td><td>受弯构件</td><td>0.91</td><td>16.76</td><td>4.74</td><td>4.29</td></tr></tbody></table></div><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517160116315.png" alt="image-20220517160116315"></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517160133846.png" alt="image-20220517160133846"></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517160148051.png" alt="image-20220517160148051"></p><p>​        由受力分析可以得到该刚架主要受到轴向力 <em>N</em> 和弯矩 <em>Mx</em>、<em>My</em> 的作用，剪切力 <em>Q</em> 很小，可以忽略不计。支承装置杆系主要包含拉（压）弯构件和受弯构件两种类型的杆件，最大弯矩约为 13kN·m，最大轴力约为 141kN。</p><h3 id="4-2-3支承装置的截面选择"><a href="#4-2-3支承装置的截面选择" class="headerlink" title="4.2.3支承装置的截面选择"></a>4.2.3支承装置的截面选择</h3><p>​        根据国外有关资料和使用经验，全部采用 Q345B 材料。</p><p>​        对于拉（压）弯构件，同时承受轴向力 <em>N</em> 和弯矩 <em>M</em> 的作用，根据计算所需截面面积 <em>A</em>，选取满足要求的型钢。根据经验公式，即</p><script type="math/tex; mode=display">A\ge\frac{\alpha N}{\beta[\sigma]}</script><p>式中    <em>α</em>——考虑弯矩影响的轴力增大系数，有横向力作用，取 <em>α</em> = 2.0；</p><p>​            <em>β</em>——考虑截面有局部钉孔销削弱的减损系数，支承机构为全焊结构，根据设计经验，取 <em>β</em> = 1；</p><p>​            [<em>σ</em>] ——材料许用应力，取 [<em>σ</em>] = 305MPa。</p><p>​        对于受弯构件，根据强度条件和刚度条件计算截面所需特性参数抗弯模量 <em>W</em> 和惯性矩 <em>I</em>，即</p><script type="math/tex; mode=display">W\ge\frac M{[\sigma]}</script><script type="math/tex; mode=display">I\ge\frac{Fl^3}{48E[Y_L]}</script><p>式中    [$<em>Y_L</em>$ ]——材料的许用挠度。</p><p>​        所选型号及其性能参数如下表所示，截面形状和尺寸如图 4.5 所示。</p><div class="table-container"><table><thead><tr><th>杆件</th><th>所需截面特性参数/cm$^n$</th><th>型号</th><th>截面系数/cm$^3$</th><th>惯性半径/cm</th></tr></thead><tbody><tr><td><em>BE</em>、<em>B</em>′<em>E</em>′</td><td><em>A</em> ≥ 3.6</td><td>HW150×150</td><td>216.0，75.1</td><td>6.39，3.77</td></tr><tr><td><em>CC</em>′</td><td><em>W</em> ≥ 32.0，<em>I</em> ≥ 2.0</td><td>F120 钢管</td><td>116.1</td><td>4.51</td></tr><tr><td><em>AC</em>、<em>A</em>′<em>C</em>′</td><td><em>A</em> ≥ 6.9</td><td>F120 钢管</td><td>116.1</td><td>4.51</td></tr><tr><td><em>CD</em>、<em>C</em>′<em>D</em>′</td><td><em>W</em> ≥ 43.1</td><td>F120 钢管</td><td>116.1</td><td>4.51</td></tr><tr><td><em>BC</em>、<em>B</em>′<em>C</em>′</td><td><em>A</em> ≥ 9.4</td><td>F80 钢管</td><td>27.8</td><td>3.07</td></tr><tr><td><em>CE</em>、<em>C</em>′<em>E</em>′</td><td><em>A</em> ≥ 0.1</td><td>F80 钢管</td><td>27.8</td><td>3.07</td></tr><tr><td><em>B</em>′<em>D</em>、<em>BD</em>′</td><td><em>A</em> ≥ 3.0</td><td>F80 钢管</td><td>27.8</td><td>3.07</td></tr><tr><td><em>EG</em>、<em>E</em>′<em>G</em></td><td><em>A</em> ≥ 3.3</td><td>F80 钢管</td><td>27.8</td><td>3.07</td></tr><tr><td><em>EE</em>′</td><td><em>W</em> ≥ 15.5</td><td>F80 钢管</td><td>27.8</td><td>3.07</td></tr></tbody></table></div><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220521153143756.png" alt="image-20220521153143756"></p><h3 id="支承装置的强度、刚度和稳定性验算"><a href="#支承装置的强度、刚度和稳定性验算" class="headerlink" title="支承装置的强度、刚度和稳定性验算"></a>支承装置的强度、刚度和稳定性验算</h3><p>​        （1）截面强度验算</p><p>​        系泊机械臂可能同时承受横向和纵向载荷，其支承装置承受双向弯矩作用，对于拉（压）弯构件其静强度条件按下式计算</p><script type="math/tex; mode=display">\sigma=\frac{N}{A_{j}}+\frac{M_{x}}{\gamma_{x} W_{j x}}+\frac{M_{y}}{\gamma_{y} W_{j y}} \leqslant[\sigma]</script><p>对于受弯构件，按下式计算</p><script type="math/tex; mode=display">\sigma=\frac{M_{x}}{\gamma_{x} W_{j x}}+\frac{M_{y}}{\gamma_{y} W_{j y}} \leqslant[\sigma]</script><script type="math/tex; mode=display">\tau=\frac{QS}{I\delta}\le[\tau]</script><p>式中    $A_j$——构件计算截面的净截面面积，取 $A_j$ = 0.85<em>A</em>；</p><p>​            $γ_x$、$γ_y$——截面塑性发展系数，HW150×150 截面取 $γ_x$ = 1.05、$γ_y$ = 1.2，其他截面取 $γ_x$ = 1.05、$γ_y$ = 1.05；</p><p>​            $W_{jx}$、$W_{jy}$——构件绕 <em>x</em>-<em>x</em> 轴和 <em>y</em>-<em>y</em> 轴的净截面抗弯模量，取 $W_{jx} = 0.85W_x$、$W+{jy} = 0.85W_y$；</p><p>​            <em>Q</em>——受弯构件的最大剪力；</p><p>​            <em>S</em>——受弯构件毛截面截面最大静矩；</p><p>​            <em>δ</em>——构件的腹板厚度；</p><p>​            [<em>τ</em>] ——许用切应力，取 [<em>τ</em>] = 175MPa。</p><p>​        计算结果如下表所示，各杆件强度均通过检验。</p><div class="table-container"><table><thead><tr><th>杆件</th><th>构件类型</th><th>正应力 <em>σ</em>/MPa</th><th>切应力 <em>τ</em>/MPa</th><th>应力比</th></tr></thead><tbody><tr><td><em>BE</em>、<em>B</em>′<em>E</em>′</td><td>拉（压）弯构件</td><td>268</td><td>-</td><td>0.88</td></tr><tr><td><em>CC</em>′</td><td>受弯构件</td><td>240</td><td>71</td><td>0.78，0.41</td></tr><tr><td><em>AC</em>、<em>A</em>′<em>C</em>′</td><td>拉（压）弯构件</td><td>216</td><td>-</td><td>0.71</td></tr><tr><td><em>CD</em>、<em>C</em>′<em>D</em>′</td><td>受弯构件</td><td>279</td><td>12</td><td>0.91，0.07</td></tr><tr><td><em>BC</em>、<em>B</em>′<em>C</em>′</td><td>拉（压）弯构件</td><td>133</td><td>-</td><td>0.44</td></tr><tr><td><em>CE</em>、<em>C</em>′<em>E</em>′</td><td>拉（压）弯构件</td><td>61</td><td>-</td><td>0.20</td></tr><tr><td><em>B</em>′<em>D</em>、<em>BD</em>′</td><td>拉（压）弯构件</td><td>171</td><td>-</td><td>0.56</td></tr><tr><td><em>EG</em>、<em>E</em>′<em>G</em></td><td>拉（压）弯构件</td><td>194</td><td>-</td><td>0.64</td></tr><tr><td><em>EE</em>′</td><td>受弯构件</td><td>99</td><td>7</td><td>0.32，0.04</td></tr></tbody></table></div><p>​        （2）静态刚性验算</p><p>​        对拉（压）弯构件，在工程中采用限制构件长细比的方法来保证其刚性，按照以下公式进行验算</p><script type="math/tex; mode=display">\lambda=\left(\frac{l_c}{r}\right)_\max\le[\lambda]</script><p>式中    <em>λ</em>——构件的最大长细比；</p><p>​            $l_c$——与最大长细比相对应的计算长度；</p><p>​            <em>r</em>——与最大长细比相对应的截面回转半径；</p><p>​            [<em>λ</em>] ——构件的许用长细比，主要构件取 [<em>λ</em>] = 190，次要构件取 [<em>λ</em>] = 250。</p><p>​        对于受弯构件，在前面截面选型的过程中已经作为控制条件，可不再考虑。</p><p>​        使用 SSDD 中国钢结构设计模块计算，对 HW150×150，其最大长细比为 45.7；对F120 钢管，其最大细长比为 29.0；对 F80 钢管，在 <em>EG</em> 和 <em>E</em>′<em>G</em> 杆为最大细长比 33.1。所选三种钢材均满足静态刚性要求。</p><p>​        （3）稳定性验算</p><p>​        稳定性分析是研究结构或构建的平衡状态是否稳定的问题，分为整体稳定性分析和局部稳定性分析。整体稳定性分析主要考虑机构在受到临界荷载时，结构失去原有平衡状态的过程。局部稳定性分析主要是对钢结构宽厚比和高厚比进行验算。</p><p>​        对于拉（压）弯构件，涉及到平面内稳定和平面外稳定。</p><p>​        平面内稳定，即</p><script type="math/tex; mode=display">\sigma=\frac{N}{\varphi_{x} A}+\frac{\beta_{\mathrm{m} x} M_{x}}{\gamma_{x} W_{x}\left(1-0.8 \frac{N}{N_{\mathrm{E} x}^{\prime}}\right)}+\frac{\eta \beta_{\mathrm{t} y} M_{y}}{\varphi_{\mathrm{b} y} W_{y}} \leqslant[\sigma]</script><p>​        平面外稳定，即</p><script type="math/tex; mode=display">\sigma=\frac{N}{\varphi_{y} A}+\eta \frac{\beta_{\mathrm{t} x} M_{x}}{\varphi_{\mathrm{b} x} W_{x}}+\frac{\beta_{\mathrm{m} y} M_{y}}{\gamma_{y} W_{y}\left(1-0.8 \frac{N}{N_{\mathrm{E} y}^{\prime}}\right)} \leqslant[\sigma]</script><p>​        对受弯构件，整体稳定性，即</p><script type="math/tex; mode=display">\sigma=\frac{M_{x}}{\varphi_{\mathrm{b} x} W_{x}}+\frac{M_{y}}{\gamma_{y} W_{y}} \leqslant[\sigma]</script><p>式中    $φ_x$、$φ_y$——对 <em>x-x</em> 轴和 <em>y-y</em> 轴的轴心受压构件稳定系数；</p><p>​            $φ_{\text{b}x}$、$φ_{\text{b}y}$——均匀弯曲的受弯构件整体稳定性系数；</p><p>​            $W_x$、$W_y$——对强轴和弱轴的毛截面模量；</p><p>​            $β_{\text{m}x}$、$β_{\text{m}y}$ ——平面内等效弯矩系数；</p><p>​            $β_{\text{t}x}$、$β_{\text{t}y}$——平面外等效弯矩系数；</p><p>​            $N^′_{\text{Ex}}$、$N^′_{\text{Ey}}$——参数，按照 $N^′_{\text{Ei}} = π^2EA/(1.1λ_i)$确定。</p><p>​        查询相关标准获取系数，使用 SSDD 中国钢结构设计软件模块计算，计算结果如下表所示，其中括号内为许用值。计算表明，该结构不会失稳。</p><div class="table-container"><table><thead><tr><th>杆件</th><th>平面内稳定/MPa</th><th>平面外稳定/MPa</th><th>宽厚比</th><th>高厚比</th></tr></thead><tbody><tr><td><em>BE</em>、<em>B</em>′<em>E</em>′</td><td>231（305）</td><td>201（305）</td><td>10（12）</td><td>24（37）</td></tr><tr><td><em>CC</em>′</td><td>207（305）</td><td>207（305）</td><td>13（31）</td><td>13（31）</td></tr><tr><td><em>AC</em>、<em>A</em>′<em>C</em>′</td><td>109（305）</td><td>115（305）</td><td>13（37）</td><td>13（37）</td></tr><tr><td><em>CD</em>、<em>C</em>′<em>D</em>′</td><td>243（305）</td><td>243（305）</td><td>13（35）</td><td>13（35）</td></tr><tr><td><em>BC</em>、<em>B</em>′<em>C</em>′</td><td>130（305）</td><td>132（305）</td><td>18（33）</td><td>18（33）</td></tr><tr><td><em>CE</em>、<em>C</em>′<em>E</em>′</td><td>21（305）</td><td>20（305）</td><td>18（33）</td><td>18（33）</td></tr><tr><td><em>B</em>′<em>D</em>、<em>BD</em>′</td><td>88.7（305）</td><td>78（305）</td><td>18（37）</td><td>18（37）</td></tr><tr><td><em>EG</em>、<em>E</em>′<em>G</em></td><td>175（305）</td><td>146（305）</td><td>18（33）</td><td>18（33）</td></tr><tr><td><em>EE</em>′</td><td>87（305）</td><td>87（305）</td><td>18（35）</td><td>18（35）</td></tr></tbody></table></div><h3 id="支承装置的连接计算"><a href="#支承装置的连接计算" class="headerlink" title="支承装置的连接计算"></a>支承装置的连接计算</h3><p>​        （1）支承装置与地面的螺纹连接</p><p>​        采用地脚螺栓连接，试选螺栓数 <em>z</em> = 8，螺栓组同时受到轴向力 $F_{PV}$、横向力 $F_{PH}$ 和翻转力矩 <em>M</em> 作用，如图 4.6 所示。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220521155625420.png" alt="image-20220521155625420"></p><p>​        在轴向力 $F_P$ 作用下，各螺栓受到工作拉力为 $F_1 = F_{PV}/z$ = 18kN。</p><p>​        在翻转力矩的作用下，远端螺栓受力大，其最大工作拉力为</p><script type="math/tex; mode=display">F_{2}=\frac{M L_{\max }}{L_{1}^{2}+L_{2}^{2}+\cdots L_{z}^{2}}=1627 \mathrm{~N}</script><p>式中    $L_\max$——受力最大螺栓到螺栓组对称轴线距离。</p><p>​        因此，远端螺栓受到总的最大拉力为 $F = F_1 + F_2$ = 19611N。</p><p>​        在横向力作用下，底板连接接合面可能产生滑移[19]。按照底板接合面不滑移的条件，并考虑轴向力对预紧力的影响，所需预紧力为</p><script type="math/tex; mode=display">F^{\prime}=\frac{1}{z}\left(\frac{K_{\mathrm{f}} F_{\mathrm{PH}}}{f}+\frac{C_{2}}{C_{1}+C_{2}} F_{\mathrm{PV}}\right)=17812 \mathrm{~N}</script><p>式中    $K_f$——考虑由摩擦力传递载荷时的可靠性系数，取 $K_f$ = 1.1；</p><p>​            <em>f</em> ——接合面的摩擦系数，取 <em>f</em> = 0.35；</p><p>​            <em>C</em>2/(<em>C</em>1+<em>C</em>2) ——被连接件的相对刚度，采用金属垫片，取 <em>C</em>2/(<em>C</em>1+<em>C</em>2) = 0.7。</p><p>​        螺栓所受总拉力为</p><script type="math/tex; mode=display">F_{0}=F^{\prime}+\frac{C_{1}}{C_{1}+C_{2}} F=23687 \mathrm{~N}</script><p>​        按螺栓危险截面拉伸强度条件，可以得到</p><script type="math/tex; mode=display">d_{1} \geqslant \sqrt{\frac{4 \times 1.3 F_{0}}{\pi[\sigma]}}=27.2 \mathrm{~mm}</script><p>式中    $d_1$——螺栓危险截面直径，即螺纹小径；</p><p>​            [<em>σ</em>] ——许用应力，选择螺栓材料为 Q345B 钢，设螺栓所需公称直径 <em>d</em> 在M16~M30 范围内，取 [<em>σ</em>] = $σ_s$/6.5。</p><p>​        根据 GB/T 1228-2006《钢结构用高强度大六角头螺栓》，选择 M30 螺栓。</p><p>​        考虑弹簧预紧力 <em>F</em>′ 的变化，连接接合面下端不压溃和连接接合面上端不出现间隙的条件为</p><script type="math/tex; mode=display">\begin{aligned}\sigma_{\mathrm{pmax}} & \approx \frac{1}{A}\left(z F^{\prime}-\frac{C_{2}}{C_{1}+C_{2}} F_{\mathrm{PV}}\right)+\frac{M}{W}=1.32 \mathrm{MPa}<\left[\sigma_{\mathrm{P}}\right]=0.8 \sigma_{\mathrm{S}} \\\sigma_{\mathrm{pmin}} & \approx \frac{1}{A}\left(z F^{\prime}-\frac{C_{2}}{C_{1}+C_{2}} F_{\mathrm{PV}}\right)-\frac{M}{W}=0.22 \mathrm{MPa}>0\end{aligned}</script><p>​        两者均满足条件。</p><p>​        （2）支承装置与摇板支座的螺栓连接</p><p>​        摇板通过摇板支座与支承装置连接，选择螺栓数 <em>z</em> = 6，螺栓组主要受到横向载荷 $F_R$ 的作用，如图 4.7 所示。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220521160659178.png" alt="image-20220521160659178"></p><p>​        以接合面不滑移作为计算准则，有</p><script type="math/tex; mode=display">F^′\ge\frac{K_fF_R}{fzm}</script><p>​        得到每个螺栓的预紧力 <em>F</em>′ = 13kN。</p><p>​        按螺栓危险截面拉伸强度条件，可以得到</p><script type="math/tex; mode=display">d_{1} \geqslant \sqrt{\frac{4 \times 1.3 F^{\prime}}{\pi[\sigma]}}=15.7 \mathrm{~mm}</script><p>​        选择 M16 螺栓。</p><p>​        （3）支承装置与横向液压缸铰接吊头底座的焊接</p><p>​        横向液压缸通过缸底铰接吊头与支承装置连接，铰接吊头底座通过焊接固定在杆 <em>CC</em>′ 上，该焊接属于在弯矩 <em>M</em> 作用下的角接焊缝，其受力如图 4.8 所示。</p><p> <img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220521161019290.png" alt="image-20220521161019290"></p><p>​        焊缝截面内的剪应力均匀分布，其强度按下式计算</p><script type="math/tex; mode=display">\tau_{\mathrm{M}}=\frac{M}{W_{\mathrm{f}}}=35 \mathrm{MPa} \leqslant\left[\tau_{\mathrm{h}}\right]=181 \mathrm{MPa}</script><p>式中    <em>M</em>——作用于接头的弯矩，<em>M</em> = $F_H$<em>h</em> = 3750N·m；</p><p>​            $W_f$——焊接计算截面的抗弯模量；</p><p>​            [$τ_h$]——焊缝许用应力，取 $[τ_h]=[\sigma]/\sqrt 2$ ，[<em>σ</em>] 为构件母材的基本许用应力。</p><p>​        横向液压缸与支承装置的焊接符合要求。</p><h2 id="传动装置的设计"><a href="#传动装置的设计" class="headerlink" title="传动装置的设计"></a>传动装置的设计</h2><p>​        系泊机械臂的传动装置实现真空吸盘横向、竖直方向和纵向的串联移动。传动装置由摇板、内门架、外门架、导槽、液压缸、链轮、链条等组成，如图 4.9 所示。横向液压缸通过两个平行的摇板和耳环与纵向内、外门架相连接。为了减小装置体积，内、外门架与导槽组成动滑轮组实现竖直方向行程的增加，纵向液压缸放置在导槽内部，与真空吸盘相连接。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517163240718.png" alt="image-20220517163240718"></p><h3 id="摇板设计"><a href="#摇板设计" class="headerlink" title="摇板设计"></a>摇板设计</h3><p>​        为使竖直方向传动模块始终保持竖直状态，设置了摇板，使其与支承装置和外门架组成平行四边形机构，保证外门架与支承装置钢柱保持平行。摇板的宽度尺寸由布置（即支承装置 H 型钢间距）决定，高度尺寸需要保证摇板处于极限位置时不发生干涉，同时要求横向液压缸在全部缩回时保持水平状态。摇板各位置状态图 4.10 所示。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517163317202.png" alt="image-20220517163317202"></p><p>​        摇板上下两端较厚，中间为销轴孔，摇板通过此孔安装在机械臂支承机构和外门架。为了减轻装置重量，参考同类设计产品，经过多次数据计算和优化，摇板高度优选为 825mm，设置其结构如图 4.11 所示。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517163346327.png" alt="image-20220517163346327"></p><h3 id="竖直传动模块设计"><a href="#竖直传动模块设计" class="headerlink" title="竖直传动模块设计"></a>竖直传动模块设计</h3><p>​        内门架、外门架、竖直方向液压缸和链轮、链条共同组成竖直传动模块，控制系泊机械臂末端真空吸盘竖直方向的位置。由于液压缸的缸筒长度与其最大工作行程有关，如果直接选用大行程液压杆会使结构占用空间过大，造成浪费，因此采用普通行程液压缸和增程结构配合的方案。竖直方向液压缸通过法兰连接固定在外门架上，活塞杆端通过耳环与内门架相连，控制内门架的位置。链条一端与导槽连接，另一端在绕过内门架上的链轮后，固定在外门架上，控制导槽的位置。竖直传动模块组成类似动滑轮的机构，实现液压缸行程的倍增。内、外门架构造如图 4.12 所示。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517163417386.png" alt="image-20220517163417386"></p><p>​        （1）立柱截面</p><p>​        内、外门架分别由左右两根型钢，通过横板焊接而成，形成门式框架。立柱是内门架和导槽作升降运动的导轨，也是主要承载部件。由于叉车工作装置与系泊机械臂竖直传动模块功能较为相似，为了使构件标准化、定型化，提高机械臂经济性，门架截面采用叉车门架立柱槽钢系列[20]。内、外门架截面组合采用 CL 并列式，如图 4.13 所示。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517163447939.png" alt="image-20220517163447939"></p><p>​        CL 并列式截面滚轮间距可变，门架的疲劳载荷小。外门架立柱顶端设有两导向滚轮，内门架立柱外伸翼缘在两滚轮之间运动，内门架底部设有一组导向滚轮，内外门架三组导向滚轮承受负载。为了减小构造尺寸并简化安装，采用标准复合滚轮，如图 4.14 所示。该复合滚轮将侧向滚轮安装在横向滚轮的中心处，从而使得滚轮组的纵向和横向滚轮的间距重合，可以同时对侧向和横向进行支承引导。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517163516864.png" alt="image-20220517163516864"></p><p>​        （2）门架高度的确定</p><p>​        对于二级门架，设内门架伸出时，内、外门架的最小重叠高度为 420mm，与导槽滚轮最大间距相同，内外门架的理论高度为</p><script type="math/tex; mode=display">H_{\text {外 }}=H_{\text {内 }}+\delta=\frac{H_{\max }}{2}+\max \left\{A_{g}+d, C\right\}+t=1080 \mathrm{~mm}</script><p>式中    $H_外$——外门架高度；</p><p>​            $H_内$——内门架高度；</p><p>​            <em>δ</em>——外门架底板厚度；</p><p>​            $H_\max$ ——液压缸工作行程；</p><p>​            $A_g$——导槽滚轮组中心距；</p><p>​            <em>d</em>——导槽滚轮组直径；</p><p>​            <em>C</em>——液压缸的导向、缸盖、缸底等固定尺寸；</p><p>​            <em>t</em>——门架上端和下端必要的结构高度。</p><p>​        在满足理论高度的情况下，还需要为其留出足够的安全距离，项目设计外门架高度为 1104mm，内门架高度为 1092mm。</p><p>​        （3）门架的验算</p><p>​        当竖直方向液压缸到达伸展极限位置时，内、外门架受力最大。在正常工作中，内、外门架主要受到横向负载拉力 $F_1$ 和 $F_2$ 作用。同时，内、外门架需要克服导槽、纵向液压缸和真空吸盘的重力 $G_C$ 及机械臂到达极限位置时步进移动产生的竖直方向负载 $F_Y$。滚轮由于偏心负载产生的力矩较小，可以忽略不计。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517163906933.png" alt="image-20220517163906933"></p><p>​        内门架受力分析如图 4.15 所示。由于竖直方向液压缸的推力和该方向的负载在内门架顶端平衡，因此内门架可以视为仅受到弯矩和剪力，门架上下滚轮压力 $F_3$ 和 $F_4$ 通过力的平衡条件计算</p><script type="math/tex; mode=display">\left\{\begin{array}{l}\sum M=0 \Rightarrow F_{3}=165 \mathrm{kN} \\\sum \vec{F}=0 \Rightarrow F_{4}=65 \mathrm{kN}\end{array}\right.</script><p>​        由图 4.15 可知，内门架在门架上滚轮处受到最大弯矩 $M_{内\max} = F_3l_1$ = 68.8kN·m和最大剪力 $Q_{内\max} = F_1 + F_2$ = 100kN，该截面为危险截面。使用 SolidWorks 软件测量得，该截面面积 $A_内$ = 7256mm$^2$，形心惯性矩 $I_内$ = 35325264mm$^4$，$y_内$ = 80mm。根据材料力学，内门架最大弯曲应力 $σ_内$ 和内门架最大剪切应力 $τ_内$ 计算公式为</p><script type="math/tex; mode=display">\sigma_{\text {内}}=\frac{M_{\max } y}{I_{z}} \leqslant[\sigma]</script><script type="math/tex; mode=display">\tau_{\text {内}}=\frac{Q_{\max }}{A} \leqslant[\tau]</script><p>式中    [<em>σ</em>]——许用应力，取安全系数 <em>n</em> = 1.5，对 Q345B，[<em>σ</em>] = 230MPa；</p><p>​            [<em>τ</em>]——许用切应力，[<em>τ</em>] = (0.5-0.7)[<em>σ</em>]，取 [<em>τ</em>] = 140MPa。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220521161748975.png" alt="image-20220521161748975"></p><p>​        外门架受力分析如图 4.16 所示。与内门架不同，外门架还受到轴力作用。外门架有两个危险截面，分别是门架上滚轮处和与横向液压缸连接处。门架上滚轮处截面外门架受到最大弯矩 $M_{外\max} = F_3^′l_1 + F_{5y}e_3 – (F_{5x} + F_{X液压缸})(l_1 - l_4)$ = 30kN·m、剪力 $Q_外$ = $F_3^′$ - $F_{X液压缸}$ – $F_{5x}$ = 42.5kN 和最大轴力 $N_外$ = $F_{5y}$ = 103kN；与横向液压缸连接处受到弯矩 $M_外$ = $F_3^′l_4$ + $F_{5y}e_3$ = 24.4kN·m、最大剪力 $Q_{外\max}$ = $F_3^′$ = 156kN 和最大轴力 $N_外$ = $F_{5y}$ = 103kN。使用 SolidWorks 软件测量得，外门架截面面积 $A_外$ = 6571mm$^2$，形心惯性矩 $I_外$ = 33944789mm$^4$，$y_外$ = 75mm。根据材料力学，外门架正应力 <em>σ</em> 外有</p><script type="math/tex; mode=display">\sigma=\sigma_{M}+\sigma_{N}=\frac{M y}{I_{z}}+\frac{N}{A} \leqslant[\sigma]</script><p>​        外门架切应力 $τ_外$ 可按式 $(42)$ 计算。内门架与外门架两种危险截面计算结果汇总如下表所示，内、外门架强度均符合要求。</p><div class="table-container"><table><thead><tr><th>截面</th><th>正应力 <em>σ</em>/MPa</th><th>切应力 <em>τ</em>/MPa</th></tr></thead><tbody><tr><td>内门架危险截面</td><td>156</td><td>14</td></tr><tr><td>外门架上滚轮处</td><td>82</td><td>16</td></tr><tr><td>外门架与横向液压缸连接处</td><td>70</td><td>24</td></tr></tbody></table></div><p>​        滚轮在与立柱翼缘板接触传力时，在接触处会产生局部挤压应力，需要进行考虑。因产生接触应力的位置不在在冀缘材料表层，而在其下一定深度处，且其破坏作用不同于其他应力分量，故只需单独对它进行校核。计算公式为</p><script type="math/tex; mode=display">\sigma_{j}=0.418 \sqrt{\frac{P E}{b r}}=905 \mathrm{MPa} \leqslant\left[\sigma_{j}\right]</script><p>式中    <em>P</em>——滚轮压力；</p><p>​            <em>E</em>——弹性模量；</p><p>​            <em>b</em>——滚轮宽度；</p><p>​            <em>r</em>——滚轮半径；</p><p>​            [<em>σj</em>]——与滚轮材质和导轨表面硬度有关的许用接触应力，取材料布氏硬度的 5 倍，即 [<em>σj</em>] = 1000MPa。</p><p>​        （4）链条的选取</p><p>​        常用的链条有套筒滚子链和片式链两种。套筒滚子链结构简单，成本较低，常应用于小吨位的叉车上。片式链链数较多，承载能力和抗冲击能力更强，工作更加可靠。由于系泊机械臂在即将达到极限位置时将以步进的方式移动，在此期间可能会产生较大的拉力，因此选承载能力较强的片式链，其结构如图 4.17 所示。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220521162935725.png" alt="image-20220521162935725"></p><p>本装置采用两根链条，设系泊机械臂导槽、纵向液压缸和真空吸盘的重力<em>G</em>C = 5kN，则每根链条的断裂载荷为[21]</p><script type="math/tex; mode=display">F_{jx}=\frac{F_Y+G_C}{2}N_L=60\text{kN}</script><p>式中    $F_{jx}$——链条的极限载荷；</p><p>​            $F_Y$——竖直方向最大负载，$F_Y$ = 25kN；</p><p>​            $N_L$——安全系数，取 $N_L$ = 4。</p><p>​        根据拉伸载荷选择链条型号为 LH1044，采用 4×4 的链板组合。</p><h3 id="纵向传动模块设计"><a href="#纵向传动模块设计" class="headerlink" title="纵向传动模块设计"></a>纵向传动模块设计</h3><p>​        导槽和纵向液压缸组成纵向传动模块，一起控制机械臂末端真空吸盘的纵向位置。滚轮架上连接复合滚轮组，复合滚轮组与内门架相接触，实现竖直方向的引导。竖直方向传动模块的链条通过链条连接座与导槽相连，带动纵向传动模块进行升降。导槽与纵向液压缸通过液压缸支座连接，导槽上下两侧还设有纵向导轨，为真空吸盘连接部分提供支承和导向，如图 4.18 所示。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220521163129493.png" alt="image-20220521163129493"></p><p>​        （1）整体强度验算</p><p>​        导槽主要受到真空吸盘横向拉力 $F_X$ 和纵向液压缸承受负载 $F_Z$，即主要受到弯矩和轴力的作用，受力分析如图 4.19 所示。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220521163409433.png" alt="image-20220521163409433"></p><p>​        由式 $(40)$ 可计算出未知力 $F_7$ = 100kN，$F_8$ = 60.81kN 和 $F_9$ = 139.18kN。</p><p>​        由弯矩图可知，在两滚轮组处，导槽承受最大弯矩 $M_\max = F_X(l_6-l_5)/2$ = 42 kN·m和轴力 <em>N</em> = $F_{Z液压缸}$ = 50kN。</p><p>​        使用 SolidWorks 软件测量得，外门架截面面积 $A_外$ = 11446mm$^2$，形心惯性矩 $I_外$ = 55110186mm$^4$，$y_外$ = 100mm。根据材料力学，槽钢应力计算公式为</p><script type="math/tex; mode=display">\sigma=\frac{N}{A}+\frac{M y}{I_{z}}=81 \mathrm{MPa} \leqslant[\sigma]</script><p>​        整体强度符合要求。</p><p>​        （2）滚轮架强度验算</p><p>​        滚轮架主要将纵向液压缸承受的负载通过滚轮组传递到内门架，滚轮的摩擦力和滚轮架自重可以忽略不计，该结构可以看作悬臂梁。</p><p>​        滚轮架在小加强筋末端应力最大，即距离滚轮中心 96mm 处应力最大，为危险截面。使用 SolidWorks 软件测量得，该截面形心惯性矩 $I_外$ = 1780543mm$^4$，$y_外$ = 32.6mm。</p><p>​        由式 $(41)$ 计算得，在连接座根部 <em>σ</em> = 88MPa，符合强度要求。</p><p>​        （3）链条连接座强度验算</p><p>​        链条连接座主要承受来自竖直方向链条的拉力，以带动导槽移动，该结构可以简化为悬臂梁，如图 4.20 所示。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220521164438091.png" alt="image-20220521164438091"></p><p>​        连接座根部所受弯矩最大，为危险截面。使用 SolidWorks 软件测量得，该截面形心惯性矩 $I_外$ = 300240mm$^4$，$y_外$ = 25mm。</p><p>​        连接座加强筋末端材料抗弯模量最小，为危险截面，使用 SolidWorks 软件测量得，该截面心惯性矩 $I_外$ = 2026906mm$^4$，$y_外$ = 65mm。</p><p>​        由式 $(41)$ 计算得，在连接座根部 <em>σ</em> = 98.6MPa，在连接座加强筋末端 <em>σ</em> = 122.8MPa，均符合强度要求。</p><p>​        （4）液压缸螺栓连接计算</p><p>​        纵向液压缸与导槽采用螺栓连接，选择螺栓数 <em>z</em> = 4，螺栓组主要受到横向负载 $F_H$ 和纵向负载 $F_Z$ 的作用，如图 4.21 所示。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220521164630460.png" alt="image-20220521164630460"></p><p>​        在翻转力矩作用下，远端螺栓受力大，由式 $(31)$ ，其最大工作压力 <em>F</em> = 5500N。</p><p>​        在横向力作用下，接合面可能产生滑移。按照底板接合面不滑移的条件，由式 $(36)$ 所需预紧力为 <em>F</em>′ = 4321N。</p><p>​        由式 $(33)$ ，螺栓受到总拉力 $F_0$ = 5971N。</p><p>​        由式 $(34)$，计算得到螺栓危险截面直径 $d_1$≥11mm，选择 M16 螺栓。</p><h2 id="真空吸盘的设计"><a href="#真空吸盘的设计" class="headerlink" title="真空吸盘的设计"></a>真空吸盘的设计</h2><p>​        本设计采用真空吸盘实现对船舶的系泊。真空吸盘与船体接触，边缘由橡胶密封，通过接管与真空泵等设备相连接。真空泵抽空吸盘内的空气，使吸盘内产生负压，将物体吸住。</p><p>​        真空吸盘具有很多优点。真空吸盘只要不泄露任何气体，即可吸附大部分物体，适用范围十分广泛，目前应用已经十分成熟。同时，由于真空吸盘不产生光、热和电磁，对环境不会产生污染，十分环保，也不会对船舶上的电磁设备造成干扰。另外，真空吸盘大多采用橡胶材质，不会对船舶表面造成损坏，是非常理想的系泊装置。</p><p>​        系泊需要同时克服使吸盘与船舶分离的横向拉力和使吸盘与船体相对滑动的纵向力。</p><p>​        为了使真空吸盘具有一定的吸力，吸盘面积 <em>S</em> 应满足[22]</p><script type="math/tex; mode=display">S \geqslant \frac{F_{X} t}{p}=1.97 \mathrm{~m}^{2}\\S \geqslant \frac{F_{Z} t}{\mu p}=1.28 \mathrm{~m}^{2}</script><p>式中    <em>t</em>——安全系数；</p><p>​            <em>p</em>——标准大气压；</p><p>​            <em>μ</em>——真空吸盘与船舶表面摩擦系数，取橡胶与钢铁之间的摩擦系数 <em>μ</em> = 0.65。</p><p>​        每个系泊机械臂设置两个真空吸盘，每个真空吸盘长取 1250mm，宽取 800mm，其布置如图 4.22 所示。为保护真空吸盘安全，在其上平均分布 12 个安全触点。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517162806024.png" alt="image-20220517162806024"></p><h2 id="本章小结-2"><a href="#本章小结-2" class="headerlink" title="本章小结"></a>本章小结</h2><p>​        本章详细介绍了系泊机械臂驱动装置、支承装置、传动装置和真空吸盘的功能、安装布置方式和设计，对其中多个零部件进行了设计计算或选型计算。系泊机械臂三个方向均使用液压缸驱动，其中横向设置两个液压缸，其余方向设置一个液压缸。支承装置采用钢结构框架式钢结构，使用三维钢结构分析和设计软件 STAAD.Pro 进行设计计算和校核。传动机构包括摇板、内门架、外门架和导槽，传动机构与驱动装置共同组成一条串联的运动链，其中内、外门架组成形成增程机构，实现竖直方向行程的增加，减小装置体积。真空吸盘采用矩形扁平真空吸盘，与真空泵连接使用。</p><h1 id="第-5-章-结构分析及优化"><a href="#第-5-章-结构分析及优化" class="headerlink" title="第 5 章 结构分析及优化"></a>第 5 章 结构分析及优化</h1><p>​        结构设计完成后，为了判断设计和布局的合理性，本章将对系泊机械臂关键机构或零部件进行有限元分析，并根据分析结果优化结构，从而使得系泊机械臂的设计更加可靠。由于支承结构在结构设计中已经进行了钢结构验算，因此无需再进行有限元分析。有限元分析完成以后，本章将对系泊机械臂与现有港口的系泊方式进行比较，评估其经济性。</p><p>​        本章采用 ANSYS 软件对机械臂关键机构或零部件进行静力学分析，其分析流程如图 5.1 所示。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517160623743.png" alt="image-20220517160623743"></p><p>​        选择静力学分析模块，将第 4 章结构设计建立的 SolidWorks 三维模型进行简化，定义各部分材料属性，得到 CAE 模型。设置 CAE 模型的载荷、约束及接触，对模型划分网格，完成前处理操作。之后对模型进行求解，得到机构或零部件的变形、应力和应变状态。最后检验结果是否准确，通过后处理找出应力较大处，判断是否失效并优化系泊机械臂的结构。</p><h2 id="摇板有限元分析"><a href="#摇板有限元分析" class="headerlink" title="摇板有限元分析"></a>摇板有限元分析</h2><p>​        摇板采用 Q345B 材料制造，输入密度、弹性模量、泊松比等材料属性至软件。取其中一个摇板及其连接板为研究对象，在 SolidWorks 中去除不必要的结构，导入 ANSYS 中。设置摇板和销轴之间为无摩擦接触，其他为固定接触，并对其划分网格。设置轴承座底板为固定约束，限制摇板与竖直方向连接部分横向的位移，并在该处设置轴向载荷 120kN、横向载荷 50kN 和弯矩 10kN·m，添加重力，如图 5.2 所示。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517160729494.png" alt="image-20220517160729494"></p><p>​        求解得到摇板的等效应力和变形如图 5.3 所示。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517160759828.png" alt="image-20220517160759828"></p><p>​        摇板最大等效应力位于摇板与竖直方向传动模块连接处，其值为 207MPa，最大应力小于材料屈服极限，满足强度要求。摇板最大位移也位于摇板与竖直方向传动模块连接处，其值为 0.7mm，变形较小，可以忽略不计，满足刚度要求。</p><h2 id="竖直传动模块有限元分析"><a href="#竖直传动模块有限元分析" class="headerlink" title="竖直传动模块有限元分析"></a>竖直传动模块有限元分析</h2><p>​        去除链条、链轮等不必要零部件，同时在 SolidWorks 中去除起吊耳环孔等不必要结构，导入 ANSYS 中。固定外门架两横梁，设置内、外门架之间的接触为无摩擦接触，内门架与液压缸耳环座之间的接触为固定接触，对其划分网格。设置内门架槽钢内部受到横向力 200kN 和纵向力 100kN，液压缸耳环座和外门架底部受到液压缸推力 25kN，链轮座处受到 25kN 的拉力，添加重力，如图 5.4 所示。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517160854229.png" alt="image-20220517160854229"></p><p>​        求解得到竖直传动模块等效应力图如图 5.5 所示。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517160916836.png" alt="image-20220517160916836"></p><p>​        分析结果表明，内门架满足强度要求。外门架在与液压缸连接处具有较大的应力；同时，外门架底板和 C 型钢连接处有较大的应力集中，最大应力超过材料的强度极限，需要对外门架的结构进行改进。</p><p>​        针对外门架与液压缸连接处较大的应力，增加底板厚度，使用圆角过渡；针对外门架底板与 C 型钢连接处较大的应力集中，在此处设置加强筋，并用圆角过渡，改进结构如图 5.6 所示。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517161039553.png" alt="image-20220517161039553"></p><p>​        再次添加接触、约束和载荷，对竖直方向传动模块进行网格划分并求解，外门架等效应力图和竖直传动模块总变形图如图 5.7 所示。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517161106022.png" alt="image-20220517161106022"></p><p>​        分析结果表明，增加外门架底板厚度之后，应力会大幅减小；增设加强筋后，应力集中现象有所改善。改进后的外门架最大应力小于材料的强度极限，满足强度要求；整个竖直传动模块最大变形为 7mm，可以忽略不计，符合刚度要求。</p><h2 id="纵向传动模块有限元分析"><a href="#纵向传动模块有限元分析" class="headerlink" title="纵向传动模块有限元分析"></a>纵向传动模块有限元分析</h2><p>​        去除螺栓等零部件，在 SolidWorks 中填充螺栓孔等不必要结构，导入 ANSYS。限制导槽滚轮组的横向和纵向位移，链条连接梁竖直方向的位移，设置导槽和真空吸盘连接板导轨部分为不分离接触，对其划分网格。设置真空吸盘连接座受到横向力 200kN，纵向力 100kN，添加重力，如图 5.8 所示。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517161156747.png" alt="image-20220517161156747"></p><p>​        求解得到竖直传动模块等效应力图如图 5.9 所示。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517161329137.png" alt="image-20220517161329137"></p><p>​        分析结果表明，真空吸盘连接板耳环根部收到很大的应力，需要进行改进。增加真空吸盘连接板的厚度，降低伸出的角度，如图 5.10 所示。改进后，连接板应力大幅减小，但是液压缸连接座出现应力集中，且有较大的纵向变形。在液压缸连接座设置加强筋后，纵向传动模块强度和刚度最终合格，如图 5.11 所示。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517161357001.png" alt="image-20220517161357001"></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20220517161413598.png" alt="image-20220517161413598"></p><h2 id="经济性分析"><a href="#经济性分析" class="headerlink" title="经济性分析"></a>经济性分析</h2><p>​        从成本上来看，首先本设计大量使用标准件。支承装置采用标准型钢焊接而成，内外门架使用叉车用型钢与底板、横梁焊接而成，导槽与真空吸盘连接板之间的导轨也采用叉车叉架的设计标准。标准件在生产中容易获得，很大降低了生产制造的成本，同时也降低了设备维修更换的成本。其次，本设计采用轻量化设计，竖直传动模块利用增程机构减少了因大行程液压缸安装尺寸较大而造成的浪费，减少了制造上的材料使用，降低了整机的重量，在减少物料成本外也降低了运输成本。最后，本文采用 STAAD.Pro、SolidWorks、ANSYS 等 CAD 和 CAE 软件，能够判断方案是否合理，大大减少了方案改进和实验验证的成本。</p><p>​        从效益上来看，这种系泊机械臂可以大幅降低船舶的系泊时间。由于系泊操作在港口十分频繁[23]，单次系泊时间的降低能够大幅提高港口的运行效率，使港口系泊更多的船只，得到更多收益。同时由于系泊机械臂能够控制船舶在横向和纵向的位移，相比现有系泊方式，船舶的运动量会减少很多，在起重机装卸货物时将不会受到影响，提高了港口装卸运输的效率。同时，机械臂大幅降低的系泊工作人员的工作量，系泊操作可以由更少的工人完成，降低了港口运营的人工成本。系泊机械臂也提高了港口的空间利用率，即不使用缆绳系缆，理论上泊位长度可以与船舶长度相等，这样可以释放一部分空间。</p><p>​        综上所述，该系泊机械臂具有良好的经济性。</p><h2 id="本章小结-3"><a href="#本章小结-3" class="headerlink" title="本章小结"></a>本章小结</h2><p>​        本章使用 ANSYS 软件对系泊机械臂的结构进行了有限元分析。通过分析发现，系泊机械臂的摇板、内门架和导槽强度和刚度符合结构要求，外门架底板和真空吸盘连接板需要进行改进。对改进后的结构经过二次分析，结果表明达到设计要求，结构设计合理。最后，本文对整个方案的生产和效益方面的经济性进行了分析，本方案具有良好的经济性。</p><h1 id="第-6-章-结论"><a href="#第-6-章-结论" class="headerlink" title="第 6 章 结论"></a>第 6 章 结论</h1><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​        本文以自动系泊系统为研究对象，分析其工作原理和工作环境，在满足结构强度、刚度的基础上，设计出一种直角坐标式船舶辅助机械臂，并对该机械臂进行分析、建模与仿真。设计主要完成了以下几部分的工作：</p><p>​        （1）对自动系泊系统的功能和工况进行分析，提出可行的解决方案。本文阐述自动系泊系统的工作原理，明确系泊机械臂的功能。并通过对系泊机械臂工作环境的分析，确定机械臂的关键参数。随后，设计出一种可行的构型方案。</p><p>​        （2）对机械臂的运动学、动力学进行建模与分析。根据得到的构想方案，采用改进 D-H 法对机械臂建立运动学模型，对逆运动学求解，并通过 python 对其进行仿真验证。然后通过牛顿—欧拉法建立了机械臂的动力学模型，求解得到关节驱动力。</p><p>​        （3）对机械臂的驱动、支承、传动装置和真空吸盘进行设计。根据关节所需驱动力等条件完成系泊机械臂液压缸的选型计算。使用 STAAD.Pro 软件对机械臂的支承装置完成受力分析、截面选择以及结构检验，支承装置采用型钢焊接组成。参考叉车门架，设计机械臂的竖直传动模块，使用两个平行的摇板连接支承装置与竖直传动模块，使用内含双杆液压缸的导槽连接真空吸盘模块。随后对真空吸盘进行设计计算。</p><p>​        （4）对机械臂进行有限元分析和经济性分析，验证其可靠性和经济性。运用 ANSYS 软件分析了摇板、竖直传动模块和纵向传动模块的强度和刚度，针对危险结构进行了改进，最终使得结构设计合理可靠。同时，对机械臂经济性进行分析，其经济效益良好。</p><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>​        本文完成了系泊机械臂的结构设计，对自动系泊系统来说还需要进一步的研究，具体表现在以下方面：</p><p>​        （1）本文对系泊机械臂的控制系统只进行了功能上的描述，为了系泊机械臂能够正常的工作，需要进行进一步的完善。完成基础功能的基础上，还可以建立大数据平台，分析系泊数据，控制液压缸驱动大小，使系泊机械臂更加节能。</p><p>​        （2）由于国内疫情等条件限制，无法进行试验，对机械臂进行进一步验证，以确保设计的可靠性。</p><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>​        2020 年的元旦，一个武汉市卫健委的情况通报在班级群里开始传播，开启了这并不平凡的一年，随后疫情来袭，病毒肆虐，全民抗疫，复工复产。突如其来的新冠病毒，彻底打乱了我们的生活，给毕业设计也增添了不少挑战。本次毕业设计能够完成，离不开那些支持我的老师、同学、亲友等等。</p><p>​        首先要特别感谢我毕业设计的指导老师袁兵副教授。袁兵老师是我本科期间工程流体力学和单片机原理及接口的任课老师，对我在力学和控制方面的学习提供了极大的帮助。在毕业设计阶段，袁兵老师提供了大量实用的设计参考资料，及时督促我们设计进度，保证了毕业设计的顺利进行，在此向袁兵老师表示感谢。</p><p>​        同时感谢武汉理工大学物流学院的全体教师。武汉理工大学给了我一个能够自由学习的平台，物流学院的老师让我在大学四年内具有机械产品设计的能力，对机械行业有了一个全面的认识，毕业设计的完成离不开老师们的教导。值此三校合并 20 周年之际，向学校表示由衷的祝贺。</p><p>​        同时感谢 ICADCS 第二课堂实验室的创办者陈定方教授、指导老师陶孟仑副教授以及队友罗来臻、周易岗、王浩、高涵、梁霄、夏泽天和任正敏等人。陶孟仑老师十分关心实验室成员的学习，分享行业相关前沿报告，让我对机械行业有了更加深刻的认识。实验室队友们在毕业设计期间给予了我很多支持和帮助，他们的讨论也给了我很多的启发，让我收获颇丰，与他们共战“挑战杯”的时光让我终生难忘。另外，感谢第二课堂杨梓桐学长等师兄师姐师弟师妹的关怀。</p><p>​        同时感谢机设 1606 班的全体同学和室友。在毕业设计阶段，与刘明昕、刘裕燊、亓鹏、张钧华、江雄、吴世安、温明洋等人的讨论给予了我很多帮助和灵感，万典给予了我液压方面的资料，没有他们毕业设计将变的十分麻烦。</p><p>​        此外，感谢 Grant Sanderson，他的系列视频和动画库 manim 让我对数学和编程有了一个全新的认识。感谢 manim-kindergarten 的成员，让我很快掌握这个动画库，并参与两次团队视频的制作，最终将其应用于毕业设计中。</p><p>​        最后，感谢我的父母、爷爷奶奶等人，他们在毕业设计期间时刻关心着我的生活，为我提供了一个十分舒适的设计环境，没有他们的支持，毕业设计将很难完成，他们的付出成就了我的现在，祝愿他们身体健康，万事如意。</p><p>​        Things Change，Summer Comes。拖着行李箱，走过林荫路，穿过熟悉的大门口，身后是那回忆中的四年，我亲爱的理工，不说再见。</p>]]></content>
    
    
    <categories>
      
      <category>机械相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 笔记</title>
    <link href="/2021/08/26/HUST/CPPConcurrency/"/>
    <url>/2021/08/26/HUST/CPPConcurrency/</url>
    
    <content type="html"><![CDATA[<p>《Effective C++》第三版的笔记</p><span id="more"></span><h1 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h1><h2 id="尽量以const-enum-inline-替换-define"><a href="#尽量以const-enum-inline-替换-define" class="headerlink" title="尽量以const, enum, inline 替换 #define"></a>尽量以<code>const, enum, inline</code> 替换 <code>#define</code></h2><p><code>#define</code> 是预处理命令，预处理器只会对文本进行简单的替换，不会进行类型检查等等操作。同时，预处理命令定义的变量并不会在编译阶段出现，因此当这个预处理命令出问题时，很难进行排查和定位。</p><p><code>const</code> 用来替换常量，<code>inline</code> 用来替换 <code>#define</code> 而<code>enum</code> 则是为了补充 <code>const</code> 的一个使用场景。</p><p>当在类内定义一个静态的常量时，这个常量必须要在类外才能初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test</span> &#123;</span><br>    <span class="hljs-comment">// static const int length = 0;</span><br>    <span class="hljs-comment">// static constexpr int length = 1;</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> length = <span class="hljs-number">1</span> &#125;;<br>    std::array&lt;<span class="hljs-keyword">int</span>, length&gt; people;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="尽可能使用const"><a href="#尽可能使用const" class="headerlink" title="尽可能使用const"></a>尽可能使用<code>const</code></h2><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>注意，两个函数参数的 <code>const</code> 不同，这两个函数不能被重载，也就是说</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123; cout &lt;&lt; val &lt;&lt; endl; &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> val)</span> </span>&#123; cout &lt;&lt; val &lt;&lt; endl; &#125;<br></code></pre></td></tr></table></figure><p>这两个函数在编译器眼中是一样的</p><p>而<code>const</code>成员函数则可以重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test::print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123; cout &lt;&lt; val &lt;&lt; endl; &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test::print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> <span class="hljs-keyword">const</span> </span>&#123; cout &lt;&lt; val &lt;&lt; endl; &#125;<br></code></pre></td></tr></table></figure><h3 id="bitwise-constness-和-logical-constness"><a href="#bitwise-constness-和-logical-constness" class="headerlink" title="bitwise constness 和 logical constness"></a>bitwise constness 和 logical constness</h3><p>对<code>const</code>来说，有两种</p><ul><li>bitwise constness：对于这个常量，它的二进制不改变</li><li>logical constness：对于这个常量，它的外在表现不会改变</li></ul><p>编译器执行的是 bitwise constness，而写程序时就需要保证是 logical constness。</p><p>当类里面出现了指针，就会出现两种 const 不同的情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test</span> &#123;</span> <span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;; &#125;<br></code></pre></td></tr></table></figure><h3 id="const-和non-const避免重复"><a href="#const-和non-const避免重复" class="headerlink" title="const 和non-const避免重复"></a><code>const</code> 和<code>non-const</code>避免重复</h3><p>当<code>const</code>成员函数和<code>non-const</code>成员函数有相同的行为时，可以让<code>non-const</code>调用<code>const</code>版本实现代码的复用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-keyword">int</span> val) : <span class="hljs-built_in">m_val</span>(val) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> &amp;<span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">int</span> &amp;&gt;(<br>            <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">const</span> Test *&gt;(<span class="hljs-keyword">this</span>)-&gt;<span class="hljs-built_in">print</span>()<br>        );<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;<span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; cout &lt;&lt; m_val &lt;&lt; endl; <span class="hljs-keyword">return</span> m_val; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> m_val;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="确定对象被使用前已经初始化"><a href="#确定对象被使用前已经初始化" class="headerlink" title="确定对象被使用前已经初始化"></a>确定对象被使用前已经初始化</h2><p>尽量使用列表初始化，这样效率更高</p><p>为了免除编译时多个文件初始化顺序的问题，尽量使用 <code>local static</code> 对象代替 <code>non-local static</code> 对象</p><h1 id="构造、析构赋值"><a href="#构造、析构赋值" class="headerlink" title="构造、析构赋值"></a>构造、析构赋值</h1><h2 id="编译器默默编写的函数"><a href="#编译器默默编写的函数" class="headerlink" title="编译器默默编写的函数"></a>编译器默默编写的函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//class Empty &#123;&#125;;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Empty</span> &#123;</span><br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">Empty</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">Empty</span>() &#123;&#125;<br>    <span class="hljs-built_in">Empty</span>(<span class="hljs-keyword">const</span> Empty &amp;other) &#123;&#125;<br>    Empty &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Empty &amp;other) &#123;&#125;<br>    <span class="hljs-built_in">Empty</span>(<span class="hljs-keyword">const</span> Empty &amp;&amp;other) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意：这些函数一开始都没有，只有需要用到的时候才会被构造出来</p><h2 id="不使用自动生成的函数，就应该拒绝"><a href="#不使用自动生成的函数，就应该拒绝" class="headerlink" title="不使用自动生成的函数，就应该拒绝"></a>不使用自动生成的函数，就应该拒绝</h2><p>比如说单例模式，如果不删掉或者自由化拷贝构造函数，编译器就会自动生成，然后就会违反单例模式。</p><h2 id="将基类析构函数声明为虚函数"><a href="#将基类析构函数声明为虚函数" class="headerlink" title="将基类析构函数声明为虚函数"></a>将基类析构函数声明为虚函数</h2><p>老面试题了，核心问题是当父类指针指向基类的对象时，会发生内存泄露</p><h2 id="不要在构造函数和析构函数中调用虚函数"><a href="#不要在构造函数和析构函数中调用虚函数" class="headerlink" title="不要在构造函数和析构函数中调用虚函数"></a>不要在构造函数和析构函数中调用虚函数</h2><p>因为子类的在构造自身前需要调用基类的构造函数，此时基类中构造函数调用的虚函数是基类版本的虚函数，会很难排查。</p><p>一种可能的方式是，这样会发生混乱</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">class <span class="hljs-title">Base</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">Base</span>() &#123; <span class="hljs-built_in">init</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Create Base&quot;</span> &lt;&lt; endl; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="operator-返回一个reference-to-this"><a href="#operator-返回一个reference-to-this" class="headerlink" title="operator= 返回一个reference to *this"></a><code>operator=</code> 返回一个reference to *this</h2><p>这样就可以做到连续赋值了 <code>test3 = test2 = test1</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-built_in">Test</span>(<span class="hljs-keyword">int</span> t_val) : <span class="hljs-built_in">val</span>(t_val) &#123;&#125;<br>    Test &amp;<span class="hljs-keyword">operator</span>= (<span class="hljs-keyword">const</span> Test &amp;others) &#123;<br>        val = others.val;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> val;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="在operator-中处理自我赋值"><a href="#在operator-中处理自我赋值" class="headerlink" title="在operator=中处理自我赋值"></a>在<code>operator=</code>中处理自我赋值</h2><p>对用户来说，很可能发生自己给自己赋值的情况，当进行删除操作的时候，需要额外的注意，可以采用</p><ul><li><p>比较源和目标的地址</p></li><li><p>调整语句顺序（让删除操作在构造新对象之后进行）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Test &amp;<span class="hljs-keyword">operator</span>= (<span class="hljs-keyword">const</span> Test &amp;others) &#123;<br>    Data *temp = other.data;<br>    data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Data</span>(temp);<br>    <span class="hljs-keyword">delete</span> temp;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>copy-and-swap（较好的方法）</p></li></ul><h2 id="复制时不要忘记每一个成员"><a href="#复制时不要忘记每一个成员" class="headerlink" title="复制时不要忘记每一个成员"></a>复制时不要忘记每一个成员</h2><p>当在派生类写复制构造函数或赋值运算符重载函数的时候，经常会忘记构造基类的对象，应该在派生类的函数中调用基类对应的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">D</span>(<span class="hljs-keyword">const</span> D &amp;other) : <span class="hljs-built_in">B</span>(D) &#123;&#125;<br>    D &amp;<span class="hljs-keyword">operator</span>= (<span class="hljs-keyword">const</span> D &amp;other) &#123; B::<span class="hljs-keyword">operator</span>=(D); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><p>资源用了要还回去，但是还回去并不简单，很容易出现资源的泄露。</p><h2 id="以对象管理资源"><a href="#以对象管理资源" class="headerlink" title="以对象管理资源"></a>以对象管理资源</h2><p>以对象管理资源有两个关键的思路</p><ul><li>资源获取后立即放入管理对象中</li><li>管理对象利用析构函数确保资源的释放</li></ul><p>为了防止资源泄露，尽量使用RAII对象</p><h2 id="在资源管理类中小心对象拷贝"><a href="#在资源管理类中小心对象拷贝" class="headerlink" title="在资源管理类中小心对象拷贝"></a>在资源管理类中小心对象拷贝</h2><p>资源很多时候是互斥的，当对一个RAII对象进行拷贝时，他们的行为会有不同，主要包括</p><ul><li>禁止拷贝（<code>unique_ptr</code>）</li><li>允许拷贝，通过引用计数，确保安全释放（<code>shared_ptr</code>）</li><li>复制底部资源</li><li>转移底部资源的拥有权</li></ul><h2 id="在资源管理类中提供对原始资源的访问"><a href="#在资源管理类中提供对原始资源的访问" class="headerlink" title="在资源管理类中提供对原始资源的访问"></a>在资源管理类中提供对原始资源的访问</h2><p>RAII对象很好，但是有些API只允许传入原始的对象，如指针，因此需要提供一个访问原始资源的接口。可以通过函数显示的调用，也可提供隐式类型转换</p><h2 id="使用new和delete要使用相同的形式"><a href="#使用new和delete要使用相同的形式" class="headerlink" title="使用new和delete要使用相同的形式"></a>使用<code>new</code>和<code>delete</code>要使用相同的形式</h2><p><code>delete</code> 用 <code>new []</code> 构造的对象会造成资源的泄露</p><p><code>delete[]</code> 用 <code>new</code> 构造的对象会造成未定义的行为</p><h2 id="通过new构造的智能指针需要设置为独立的语句"><a href="#通过new构造的智能指针需要设置为独立的语句" class="headerlink" title="通过new构造的智能指针需要设置为独立的语句"></a>通过<code>new</code>构造的智能指针需要设置为独立的语句</h2><p>对于下面的语句</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getNumber</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setNumber</span><span class="hljs-params">(std::shared_ptr&lt;Person&gt;, <span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-built_in">setNumber</span>(std::shared_ptr&lt;Person&gt;(<span class="hljs-keyword">new</span> Persion), <span class="hljs-built_in">getNumber</span>());<br></code></pre></td></tr></table></figure><p>编译器的执行顺序为下图，但是 <code>new Person</code> 和 <code>getNumber</code> 的执行顺序无法确认。</p><pre><code class=" mermaid">graph LR执行newPerson --&gt; 调用shared_ptr构造函数 --&gt; 执行setNumber调用getNumber --&gt; 执行setNumber</code></pre><p>当 <code>new Person</code> 执行后再执行 <code>getNumber()</code> 此时一旦 <code>getNumber()</code> 中出现异常，<code>new</code> 出的对象将会造成内存泄露</p><h1 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h1><h2 id="让接口容易正确使用"><a href="#让接口容易正确使用" class="headerlink" title="让接口容易正确使用"></a>让接口容易正确使用</h2><ul><li>构造新类型避免接口被误用</li><li>对输入进行限制</li><li>让自定义类型的行为与内置类型的行为一致</li><li>消除用户管理资源的责任</li></ul><h2 id="用传常量引用代替传值"><a href="#用传常量引用代替传值" class="headerlink" title="用传常量引用代替传值"></a>用传常量引用代替传值</h2><ul><li>对于自定义对象，使用传常量引用代替传值</li><li>对于内置类型和STL迭代器和函数对象，使用传值的方式就更加高效一些</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2021/08/22/HUST/DesignPattern/"/>
    <url>/2021/08/22/HUST/DesignPattern/</url>
    
    <content type="html"><![CDATA[<p>设计模式和软件工程作用是差不多的，都是为了更高效的软件开发</p><span id="more"></span><p>设计模式是软件开发中一个些典型问题的解决方法。设计模式主要关心当产品的 <strong>业务需求</strong> 发生变更时，要怎么做，让软件开发更加<strong>安全高效</strong></p><p>软件的开发需要依据一些设计原则，违反了这些设计原则后，开发就会因为业务需求的变化而变的十分困难。这时候，就需要用到设计模式了</p><p>设计模式有三大类</p><div class="table-container"><table><thead><tr><th style="text-align:center">类别</th><th style="text-align:center">特点</th></tr></thead><tbody><tr><td style="text-align:center">创造型</td><td style="text-align:center">关注类的创建，提供创造类的对象的机制</td></tr><tr><td style="text-align:center">行为型</td><td style="text-align:center">关注类的通讯和职责委派</td></tr><tr><td style="text-align:center">结构型</td><td style="text-align:center">介绍如何将对象和类组装成较大的结构</td></tr></tbody></table></div><h1 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h1><pre><code class=" mermaid">classDiagramDelivered --|&gt; Base : 继承Realization ..|&gt; Interface : 实现Penguin --&gt; Climate : 关联LiHua --o Chinese : 聚合Wing --* Bird : 组合Animal ..&gt; Water : 依赖</code></pre><ul><li>关联：一个类需要知道另外一个类的一些消息</li><li>聚合：一种弱的拥有关系，体现的是A对象可以包含B对象，但是B对象不是A对象的一部分</li><li>组合：一种强的拥有关系，体现部分和整体的关系，部分和整体的声明周期是相同的</li></ul><h1 id="设计原则-Design-Principles"><a href="#设计原则-Design-Principles" class="headerlink" title="设计原则 | Design Principles"></a>设计原则 | Design Principles</h1><ul><li><p>依赖倒置原则</p><ul><li>高层模块不应该依赖于底层模块，两者都应该依赖与抽象</li><li>抽象不应该依赖于细节。细节应该依赖抽象</li></ul><blockquote><p>针对接口（抽象）编程，不要针对实现（细节）编程</p></blockquote></li><li><p>单一职责原则</p><ul><li>一个类只应该有一个影响它变化的因素</li></ul><blockquote><p>类的职责过多的话，当每一处的需求发生变化的话就会牵一发而动全身，把指着分开则可以实现代码的高效复用</p></blockquote></li><li><p>开放封闭原则</p><ul><li>类应该是可拓展的，但是不可修改的</li></ul><blockquote><p>可拓展是为了应对变化，不可修改是为了防止错误</p></blockquote></li><li><p>里氏替换原则</p><ul><li>子类应该可以替换父类（IS-A）</li></ul></li><li><p>接口隔离原则</p><ul><li>接口应该小而完整</li></ul></li><li><p>优先使用对象组合，而不是类继承</p><ul><li>类的继承是白箱复用，对象组合是黑箱组合</li><li>类继承破坏了封装性，子类父类耦合性高</li><li>而对象组合则只要求被组合的对象具有良好定义的接口</li></ul></li><li><p>封装变化点</p><ul><li>应该将变化的部分和稳定的部分分开，设计者可以在分界的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合</li></ul></li><li><p>针对接口编程，而不是针对实现编程</p><ul><li>不将变量类型声明为某个特定的具体类，而是声明为某个接口</li><li>客户程序无需获知对象的具体类型，只需要知道对象所具有的接口</li><li>减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案</li></ul></li></ul><h1 id="创造型模式-Creational-Patterns"><a href="#创造型模式-Creational-Patterns" class="headerlink" title="创造型模式 | Creational Patterns"></a>创造型模式 | Creational Patterns</h1><p>提供创建对象的机制， 增加已有代码的灵活性和可复用性</p><p>主要的措施是绕开 <code>new</code> 然后避免紧耦合（编译时依赖）</p><h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><h3 id="针对的问题"><a href="#针对的问题" class="headerlink" title="针对的问题"></a>针对的问题</h3><p>针对由于需求的需要，创建的对象经常改变的情况。</p><blockquote><p>例如在界面中之前使用 <code>Lable</code> 显示进度，现在要改为进度条。如果 <code>Lable</code> 在原先的代码中</p></blockquote><h3 id="实现的方法"><a href="#实现的方法" class="headerlink" title="实现的方法"></a>实现的方法</h3><pre><code class=" mermaid">classDiagramProduct &lt;.. ClientCreator &lt;.. ClientProductA &lt;.. Creatorclass Product &#123;&lt;&lt;Interface&gt;&gt;+doStuff()*&#125;class Creator&#123;+creatorProduct(flag)&#125;Product &lt;|.. ProductA</code></pre><ul><li><code>Creator::creatorProduct(flag)</code> 中对传入的<code>flag</code>进行判断，通过条件分支创建不同的对象</li><li><code>Client</code>通过<code>Product *pd = Creator::creatorProduct(flag)</code> 创建对象</li></ul><h3 id="带来的好处"><a href="#带来的好处" class="headerlink" title="带来的好处"></a>带来的好处</h3><p>简单工厂的出现能够让代码更加方便的管理。当使用 <code>new</code> 创建对象的时候就形成了稳定的模块依赖于变化的模块了，违反了依赖倒置原则。</p><p>如果不采用简单工厂方法，为了适应对象经常改变的这种情况，就需要在代码中不断的出现<code>if-else</code>这种条件语句，用来更改对应的对象，如果现在新添加一种类型的对象，就需要在每个条件语句进行更改，同时，所有更改的文件都需要重新编译，效率低下</p><p>如果采用简答工厂方法，添加新类型的时候就只需要在对应的工厂类中的<code>Creator::creatorProduct(flag)</code>进行更改</p><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>简单工厂每次修改都需要更改<code>Creator::creatorProduct(flag)</code>，违反了开放封闭原则。当这些产品种类变的很多的时候，工厂的条件判断就会变的十分庞杂。同时很多人进行协作时，会对这个工厂进行频繁的修改，管理起来就会比较麻烦。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.csdn.net/qq_22238021/article/details/79832092">https://blog.csdn.net/qq_22238021/article/details/79832092</a></p><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><h3 id="针对的问题-1"><a href="#针对的问题-1" class="headerlink" title="针对的问题"></a>针对的问题</h3><p>解决和简单工厂一样的问题，但是针对简单工厂违反开放封闭原则的问题，将条件分支转化为了类接口的实现</p><blockquote><p>工厂方法 = 简单工厂 + 策略模式</p></blockquote><h3 id="实现的方法-1"><a href="#实现的方法-1" class="headerlink" title="实现的方法"></a>实现的方法</h3><p>解决方法是为每个产品定义一个工厂，工厂负责创造产品的实例。所有的产品都继承自一个抽象产品类，所有的工厂都继承自一个抽象工厂类。使用的时候通过不同的工厂获得不同的产品</p><pre><code class=" mermaid">classDiagramCreator &lt;.. ClientProduct &lt;.. Clientclass Creator&#123;&lt;&lt;Interface&gt;&gt;+creatProduct()*&#125;class Product&#123;&lt;&lt;Interface&gt;&gt;+doStuff()*&#125;class CreatorA&#123;+createProduct()&#125;class CreatorB&#123;+createProduct()&#125;Creator &lt;|.. CreatorACreator &lt;|.. CreatorBProduct &lt;|.. ProductAProduct &lt;|.. ProductBProductA &lt;.. CreatorAProductB &lt;.. CreatorB</code></pre><ul><li><code>createProduct()</code> 返回具体 <code>Createor</code> 对应的 <code>Product</code> 对象（<code>CreatorA::createProduct() &#123; return new ProductA; &#125;</code>）。</li><li>构造 <code>Product</code> 对象时，通过调用 <code>product *p = creator-&gt;creatProduct()</code> 实现对象的创建，当业务需求时更改创建的对象时，只需更改 <code>creator</code> 指向的对象即可</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><strong>优点：</strong> 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</p><p><strong>缺点：</strong>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p>主要是针对一系列相互依赖的对象的创建工作</p><p>具体的解决方法时提供一个接口，让这个接口负责创建一系列相互依赖的对象</p><pre><code class=" mermaid">classDiagramAbstractCreator &lt;.. ClientAbstractProductA &lt;.. ClientAbstractProductB &lt;.. Clientclass AbstractCreator &#123;&lt;&lt;Interface&gt;&gt;+createProductA()*+createProductB()*&#125;class AbstractProductA &#123;&lt;&lt;Interface&gt;&gt;&#125;class AbstractProductB &#123;&lt;&lt;Interface&gt;&gt;&#125;class Creator1 &#123;+createProductA()+createProductB()&#125;class Creator2 &#123;+createProductA()+createProductB()&#125;AbstractCreator &lt;|.. Creator1AbstractCreator &lt;|.. Creator2AbstractProductA &lt;|.. ProductA1AbstractProductA &lt;|.. ProductA2AbstractProductB &lt;|.. ProductB1AbstractProductB &lt;|.. ProductB2ProductA1 &lt;.. Creator1ProductB1 &lt;.. Creator1ProductA2 &lt;.. Creator2ProductB2 &lt;.. Creator2</code></pre><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p><strong>优点：</strong>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p><p><strong>缺点：</strong>产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p><h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><p>解决只生成一个实例的问题</p><pre><code class=" mermaid">classDiagramclass Singleton&#123;-Singleton()+getInstance()$&#125;</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">Singleton</span>() &#123;&#125;<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-keyword">const</span> Singleton &amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Singleton &amp;) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-built_in">Singleton</span>(Singleton &amp;&amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton &amp;<span class="hljs-keyword">operator</span>=(Singleton&amp;&amp;) = <span class="hljs-keyword">delete</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> Singleton &amp;<span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">static</span> Singleton s;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="行为模式-Behavioral-Patterns"><a href="#行为模式-Behavioral-Patterns" class="headerlink" title="行为模式 | Behavioral Patterns"></a>行为模式 | Behavioral Patterns</h1><p>负责对象间的高效沟通和职责委派</p><h2 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h2><p>实现订阅-通知这种关系，一个对象的状态发生改变，就立即通知其他的对象，是一种一对多或者多对多的通知关系</p><pre><code class=" mermaid">classDiagramPublisher &lt;.. ClientSubscriber &lt;.. Clientclass Publisher &#123;&lt;&lt;Interface&gt;&gt;+attach(Subscriber)*+detach(Subscriber)*-notify()*&#125;class ConcretePublisher &#123;+getDate()-attach(Subscriber)-detach(Subscriber)-notify()-mainProgess()&#125;class Subscriber &#123;&lt;&lt;Interface&gt;&gt;update()*&#125;class ConcreteSubscriber &#123;update()&#125;Publisher &lt;|.. ConcretePublisherSubscriber &lt;|.. ConcreteSubscriberPublisher &lt;.. SubscriberConcretePublisher &lt;.. ConcreteSubscriber</code></pre><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><h3 id="针对问题"><a href="#针对问题" class="headerlink" title="针对问题"></a>针对问题</h3><p>某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担</p><p>虽然可以将算法类抽象成一个对象，然后使用简单工厂创建。但是遇到算法更改十分频繁的时候，工厂类会同时部署起来也十分的麻烦，因此不是最好的解决方法。</p><h3 id="实现的方法-2"><a href="#实现的方法-2" class="headerlink" title="实现的方法"></a>实现的方法</h3><p>定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程 序(稳定)而变化（扩展，子类化）</p><pre><code class=" mermaid">classDiagramContext &lt;.. ClientStrategyA &lt;.. ClientStrategyB &lt;.. ClientStrategyC &lt;.. ClientStrategy --o Contextclass Strategy &#123;&lt;&lt;Interface&gt;&gt;+Algorithm()*&#125;class StrategyA &#123;+Algorithm()&#125;class StrategyB &#123;+Algorithm()&#125;class StrategyC &#123;+Algorithm()&#125;class Context &#123;+Context(Strategy)+contextInterface()&#125;Strategy &lt;|.. StrategyAStrategy &lt;|.. StrategyBStrategy &lt;|.. StrategyC</code></pre><ul><li><code>Context::contextInterface() &#123; strategy-&gt;Algorithm(); &#125;</code> 这个函数执行算法</li><li>使用算法时，调用<code>Context(new StrategyA())</code>创建上下文后调用<code>Context::Contextinterface()</code>即可</li></ul><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p><strong>优点：</strong> 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。</p><p><strong>缺点：</strong> 1、策略类会增多。 2、所有策略类都需要对外暴露。</p><p>Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需 要Strategy模式。</p><h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><h3 id="针对的问题-2"><a href="#针对的问题-2" class="headerlink" title="针对的问题"></a>针对的问题</h3><p>对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因 （比如框架与应用之间的关系）而无法和任务的整体结构同时实现</p><h3 id="实现的方法-3"><a href="#实现的方法-3" class="headerlink" title="实现的方法"></a>实现的方法</h3><p>定义一个操作中的算法的骨架 (稳定)，而将一些步骤延迟 (变化)到子类中。Template Method使得子类可以不改变 (复用)一个算法的结构即可重定义(override 重写)该算法的 某些特定步骤。</p><pre><code class=" mermaid">classDiagramclass AbstractClass &#123;+templateMethod()-step1()*-step2()*-step3()*&#125;class Class1 &#123;-step1()&#125;class Class2 &#123;-step2()-step3()&#125;AbstractClass &lt;|.. Class1AbstractClass &lt;|.. Class2</code></pre><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><p><strong>优点：</strong> 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。</p><p><strong>缺点：</strong>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</p><h1 id="结构型模式-Structural-Patterns"><a href="#结构型模式-Structural-Patterns" class="headerlink" title="结构型模式 | Structural Patterns"></a>结构型模式 | Structural Patterns</h1><p>介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效</p><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><h3 id="针对的问题-3"><a href="#针对的问题-3" class="headerlink" title="针对的问题"></a>针对的问题</h3><p>在通过类的继承实现拓展的时候，有时候一些组合会使得拓展出来的子类数量急剧的膨胀</p><p>例如咖啡类。如果要在咖啡上添加牛奶、巧克力和糖，就会产生8个子类</p><p>装饰模式能够实现类的动态拓展，避免子类数量的膨胀</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><pre><code class=" mermaid">classDiagramConcreteComponent &lt;.. ClientDecoratorComponentA &lt;.. ClientDecoratorComponentB &lt;.. Clientclass Component&#123;&lt;&lt;Interface&gt;&gt;+operation()*&#125;Component &lt;|.. ConcreteComponentclass ConcreteComponent&#123;+operation()&#125;Component &lt;|-- Decoratorclass Decorator&#123;&lt;&lt;Interface&gt;&gt;+Decorator(Component)+operation()&#125;class DecoratorComponentA&#123;+Decorator(Component)+operation()-addItem()&#125;class DecoratorComponentB&#123;+Decorator(Component)+operation()-addString&#125;Decorator &lt;|.. DecoratorComponentADecorator &lt;|.. DecoratorComponentB</code></pre><ul><li><p>装饰类<code>DecoratorComponentA/B</code>的<code>operation()</code>中包括传入的<code>component</code>的<code>opration()</code>和自己添加的操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DecoratorComponentA::operation</span><span class="hljs-params">()</span> </span>&#123;<br>    component.<span class="hljs-built_in">operation</span>();<span class="hljs-comment">// component是这个类构造函数中传入的对象</span><br>    ...<span class="hljs-comment">// DecoratorComponentA自己的操作</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>Client</code>使用时，进行如下操作即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doStuff</span><span class="hljs-params">()</span> </span>&#123;<br>    Component *cc = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteComponent</span>();<br>    DecorationComponentA *dca = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DecorationComponentA</span>(cc);<br>    DecorationComponentB *dcb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DecorationComponentB</span>(dca);<br>    dcb-&gt;<span class="hljs-built_in">operation</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h3><p><strong>优点：</strong>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p><p><strong>缺点：</strong>多层装饰比较复杂。</p><h1 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://refactoringguru.cn/design-patterns/">https://refactoringguru.cn/design-patterns/</a></li><li>程杰.《大话数据结构》</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法</title>
    <link href="/2021/08/18/HUST/Introduction2Algorithms/"/>
    <url>/2021/08/18/HUST/Introduction2Algorithms/</url>
    
    <content type="html"><![CDATA[<p>数据结构更新至绪论，算法更新至堆排序。</p><p>作为计算机基础4大件，数据结构与算法是讲如何让计算机算的对，<strong>算的快</strong>，能让我们高效的使用计算机。</p><span id="more"></span><p class="note note-primary">正在进行</p><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><ul><li>程序 = 算法 + 数据结构</li><li>一个好算法<ul><li>正确</li><li>高效</li><li>鲁棒（能辨别不良数据，并且进行优化，不非正常退出）</li><li>可读</li></ul></li></ul><h2 id="评价算法"><a href="#评价算法" class="headerlink" title="评价算法"></a>评价算法</h2><h3 id="方法-amp-环境"><a href="#方法-amp-环境" class="headerlink" title="方法&amp;环境"></a>方法&amp;环境</h3><ul><li><p>实验（最直接，但是不可行，因为不太方便在同一尺度下比较）</p></li><li><p>图灵机模型</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200911165310.png" alt=""></p><ul><li>组成：无限长纸带、有限字母表、有限状态信息、读写头</li><li>转换函数：Transition Function = (图灵机当前状态, 当前字符; 修改后的字符, 下一步前进方向, 图灵机改变后的状态)</li></ul></li><li><p>RAM模型</p><ul><li>无限储存空间</li><li>计算时间∝计算次数</li></ul></li></ul><h3 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h3><p>计算规模小的问题很快就会解决，因此只用考虑足够大的问题。</p><p>只考虑算法运算时间随时间的增长率（采用渐进分析）</p><ul><li>大O记号（上界,    悲观估计）</li><li><p>其他记号：Θ（同增长率），Ω（上界）</p></li><li><p>常见的时间复杂度</p><ul><li>常数复杂度$O(1)$</li><li>对数复杂度$O(\lg n)$</li><li>多项式复杂度$O(n^c)$（线性复杂度）</li><li>指数复杂度$O(2^n)$</li></ul></li><li><p>一些常见求时间复杂度的公式</p><ul><li>$\sum\limits_{i=1}^ni^d=O(n^{d+1})$</li><li>几何级数与其自身同阶$\sum\limits_{i=0}^na^n=O(a^n)$</li><li>$\sum\limits_{i=1}^ni^{-1}=O(\lg n)$</li><li>$\sum\limits_{i=1}^n\lg i=O(n\lg n)$</li></ul></li></ul><blockquote><p>例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j+=j)&#123;<br>        ...<br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有$\sum\limits_{i=1}^n\lg i=O(n\lg n)$的时间复杂度</p></blockquote><h3 id="快速估计：封底估算"><a href="#快速估计：封底估算" class="headerlink" title="快速估计：封底估算"></a>快速估计：封底估算</h3><p>抓住主要问题进行估计</p><h2 id="迭代与递归"><a href="#迭代与递归" class="headerlink" title="迭代与递归"></a>迭代与递归</h2><ul><li><p>空间复杂度：除输入外所需附加的空间</p></li><li><p>减而治之：逐步的减小问题的规模</p></li><li><p>分而治之：划分成两个规模相当的子问题</p></li><li><p>递归分析方法</p><ul><li><p>递归跟踪：直观、形象，仅适用于简答的递归模式</p><blockquote><p>把递归的函数一条条列出来，分析其中的逻辑</p></blockquote></li><li><p>递推分析：间接、抽象，适用于复杂的情况</p><blockquote><p>把递归式子写成数学归纳法的样子，然后解微分方程</p></blockquote></li></ul></li></ul><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>递归用到函数调用，效率会比较低，动态规划就是将递归变成迭代的</p><h1 id="数据结构-Data-Structure"><a href="#数据结构-Data-Structure" class="headerlink" title="数据结构 | Data Structure"></a>数据结构 | Data Structure</h1><p>主要介绍实现方式，重点是STL的实现方式</p><h2 id="向量-Vector"><a href="#向量-Vector" class="headerlink" title="向量 | Vector"></a>向量 | Vector</h2><p>向量就是数组的拓展，让它配合向量ADT接口。向量是一种<strong>线性结构</strong>，其物理位置与逻辑位置完全相同，可以执行<strong>高效的静态操作</strong>，如实现$O(1)$的<strong>寻秩访问</strong>。</p><p><code>std::vector</code> 的底层实现为线性连续数组。 <code>std::vector</code> 的核心问题是扩容。最开始 <code>std::vector</code> 的容量为 0 ，插入一个元素后容量为 1，随后每次乘二（<code>size = 16, capacity = 16</code>）</p><pre><code class=" mermaid">graph LRVector--&gt;属性--&gt;_size属性--&gt;_capacity属性--&gt;_elemVector--&gt;操作--&gt;构造类操作构造类操作--&gt;构造函数/析构函数构造类操作--&gt;复制构造函数构造类操作--&gt;动态空间管理--&gt;expand--&gt;加倍策略expand--&gt;分摊时间复杂度构造类操作--&gt;insert/remove动态空间管理--&gt;shrink操作--&gt;查找类操作--&gt;寻秩访问查找类操作--&gt;无序--&gt;find无序--&gt;deduplicate查找类操作--&gt;有序--&gt;search有序--&gt;uniquify操作--&gt;排序类操作search--&gt;二分查找search--&gt;Fibonacci查找search--&gt;插值查找</code></pre><h2 id="列表-List"><a href="#列表-List" class="headerlink" title="列表 | List"></a>列表 | List</h2><p>列表是另外一种线性的数据结构，与向量不同的是，它物理位置与逻辑位置不完全相同，可以执行高效的<strong>动态操作</strong>，寻秩访问速度较慢，主要进行的是<strong>寻位访问</strong>。</p><p><code>std::list</code> 为双向列表，<code>forward_list</code> 为单向列表</p><p>列表是基于结点的数据结构，其结点至少包含前驱指针、后继指针和数据三个数据。</p><pre><code class=" mermaid">graph LRnode--&gt;A(属性)--&gt;pred/succA--&gt;datanode--&gt;B(操作)--&gt;insertAfter/insertBeforeList--&gt;C(属性)--&gt;_sizeC--&gt;header/trailerList--&gt;D(操作)--&gt;寻秩访问/寻位访问D--&gt;构造/析构/基于复制的构造D--&gt;insert/remove/deduplicate/traverseD--&gt;uniquify/searchD--&gt;排序--&gt;选择排序排序--&gt;插入排序</code></pre><h2 id="双端队列-Deque"><a href="#双端队列-Deque" class="headerlink" title="双端队列 | Deque"></a>双端队列 | Deque</h2><p><code>std::vector</code> 只能实现高效的从尾部插入数据，而双端队列则可从首尾插入数据</p><p><code>std::deque</code> 的实现是动态的由多段连续空间组合而成。<code>std::deque</code> 的主体是一个指针数组，数组中的每一个节点都指向对应的一块连续的内存空间，这个里面存放的就是数据了。<code>std::deque</code> 有一个<code>map_size</code> 用来记录指针数组有多少个指针，有<code>start, end</code> 两个迭代器记录起始位置和数据结束的位置。</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.2/202102/1565877658970.png" alt="img"></p><blockquote><p>中控器就算对应的指针数组，缓冲区就算指针数组中指向的连续的内存区域</p></blockquote><p><code>std::deque</code> 的迭代器有4个对象</p><ul><li><code>cur</code> ：用于指向迭代器所指元素。</li><li><code>first</code> &amp; <code>last</code> ：指向当前缓冲区的头与尾。</li><li><code>node</code> ：指向中控器中指向本缓冲区的指针。</li></ul><p>由于 <code>std::deque</code> 本身结构比较复杂，它的迭代器也不是普通的指针，因此能使用<code>std::vector</code>就尽量使用<code>std::vector</code></p><h2 id="栈和队列-Stack-amp-Queue"><a href="#栈和队列-Stack-amp-Queue" class="headerlink" title="栈和队列 | Stack &amp; Queue"></a>栈和队列 | Stack &amp; Queue</h2><p>栈和队列就是向量和列表的特例，其中栈讲究先入后出，队列讲究先入先出。</p><pre><code class=" mermaid">graph LRStack--&gt;属性--&gt;sizeStack--&gt;操作--&gt;push操作--&gt;pop/topStack--&gt;应用--&gt;逆序输出应用--&gt;延迟缓冲应用--&gt;递归嵌套--&gt;括号识别递归嵌套--&gt;栈混洗应用--&gt;栈式计算--&gt;RPN栈式计算--&gt;中缀表达式</code></pre><pre><code class=" mermaid">graph LRQueue--&gt;enqueue/rearQueue--&gt;dequeue/front</code></pre><p><code>std::stack, std::queue</code> 是由其他容器构造出的，因此叫做容器构造器。默认情况下 <code>std::stack, std::queue</code> 利用 <code>std::deque</code> 实现,</p><h1 id="算法-Algorithm"><a href="#算法-Algorithm" class="headerlink" title="算法 | Algorithm"></a>算法 | Algorithm</h1><h2 id="排序-Sorting"><a href="#排序-Sorting" class="headerlink" title="排序| Sorting"></a>排序| Sorting</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>思路：遍历数组，将数组的前一个元素和后一个元素进行比较，让大的数放在后面。一次遍历完成之后，最大的数就在最后了。然后在对当前数组的 <code>[0,size-1)</code> 部分进行冒泡排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(vector&lt;T&gt; &amp;data)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> size = data.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (data[j] &gt;= data[j + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-built_in">swap</span>(data[j], data[j + <span class="hljs-number">1</span>]);<br>               flag = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag) &#123; <span class="hljs-keyword">return</span> ; &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>思路：遍历数组，选择其中最小的那个与数组第一个数交换，然后对数组的 <code>[1:size)</code> 部分进行排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(vector&lt;T&gt; &amp;data)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> size = data.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>        <span class="hljs-keyword">int</span> minIndex = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; size; ++j) &#123;<br>            <span class="hljs-keyword">if</span>(data[j] &lt; data[minIndex]) &#123; minIndex = j; &#125;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(data[i], data[minIndex]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>思路：1个元素开始，每次增加一个元素，让这个元素前的数组<code>[0:i]</code> 变成有序的。具体的实现就第 <code>i</code> 个元素向前移动，移动到它前面的数都不大于它</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(vector&lt;T&gt; &amp;data)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> size = data.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; size; ++i) &#123;<br>        <span class="hljs-keyword">int</span> currNum = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> currIndex = i;<br>        <span class="hljs-keyword">while</span>(currIndex &gt; <span class="hljs-number">0</span> &amp;&amp; data[currIndex] &lt; data[currIndex - <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">if</span>(data[currIndex] &lt; data[currIndex - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-built_in">swap</span>(data[currIndex], data[currIndex - <span class="hljs-number">1</span>]);<br>            &#125;<br>            --currIndex;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>插入排序对有序的数组效率比较高，希尔排序是利用这一点对插入排序进行优化</p><p>思路：将数组按间隔进行分组，在每一组内进行插入排序，提高数组的有序程度，然后逐渐减少分组的间隔，直到间隔为1，排序完成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(vector&lt;T&gt; &amp;data)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> size = data.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> gap = size &gt;&gt; <span class="hljs-number">1</span>; gap &gt; <span class="hljs-number">0</span>; gap &gt;&gt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; gap; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; size; j += gap) &#123;<br>                <span class="hljs-comment">// 下面是插入排序的部分</span><br>                <span class="hljs-keyword">int</span> currIndex = j;<br>                <span class="hljs-keyword">while</span>(currIndex &gt; gap &amp;&amp; data[currIndex] &lt; data[currIndex - gap]) &#123;<br>                    <span class="hljs-keyword">if</span>(data[currIndex] &lt; data[currIndex - gap]) &#123;<br>                        <span class="hljs-built_in">swap</span>(data[currIndex], data[currIndex - gap]);<br>                    &#125;<br>                currIndex -= gap;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>思路：快速排序需要设定一个轴，然后把数组中小于轴的元素移到轴左边，大于轴的元素移动到轴的右边，然后轴左右两边的数组就成了一个子问题，递归的解决就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;T&gt; &amp;data, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(right &lt;= left) &#123; <span class="hljs-keyword">return</span>; &#125;<br>    T key = data[left];<br>    <span class="hljs-keyword">int</span> i = left, j = right;<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; key &lt;= data[j]) &#123; --j; &#125;<br>        <span class="hljs-built_in">swap</span>(data[i], data[j]);<br>        <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; data[i] &lt;= key) &#123; ++i; &#125;<br>        <span class="hljs-built_in">swap</span>(data[i], data[j]);<br>    &#125;<br>    <span class="hljs-built_in">quickSort</span>(data, left, i - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">quickSort</span>(data, i + <span class="hljs-number">1</span>, right);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>思路，把数组分为两个部分，然后递归的解决，得到两个已经排好序的数组，然后依次取两个子数组中最小的那个</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;T&gt; &amp;data, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(left + <span class="hljs-number">1</span> &gt;= right) &#123; <span class="hljs-keyword">return</span>; &#125;<br>    <span class="hljs-keyword">int</span> mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>, size = right - left, l = left, r = mid;<br>    <span class="hljs-built_in">mergeSort</span>(data, left, mid);<br>    <span class="hljs-built_in">mergeSort</span>(data, mid, right);<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(size)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size;) &#123;<br>        <span class="hljs-keyword">if</span>((r &gt;= right) || (l &lt; mid &amp;&amp; data[l] &lt; data[r])) &#123; temp[i++] = data[l++]; &#125;<br>        <span class="hljs-keyword">if</span>((l &gt;= mid) || (r &lt; right &amp;&amp; data[l] &gt;= data[r]))&#123; temp[i++] = data[r++]; &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123; data[left + i] = temp[i]; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>思路：参见灯神的视频</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(vector&lt;T&gt; &amp;data, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> lc = <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>, rc = <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>, max = index;<br>    <span class="hljs-keyword">if</span>((lc &lt; size) &amp;&amp; data[lc] &gt; data[max]) &#123; max = lc; &#125;<br>    <span class="hljs-keyword">if</span>((rc &lt; size) &amp;&amp; data[rc] &gt; data[max]) &#123; max = rc; &#125;<br>    <span class="hljs-keyword">if</span>(index != max)&#123;<br>        <span class="hljs-built_in">swap</span>(data[max], data[index]);<br>        <span class="hljs-built_in">heapify</span>(data, max, size);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildHeap</span><span class="hljs-params">(vector&lt;T&gt; &amp;data)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> size = data.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size &gt;&gt; <span class="hljs-number">1</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123; <span class="hljs-built_in">heapify</span>(data, i, size); &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(vector&lt;T&gt; &amp;data, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> size = data.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">buildHeap</span>(data);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-built_in">swap</span>(data[<span class="hljs-number">0</span>], data[i]);<br>        <span class="hljs-built_in">heapify</span>(data, <span class="hljs-number">0</span>, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>适用于数据量很大，但是数据返回很小</p><p>思路：记录每种元素数量的大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">countSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;data)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> size = data.<span class="hljs-built_in">size</span>(), index = <span class="hljs-number">0</span>, min = data[<span class="hljs-number">0</span>], max = data[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> item : data) &#123;<br>        min = item &lt; min ? item : min;<br>        max = item &gt; max ? item : max;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">valueCount</span><span class="hljs-params">(max - min + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">datacpy</span><span class="hljs-params">(data.begin(), data.end())</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item : datacpy) &#123; ++valueCount[item - min]; &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = min; i &lt;= max; ++i) &#123;<br>        <span class="hljs-keyword">while</span> (valueCount[i - min]--) &#123; data[index++] = i; &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>把数据缩小范围，然后组内进行排序</p><p>计数排序和基数排序都是桶排序的一种</p><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>多关键字的排序</p><p>例如对整数进行排序，</p>]]></content>
    
    
    <categories>
      
      <category>计算机相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>编程</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++基础回顾</title>
    <link href="/2021/08/10/HUST/CPPBase/"/>
    <url>/2021/08/10/HUST/CPPBase/</url>
    
    <content type="html"><![CDATA[<p>C++的基础知识，用于面试前的突击。</p><span id="more"></span><h1 id="编译内存相关"><a href="#编译内存相关" class="headerlink" title="编译内存相关"></a>编译内存相关</h1><h2 id="C-程序编译过程"><a href="#C-程序编译过程" class="headerlink" title="C++程序编译过程"></a>C++程序编译过程</h2><p>C++程序有4个编译过程，分别是预处理、编译、汇编和链接。</p><ul><li><p>预处理：负责处理以 <code>#</code> 开头的指令，像 <code>#include</code> 就是将对应的文件原封不动的复制过来</p></li><li><p>编译：负责将预处理好的 <code>C++</code> 源文件翻译为汇编代码，编译完成后得到 <code>.s</code> 文件</p></li><li><p>汇编：负责将汇编代码翻译为二进制的机器指令，把这些指令打包成可重定位目标程序</p></li><li><p>链接：负责将上面生成的可重定位目标程序和库文件等等打包成最终的一个可执行文件</p><p>其中链接分为两种</p><ul><li><p>静态链接：链接的时候把静态链接库中的程序直接拷贝到最终的可执行文件，这个库在每个用到它的可执行文件中都拷贝了一份</p><p>静态链接库<strong>浪费空间，更新困难</strong>，优点是效率高</p></li><li><p>动态链接：程序在编译时只记录动态链接库的名字等一些信息，在运行的时候加载动态链接库，一个动态链接库只有一个对应的库文件</p><p>动态链接库节省空间、更新方便，但是每次执行的时候需要重定位，相比静态链接有一定的性能损失</p></li></ul></li></ul><h2 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h2><p>C++将内存进行了一个分区操作，将内存分为了 <code>.text</code> <code>.data</code> <code>.bss</code> <code>.rodata</code> 堆区和栈区。</p><ul><li><code>.text</code> 存放机器代码</li><li><code>.data</code> 存放已初始化的静态变量和全局变量</li><li><code>.bss</code> 存放未初始化的静态和全局变量，以及所有被初始化为 0 的静态和全局变量</li><li><code>.rodata</code> 存放只读数据</li><li>堆区 存放动态申请的内存空间，需要手动的申请和释放，或者程序运行结束操作系统释放</li><li>栈区 存放函数的局部变量、函数参数和函数的返回地址等信息，由程序自动释放</li></ul><h3 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h3><ul><li>申请方式上，堆需要通过 <code>new/delete</code> 关键字进行一个手动的释放，栈有程序自动的分配和回收</li><li>存放内容上，堆存放的是手动分配的数据，栈存放的是局部变量、函数的参数和函数的返回地址</li><li>分配方式上，堆上分配的数据是不连续的，栈上分配的数据是连续的</li><li>拓展上，堆向高地址拓展，栈向低地址拓展</li><li>效率上，由于堆是类似于一种链表在内存中呈现，所以分配和销毁都需要消耗一定的时间，因此堆效率比栈要低</li></ul><h2 id="全局变量、局部变量、静态全局变量、静态局部变量的区别"><a href="#全局变量、局部变量、静态全局变量、静态局部变量的区别" class="headerlink" title="全局变量、局部变量、静态全局变量、静态局部变量的区别"></a>全局变量、局部变量、静态全局变量、静态局部变量的区别</h2><p>全局和局部是作用域的概念；静态和非静态是生命周期的概念</p><ul><li>从作用域来看<ul><li>全局变量作用于所有的源文件，当然，其他文件需要用 <code>extern</code> 关键字重新申明</li><li>静态全局变量作用于本文件，无法作用于其他文件</li><li>静态局部变量和局部变量作用于代码块中，静态局部变量只会初始化一次，而局部变量只在代码块中，离开了代码块就会被销毁</li></ul></li><li>从生命周期来看<ul><li>静态变量和全局变量都会在程序的全生命周期，储存在<code>.bss/.data</code>，局部变量的生命周期在代码块中，存储在栈中</li></ul></li></ul><h3 id="全局变量定义在头文件中有什么问题"><a href="#全局变量定义在头文件中有什么问题" class="headerlink" title="全局变量定义在头文件中有什么问题"></a>全局变量定义在头文件中有什么问题</h3><p>全局变量有全局作用域，当不同的文件定义了同一个名字的全局变量，然后不同的文件 <code>#include</code> 的话就会出现链接错误，就是一个变量定义了多次</p><p>解决方法有</p><ul><li>全局常量作为外部变量，使用 <code>extern</code> 关键字说明这个变量在外部定义</li></ul><h2 id="对象创建限制在堆或栈"><a href="#对象创建限制在堆或栈" class="headerlink" title="对象创建限制在堆或栈"></a>对象创建限制在堆或栈</h2><h3 id="限制在堆中"><a href="#限制在堆中" class="headerlink" title="限制在堆中"></a>限制在堆中</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span>&#123;</span><br>    <span class="hljs-comment">// static使得在没有实例的情况下也能获取对象</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> Demo *<span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Demo; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteItem</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>; &#125;<br><span class="hljs-keyword">protected</span>:<span class="hljs-comment">// 使得派生类也能访问析构函数</span><br>    <span class="hljs-built_in">Demo</span>();<br>    ~<span class="hljs-built_in">Demo</span>();<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="限制在栈中"><a href="#限制在栈中" class="headerlink" title="限制在栈中"></a>限制在栈中</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(<span class="hljs-keyword">size_t</span> t)</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span> *)<span class="hljs-literal">nullptr</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span> </span>&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="什么是内存对齐？为什么要进行内存对齐，有什么优点？"><a href="#什么是内存对齐？为什么要进行内存对齐，有什么优点？" class="headerlink" title="什么是内存对齐？为什么要进行内存对齐，有什么优点？"></a>什么是内存对齐？为什么要进行内存对齐，有什么优点？</h2><p>内存对齐的原则就是基本类型有多少字节，对应对象的首地址都必须是多少字节的倍数。例如 <code>int</code> 是4个字节的，那么结构体中 <code>int</code> 类型的地址就要是 4 的倍数，遇到不够的会补充填充字节。另外整个类/结构体的大小是这里面字节数最宽的基本类型对应字节数的整数倍。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><br>    <span class="hljs-keyword">short</span> var0;<span class="hljs-comment">// 0, short占2字节, 填充2字节</span><br>    <span class="hljs-keyword">int</span> var1;<span class="hljs-comment">// 4, int占4字节</span><br>    <span class="hljs-keyword">float</span> var2;<span class="hljs-comment">// 8, float占4字节</span><br>    <span class="hljs-keyword">long</span> var3;<span class="hljs-comment">// 12, long占4字节 32(64)</span><br>    <span class="hljs-keyword">char</span> var4;<span class="hljs-comment">// 16, int占1字节，填充3字节</span><br>    std::string var5;<span class="hljs-comment">// 20,string占24字节</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>优点</p><ul><li>CPU读取内存时，是一块一块读取的，使用对齐会提高内存访问效率</li><li>有些硬件不支持任意地址的数据访问</li></ul><h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p>程序没有释放不用了的内存</p><ul><li>程序编码错误，<code>new</code> 的数据没有<code>delete</code> </li><li>程序异常，正常的分支无法对内存进行释放</li><li>无主内存，<code>new</code> 得到的指针被赋到另外一个值了</li><li>类的析构函数不是虚函数，当用父类指针销毁时，子类的成员变量无法得到释放</li><li>隐式内存泄露，程序不断的申请内存，但是在程序结束的时候才进行释放，比如说申请大量的Socket资源但是没有释放</li></ul><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>在头文件 <code>memory</code> 中</p><h3 id="智能指针作用"><a href="#智能指针作用" class="headerlink" title="智能指针作用"></a>智能指针作用</h3><p>C++中堆的管理十分麻烦，申请和释放都是需要手动操作的，容易造成内存泄露、二次释放等问题，使用智能指针能够更好的管理堆内存</p><h3 id="智能指针区别"><a href="#智能指针区别" class="headerlink" title="智能指针区别"></a>智能指针区别</h3><p>有三种类型的智能指针 <code>unique_ptr, share_ptr, week_ptr</code></p><ul><li><code>unique_ptr</code> 独占所指向的对象</li><li><code>share_ptr</code> 可以让多个指针指向同一个对象</li><li><code>week_ptr</code> 是一种伴随类，指向 <code>share_ptr</code> 所管理的对象，这种指针不会改变所控制对象的生命周期</li></ul><h3 id="智能指针底层"><a href="#智能指针底层" class="headerlink" title="智能指针底层"></a>智能指针底层</h3><p>智能指针主要是通过将对象以指针的方式放入一个类中，在这个类的构造函数中创建指针指向的对象，在构造类的析构函数中完成资源的释放。</p><h3 id="智能指针使用中要注意的地方"><a href="#智能指针使用中要注意的地方" class="headerlink" title="智能指针使用中要注意的地方"></a>智能指针使用中要注意的地方</h3><ul><li><p>不 <code>delete</code> <code>get()</code> 返回的指针</p></li><li><p>不用 <code>get()</code> 初始化或 <code>reset</code> 另一个智能指针</p></li><li><p>不要混合使用智能指针</p></li><li><p>使用 <code>get()</code> 返回的指针时，当最后一个智能指针失效时，对应的 <code>get()</code> 返回的指针也就失效了</p></li><li><p>智能指针还会产生 <strong>循环引用</strong> 的问题，两个指针相互指向对方的内存空间，导致内存无法释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span> <span class="hljs-keyword">public</span>: shared_ptr&lt;B&gt; b; &#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>&#123;</span> <span class="hljs-keyword">public</span>: shared_ptr&lt;A&gt; a; &#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A a; B b;<span class="hljs-comment">// A::b, B::a useCount = 1</span><br>    a.b = b;<span class="hljs-comment">// A::b useCount = 2</span><br>    b.a = a;<span class="hljs-comment">// B::a useCount = 2</span><br>&#125;<span class="hljs-comment">// A::b, B::a useCount = 1，资源不会进行释放</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="声明和定义的区别"><a href="#声明和定义的区别" class="headerlink" title="声明和定义的区别"></a>声明和定义的区别</h2><ul><li>声明只是把变量的类型和名字告诉编译器，并没有分配内存。定义的话需要分配内存</li><li>可以多次声明（<code>extern</code>），但是只能有一次定义</li></ul><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="什么是面向对象？面向对象的三大特性"><a href="#什么是面向对象？面向对象的三大特性" class="headerlink" title="什么是面向对象？面向对象的三大特性"></a>什么是面向对象？面向对象的三大特性</h2><p>面向对象就是把对象抽象成类，类中包括成员变量和成员方法。</p><ul><li>封装：类把具体的实现给隐藏起来，只对外提供接口。例如类的 <code>public</code> 部分就是对外的接口</li><li>继承：子类继承父类的成员变量和成员函数</li><li>多态：我理解的多态就是不同的对象对同一个行为有不同的表现方式。总共有两大类<ul><li>静态的多态：包括函数的重载、泛型和模板编程++</li><li>动态的多态</li></ul></li></ul><h2 id="重载、重写、隐藏的区别"><a href="#重载、重写、隐藏的区别" class="headerlink" title="重载、重写、隐藏的区别"></a>重载、重写、隐藏的区别</h2><ul><li><p>重载：同一个可访问区内一个函数名，有着不同的参数</p><blockquote><p>同一个可访问区，函数名相同，参数不同（返回参数不看）</p></blockquote></li><li><p>重写：子类对父类的函数进行一个重新实现</p><blockquote><p>子类与父类间，函数名和参数都相同，父类函数有 <code>virtual</code></p></blockquote></li><li><p>隐藏：派生类的函数会隐藏掉父类的同名函数，不管参数列表是否相同</p><blockquote><p>子类与父类间，函数名相同</p></blockquote></li></ul><h2 id="多态如何实现"><a href="#多态如何实现" class="headerlink" title="多态如何实现"></a>多态如何实现</h2><p>多态是通过虚函数实现的，虚函数的地址保存在虚函数表中，虚函数表的地址保存在含有虚函数的类的实例对象的内存空间中。</p><ol><li>在类中用 virtual 关键字声明的函数叫做虚函数</li><li>存在虚函数的类都有一个虚函数表，当创建一个该类的对象时，该对象有一个指向虚函数表的虚表指针（虚函数表和类对应的，虚表指针是和对象对应）</li><li>当基类指针指向派生类对象，基类指针调用虚函数时，基类指针指向派生类的虚表指针，由于该虚表指针指向派生类虚函数表，通过遍历虚表，寻找相应的虚函数。</li></ol><h1 id="关键字库函数"><a href="#关键字库函数" class="headerlink" title="关键字库函数"></a>关键字库函数</h1><h2 id="sizeof-和strlen-区别"><a href="#sizeof-和strlen-区别" class="headerlink" title="sizeof 和strlen 区别"></a><code>sizeof</code> 和<code>strlen</code> 区别</h2><ul><li><code>sizeof</code> 是一个运算符，<code>strlen</code> 是一个库函数</li><li>适用类型上，<code>sizeof</code> 既适用于类型，也适用于变量，<code>strlen</code> 只适用于 <code>char *</code> 类型的变量</li><li>返回结果上，<code>sizeof</code> 统计的是这个数据实际占用的字节大小，<code>strlen</code> 统计的是这个字符串的长度。<code>char a[10] = &quot;Hello&quot;</code> ，此时 <code>sizeof(a) == 10, strlen == 5</code> （<code>strlen</code> 不包括 <code>\0</code>）</li><li>当传入的类型是<code>char *</code> ，<code>sizeof</code> 返回指针的大小，<code>strlen</code> 返回字符串的长度 </li></ul><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>lambda表达式是一个匿名函数</p><p>lambda表达式的基本形式是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[capture list](params list) -&gt;<span class="hljs-keyword">return</span> type &#123; function body &#125;<br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>捕获形式</th><th>说明</th></tr></thead><tbody><tr><td>[]</td><td>不捕获任何外部变量</td></tr><tr><td>[变量名, …]</td><td>默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用&amp;说明符）</td></tr><tr><td>[this]</td><td>以值的形式捕获this指针</td></tr><tr><td>[=]</td><td>以值的形式捕获所有外部变量</td></tr><tr><td>[&amp;]</td><td>以引用形式捕获所有外部变量</td></tr><tr><td>[=, &amp;x]</td><td>变量x以引用形式捕获，其余变量以传值形式捕获</td></tr><tr><td>[&amp;, x]</td><td>变量x以值的形式捕获，其余变量以引用形式捕获</td></tr></tbody></table></div><p>当定义 lambda 表达式的时候，编译器会生成一个匿名类，这个类的成员就是捕获的内容，它还重载了<code>()</code> 运算符。在运行的时候，<code>lambda</code> 表达式会生成一个匿名类的对象，如何调用它的 <code>()</code> 表达式</p><h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a><code>explicit</code></h2><p>用来禁止隐式转换</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>只能用于单参数的构造函数</li></ul><h2 id="static"><a href="#static" class="headerlink" title="static"></a><code>static</code></h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>作用于局部变量时，可以延长变量的生命周期，变量的生命周期将一直持续到程序运行借宿</li><li>作用于全局变量和函数时，可以限制变量和函数的作用域，将变量和函数限制在本文件中</li><li>作用于类的成员变量和成员函数时，可以不把这个类实例成对象就使用类对应的变量和函数</li></ul><h3 id="在类中使用的注意事项"><a href="#在类中使用的注意事项" class="headerlink" title="在类中使用的注意事项"></a>在类中使用的注意事项</h3><ul><li>静态成员变量的定义和初始化是在类外进行的，类内只进行声明，类外初始化的时候不能出现 <code>static</code> 关键字</li><li>静态成员变量被所有类的对象和子类的对象所共享</li><li>静态成员变量可以作为类的成员函数的参数，普通的成员变量不能</li><li>静态成员函数没有 <code>this</code> 指针，不能声明为 <code>const/volatile/virtual</code> 函数，这些函数是通过改变 <code>this</code> 指针来进行限定的</li><li>静态成员函数不能调用非静态成员变量和非静态成员函数，原因也是没有 <code>this</code> 指针</li></ul><h2 id="const"><a href="#const" class="headerlink" title="const"></a><code>const</code></h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><ul><li><code>const</code> 修饰成员变量可以进行类型检查，节省内存空间，提高效率</li><li><code>const</code> 修饰函数参数可以保证参数不发生改变</li><li><code>const</code> 修饰成员函数可以保证这个类里面的成员变量不会发生改变</li></ul><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ul><li><code>const</code> 成员变量<ul><li><code>const</code> 成员变量只能在类内声明、定义和初始化，最好在类的初始化列表中进行初始化</li></ul></li><li><code>const</code> 成员函数<ul><li><code>const</code> 不能修改成员变量的值，除非该变量有 <code>mutable</code> 进行了修饰</li><li><code>const</code> 不能调用非静态的成员函数和成员变量</li></ul></li></ul><h2 id="define"><a href="#define" class="headerlink" title="define"></a><code>define</code></h2><h3 id="define-和-const-的区别"><a href="#define-和-const-的区别" class="headerlink" title="define 和 const 的区别"></a><code>define</code> 和 <code>const</code> 的区别</h3><ul><li><code>define</code> 是预处理阶段进行的，<code>const</code> 是编译阶段进行的</li><li><code>define</code> 只是进行简单的替换，没有进行类型安全的检查</li><li><code>define</code> 进行的替换会在内存中有多个备份，而 <code>const</code> 在程序运行中只有一份</li><li><code>const</code> 定义的变量在调试的过程中可以显示数值</li></ul><h3 id="define-和-typedef-的区别"><a href="#define-和-typedef-的区别" class="headerlink" title="define 和 typedef 的区别"></a><code>define</code> 和 <code>typedef</code> 的区别</h3><ul><li><code>typedef</code> 在编译期间进行，有类型检查功能</li><li><code>typedef</code> 有作用域的限制</li><li>指针的操作：<code>typedef</code> 和 <code>#define</code> 在处理指针时不完全一样</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INTPTR1 int *</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> * INTPTR2;<br>INTPTR1 ptr0, ptr1;<span class="hljs-comment">// ptr0: int *; ptr1: int </span><br>INTPTR2 ptr2, ptr3;<span class="hljs-comment">// ptr2: int *; ptr3: int *</span><br><span class="hljs-keyword">const</span> INTPTR1 ptr4;<span class="hljs-comment">// ptr4: int * -&gt; const int 指针指向的是常量</span><br><span class="hljs-keyword">const</span> INTPTR2 ptr5;<span class="hljs-comment">// ptr5: int *const这个指针是常量</span><br></code></pre></td></tr></table></figure><h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a><code>inline</code></h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li>内联函数是函数在编译阶段，编译器将内联函数的函数体嵌入到调用内联函数的地方</li><li>普通函数是需要保护上下文，将返回地址等等数据压入栈中，把传入的参数存入寄存器中，然后更改PC指针到函数对应的地方，函数调用完毕后，还需要恢复现场，需要比较大的开销</li></ul><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul><li>在类内声明类外定义加 <code>inline</code> 都可以</li></ul><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><ul><li>减少函数开销</li><li>去除函数只能定义一次的限制</li></ul><h2 id="new-delete"><a href="#new-delete" class="headerlink" title="new / delete"></a><code>new</code> / <code>delete</code></h2><h3 id="new-delete-和-malloc-free-的区别"><a href="#new-delete-和-malloc-free-的区别" class="headerlink" title="new/delete 和 malloc/free 的区别"></a><code>new/delete</code> 和 <code>malloc/free</code> 的区别</h3><ul><li><code>new/delete</code> 会调用构造函数和析构函数，<code>malloc/free</code> 没有</li><li><code>new/delete</code> 无需指定分配空间的大小，编译器会自动计算，<code>malloc/free</code> 需要</li><li><code>new</code>分配成果返回对应类型的指针，失败抛出 <code>bad_alloc</code> 异常，<code>malloc</code>分配成果返回 <code>void *</code> 类型的指针，失败返回空指针</li></ul><h3 id="delete-实现原理"><a href="#delete-实现原理" class="headerlink" title="delete 实现原理"></a><code>delete</code> 实现原理</h3><ul><li>调用该对象所属类的析构函数</li><li>释放内存空间</li></ul><h2 id="union"><a href="#union" class="headerlink" title="union"></a><code>union</code></h2><p><code>union</code> 总的来说就是对同一个数据用不同的方式译码</p><ul><li><code>union</code> 有若干个成员组成，但是只有一个有效的成员</li><li><code>union</code> 更改一个成员变量的值，其他成员变量的值都会更改</li><li><code>union</code> 的大小为所有成员中最大的，还应遵循内存对齐原则</li></ul><h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><p>例如下面这个例子可以判断是小端法还是大端法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">smallOrBig</span> &#123;</span> <span class="hljs-keyword">int</span> data; <span class="hljs-keyword">char</span> ch; &#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    smallOrBig data;<br>    data.data =<span class="hljs-number">0x1234</span>;<br>    std::cout &lt;&lt; data.ch &lt;&lt; std::endl;<span class="hljs-comment">// 0x34 -&gt; small; 0x12 -&gt; big</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a><code>volatile</code></h2><p>使用 <code>volatile</code> 关键字修饰变量表示这个变量很可能被编译器所不知道的因素更改，比如说多线程、中断和一些硬件。</p><p>编译器遇到 <code>volatitle</code> 修饰的变量时会停止对这个变量进行编译上的优化，同时使用的时候系统每次都从内存中读取这个数据，即使CPU刚刚已经读取过</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>多线程中如果两个线程更改同一个变量时，如果编译器对它进行优化，就会出现一个正在使用内存中的变量，一个正在使用CPU寄存器中的变量，导致计算结果不符合预期。<code>volatile</code>的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。</li><li>当读取一些硬件设备寄存器的时候，他们的寄存器的值可能很快的改变，<code>volatile</code> 可以保证编译器不会对这个访问进行优化</li></ul><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a><code>static_cast</code></h3><p>只能用于<strong>低风险</strong>的强制类型转换（只能用于可以进行隐式类型转换的情况，作用只是将隐式类型转换挑明），无法用于不同类型指针之间的转换、整形和指针之间的转换</p><ul><li><code>void *</code> 转换成其他类型的指针</li><li>浮点、整数、字符的转换</li><li>父类转换为子类（这种情况是特例，隐式类型转换不能编译通过，但是<code>static_cast</code>可以）</li><li>子类转换为父类</li><li>转换运算符</li></ul><p><code>static_cast</code> 主要功能是替换隐式类型转换，让代码可读性更好</p><h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a><code>const_cast</code></h3><p>将常量转化为非常量，只针对指针、引用和 <code>this</code> 指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> i = <span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(ci);<span class="hljs-comment">// ERROR</span><br><span class="hljs-keyword">int</span> *pi = <span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">int</span> *&gt;(&amp;ci);<br><span class="hljs-keyword">int</span> &amp;i = <span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">int</span> &amp;&gt;(ci);<br></code></pre></td></tr></table></figure><h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a><code>dynamic_cast</code></h3><p>负责子类和父类之间的转换。实现了一个检测功能，当发现不安全这种情况会判断转型失败，返回空指针，对应用类型的转换失败会抛出异常</p><p><code>dynamic_cast</code> 采用了 <code>RTTI</code> （运行时类型识别）这种技术来在运行时检测被转换的指针的类型，有额外的开销，因此建议只在<strong>父类指针转子类</strong>的情况下使用</p><p><code>RTTI</code> 的实现依赖于虚函数，因此 <code>dynamic_cast</code> 只能在<strong>有虚函数</strong>的类转换过程中使用，否则会编译错误</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Create A&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Print A&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>:</span> <span class="hljs-keyword">public</span> A &#123; <span class="hljs-keyword">public</span>: <span class="hljs-keyword">int</span> data = <span class="hljs-number">1</span>; &#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    B *ptrB = <span class="hljs-keyword">dynamic_cast</span>&lt;B *&gt;(<span class="hljs-keyword">new</span> A);<span class="hljs-comment">// 不安全，转型失败，ptrB == nullptr</span><br>    A *ptrA = <span class="hljs-keyword">dynamic_cast</span>&lt;A *&gt;(<span class="hljs-keyword">new</span> B);<span class="hljs-comment">// 安全</span><br>    B *ptrBA = <span class="hljs-keyword">dynamic_cast</span>&lt;B *&gt;(ptrA);<span class="hljs-comment">// 安全</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a><code>reinterpret_cast</code></h3><p>用于替换强制类型转换，是进行逐字节的重新翻译</p><h1 id="类相关"><a href="#类相关" class="headerlink" title="类相关"></a>类相关</h1><h2 id="虚函数与纯虚函数"><a href="#虚函数与纯虚函数" class="headerlink" title="虚函数与纯虚函数"></a>虚函数与纯虚函数</h2><p>虚函数是用 <code>virtual</code> 关键字修饰的成员函数，当子类继承有虚函数的类，并且重写了这个虚函数时，如果一个父类的指针指向子类的对象，那么这个指针在调用虚函数时，处理的函数时子类中对应的函数</p><p>纯虚函数时 <code>virtual</code> 关键字修饰，并且在函数声明的末尾用 <code>=0</code> 进行修饰的函数，有了纯虚函数的类叫做抽象类，这个类不能够实例化，子类继承抽象类后实现所有的纯虚函数才能够实例化</p><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><ul><li>虚函数可以直接使用，纯虚函数必须要在子类实现后才能够使用</li><li>纯虚函数可以只声明不实现，虚函数必须要实现</li><li>定义形式不同</li></ul><h3 id="虚函数实现机制"><a href="#虚函数实现机制" class="headerlink" title="虚函数实现机制"></a>虚函数实现机制</h3><p>虚函数时通过虚函数表来实现的。如果一个类或者它的父类中有虚函数，它成员变量中就会有一个指向虚函数表的指针。当一个父类的指针指向一个子类的对象时，父类的指针就会通过这个虚表指针找到子类的虚函数表，从而调用子类定义的虚函数</p><blockquote><p>虚函数表和类绑定，虚表指针和类的对象绑定</p></blockquote><h3 id="虚函数表相关"><a href="#虚函数表相关" class="headerlink" title="虚函数表相关"></a>虚函数表相关</h3><ul><li>存放内容：虚函数的地址</li><li>建立时间：编译阶段</li><li>虚表指针位置：存放在对象内存空间最前面的位置</li><li>对象建立过程：程序在初始化子类对象的时候，会先调用父类的构造函数，然后当遇到了父类的虚函数，编译器将虚表指针指向父类的虚表，随后调用子类的构造函数，虚表指针被覆盖，指向子类的虚表</li><li>多继承的情况，继承了几个类就有几个类的虚函数表</li></ul><h2 id="类的构造"><a href="#类的构造" class="headerlink" title="类的构造"></a>类的构造</h2><h3 id="禁止类的构造函数使用"><a href="#禁止类的构造函数使用" class="headerlink" title="禁止类的构造函数使用"></a>禁止类的构造函数使用</h3><ul><li>禁止类外使用：声明为 <code>private/protect</code></li><li>禁止类外和类内使用：增加 <code>= delete</code> 修饰符</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CString</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">()</span> </span>= <span class="hljs-keyword">delete</span>;<span class="hljs-comment">//这样不允许使用new关键字</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="构造函数与析构函数定义为虚函数"><a href="#构造函数与析构函数定义为虚函数" class="headerlink" title="构造函数与析构函数定义为虚函数"></a>构造函数与析构函数定义为虚函数</h3><ul><li><p>构造函数一般不声明为虚函数</p><p>原因是构造函数的目的是为了创造对象，而虚函数需要使用对象中的虚表指针，才能实现对虚函数的调用。此时对象还没有创建，因此如果构造函数时虚函数就无法调用</p></li><li><p>析构函数一般声明为虚函数</p><p>原因主要时为了防止内存泄漏。当父类的指针指向子类的对象时，如果使用 <code>delete</code> 关键字对这个对象进行回收，只会调用父类的析构函数，子类中的成员变量就得不到释放，造成内存泄露</p></li></ul><h3 id="多重继承出现问题"><a href="#多重继承出现问题" class="headerlink" title="多重继承出现问题"></a>多重继承出现问题</h3><ul><li><p>数据冗杂</p></li><li><p>命名冲突</p><p>常常出现在菱形继承中</p><pre><code class=" mermaid">classDiagramBase1 &lt;|-- Base2Base1 &lt;|-- Base3Base2 &lt;|-- Base4Base3 &lt;|-- Base4</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base1</span> &#123;</span> <span class="hljs-keyword">public</span>: <span class="hljs-keyword">int</span> var1; &#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base2</span> :</span> <span class="hljs-keyword">public</span> Base1 &#123; <span class="hljs-keyword">public</span>: <span class="hljs-keyword">int</span> var2; &#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base3</span> :</span> <span class="hljs-keyword">public</span> Base1 &#123; <span class="hljs-keyword">public</span>: <span class="hljs-keyword">int</span> var3; &#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base2, <span class="hljs-keyword">public</span> Base3 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var1 = tmp; &#125; <br>    <span class="hljs-comment">// error: reference to &#x27;var1&#x27; is ambiguous. 命名冲突</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> var4;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derive d;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>解决方法：</p><ul><li><p>指定冲突的变量来自那个类 <code>void set_var1(int tmp) &#123; Base2::var1 = tmp; &#125;</code> </p></li><li><p>使用虚继承，保证类的成员变量只有一份</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base2</span> :</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Base1 &#123; <span class="hljs-keyword">public</span>: <span class="hljs-keyword">int</span> var2; &#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base3</span> :</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Base1 &#123; <span class="hljs-keyword">public</span>: <span class="hljs-keyword">int</span> var3; &#125;;<br></code></pre></td></tr></table></figure></li></ul><h3 id="拷贝构造函数必须为引用"><a href="#拷贝构造函数必须为引用" class="headerlink" title="拷贝构造函数必须为引用"></a>拷贝构造函数必须为引用</h3><p>拷贝构造函数在调用的时候，如果传入的是变量，将会先调用拷贝构造函数，这样就会造成无限制的递归，最终导致栈溢出</p><h3 id="类对象的初始化顺序-析构顺序"><a href="#类对象的初始化顺序-析构顺序" class="headerlink" title="类对象的初始化顺序/析构顺序"></a>类对象的初始化顺序/析构顺序</h3><ol><li>调用基类的构造函数，多重继承按照派生类表的顺序进行</li><li>按照声明的顺序对类的成员变量进行初始化</li><li>调用自身构造函数</li></ol><blockquote><p>析构函数调用顺序与构造函数相反</p></blockquote><h3 id="使用成员初始化列表会快些的原因"><a href="#使用成员初始化列表会快些的原因" class="headerlink" title="使用成员初始化列表会快些的原因"></a>使用成员初始化列表会快些的原因</h3><p>对象的成员变量初始化在进入构造函数函数体之前完场，如果在构造函数内进行成员变量的初始化，这样成员变量就会产生两次拷贝，造成浪费。使用成员初始化列表就相当于是一步到位了</p><blockquote><p>类内初始化和初始化列表一样，不过初始化列表优先级更高，有初始化列表的，类内初始化会自动屏蔽</p></blockquote><h3 id="实例化对象的几个阶段"><a href="#实例化对象的几个阶段" class="headerlink" title="实例化对象的几个阶段"></a>实例化对象的几个阶段</h3><ol><li>分配空间，不同的对象分配的时机不同</li><li>（虚表指针赋值）</li><li>初始化</li><li>赋值</li></ol><h3 id="C-构造函数"><a href="#C-构造函数" class="headerlink" title="C++构造函数"></a>C++构造函数</h3><ul><li><p>默认构造函数：没有任何参数的构造函数</p></li><li><p>拷贝构造函数：同一类型的对象进行拷贝</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">Box</span>(Box&amp; other); <span class="hljs-comment">// Avoid if possible--allows modification of other.</span><br><span class="hljs-built_in">Box</span>(<span class="hljs-keyword">const</span> Box&amp; other);<br><span class="hljs-built_in">Box</span>(<span class="hljs-keyword">volatile</span> Box&amp; other);<br><span class="hljs-built_in">Box</span>(<span class="hljs-keyword">volatile</span> <span class="hljs-keyword">const</span> Box&amp; other);<br><span class="hljs-comment">// Additional parameters OK if they have default values</span><br><span class="hljs-built_in">Box</span>(Box&amp; other, <span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>, string label = <span class="hljs-string">&quot;Box&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>移动构造函数：传入参数为右值引用的构造函数</p></li><li><p>委托构造函数：一个构造函数调用了另外一个个构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">Box</span>() &#123;&#125;<br><span class="hljs-built_in">Box</span>(<span class="hljs-keyword">int</span> i) : <span class="hljs-built_in">Box</span>() &#123;&#125;<span class="hljs-comment">// 委托构造函数</span><br></code></pre></td></tr></table></figure></li><li><p>继承构造函数：子类用了基类的构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>  <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> i) &#123;&#125;<br>  <span class="hljs-built_in">A</span>(<span class="hljs-keyword">double</span> d, <span class="hljs-keyword">int</span> i) &#123;&#125;<br>  <span class="hljs-built_in">A</span>(<span class="hljs-keyword">float</span> f, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* c) &#123;&#125;<br>  <span class="hljs-comment">//...</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span> :</span> A &#123; <span class="hljs-keyword">using</span> A::A; &#125;;<span class="hljs-comment">//关于基类各构造函数的继承一句话搞定 </span><br></code></pre></td></tr></table></figure></li></ul><h2 id="空类的默认函数"><a href="#空类的默认函数" class="headerlink" title="空类的默认函数"></a>空类的默认函数</h2><p>对于一份空类来说，如果没有实例化，编译器不会为它生成任何函数，在使用的时候，会根据情况生成 6 类函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>();<span class="hljs-comment">// 默认构造函数</span><br>    ~<span class="hljs-built_in">A</span>();<span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">const</span> A &amp;);<span class="hljs-comment">// 拷贝构造函数</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>= (<span class="hljs-keyword">const</span> A &amp;);<span class="hljs-comment">// =运算符</span><br>    A *<span class="hljs-keyword">operator</span>&amp; ();<span class="hljs-comment">// &amp;运算符</span><br>    <span class="hljs-keyword">const</span> A *<span class="hljs-keyword">operator</span>&amp; () <span class="hljs-keyword">const</span>;<span class="hljs-comment">// &amp;运算符的const版本</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="友元注意事项"><a href="#友元注意事项" class="headerlink" title="友元注意事项"></a>友元注意事项</h2><ul><li>友元是单向的</li><li>友元关系不能被继承</li><li>友元关系不具有传递性，例如A是B的友元，C是A的友元，但是C不能访问B的私有变量</li></ul><h2 id="静态类型和动态类型，静态绑定和动态绑定"><a href="#静态类型和动态类型，静态绑定和动态绑定" class="headerlink" title="静态类型和动态类型，静态绑定和动态绑定"></a>静态类型和动态类型，静态绑定和动态绑定</h2><ul><li><p>静态类型：对象在声明时的类型，在编译的时候确定，非虚函数的调用对象由静态类型决定</p></li><li><p>动态类型：指针和引用所指的类型，在运行时确定，虚函数的调用对象由动态类型决定</p></li><li><p>静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期，非虚函数一般都是静态绑定</p><blockquote><p>静态绑定的函数空指针也能调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;A&quot;</span> &lt;&lt; endl; &#125; &#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A *a = <span class="hljs-literal">nullptr</span>;<br>    a-&gt;<span class="hljs-built_in">print</span>();<span class="hljs-comment">// 能够输出 A</span><br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期，虚函数一般都是动态绑定</p></li></ul><blockquote><p>不要重新定义父类的非虚函数</p><p>不要定义基类虚函数的<strong>缺省参数</strong>, 否则会产生异常。因为缺省是静态绑定，虚函数是动态绑定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">E</span> &#123;</span> <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>)</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;E: &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125; &#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">F</span>:</span> <span class="hljs-keyword">public</span> E &#123; <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>)</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;F: &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125; &#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <br>    F* pf = <span class="hljs-keyword">new</span> <span class="hljs-built_in">F</span>(); E* pe = pf;<br>    pf-&gt;<span class="hljs-built_in">func</span>(); <span class="hljs-comment">//F: 1  正常，就该如此；</span><br>    pe-&gt;<span class="hljs-built_in">func</span>(); <span class="hljs-comment">//F: 0  调用了子类的函数，却使用了基类中参数的默认值！</span><br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="编译时多态和运行时多态"><a href="#编译时多态和运行时多态" class="headerlink" title="编译时多态和运行时多态"></a>编译时多态和运行时多态</h2><ul><li>编译时多态：指的是函数重载和模板（泛型编程）</li><li>运行时多态：指的是父类的指针指向子类的对象，从而通过这个指针访问子类的虚函数（虚函数）</li></ul><h2 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h2><ul><li>浅拷贝是在拷贝指针时，只拷贝了指针，并没有开辟新地址。当指针指向的对线被销毁后，拷贝后的指针就变成了一个无效的指针。访问其中的资源就会出现错误</li><li>深拷贝是指拷贝指针的时候申请一块新的地址用来存放拷贝的值。即使原先的对象被销毁掉，也不会影响深拷贝的值。</li></ul><blockquote><p>浅拷贝在对象的拷贝创建时存在风险，即被拷贝的对象析构释放资源之后，拷贝对象析构时会再次释放一个已经释放的资源，深拷贝的结果是两个对象之间没有任何关系，各自成员地址不同。</p><p>深拷贝需要自己实现</p></blockquote><h1 id="语言特性相关"><a href="#语言特性相关" class="headerlink" title="语言特性相关"></a>语言特性相关</h1><h2 id="值类别"><a href="#值类别" class="headerlink" title="值类别"></a>值类别</h2><h3 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h3><ul><li><p>左值就是可以取地址的值，左值可以标识一个对象，或者一个函数，又或者一个地址</p></li><li><p>右值就相当于是一个临时的对象，例如字面量和两个对象相加形成的没有名字的临时变量，右值很快就会被销毁</p></li><li><p>C++11 标准又引入了一个 <code>xvalue</code> 将亡值，是由右值引用的产生而引起的，它是通过“右值引用”产生的对象，有两类</p><ul><li>返回右值引用的函数的调用表达式</li><li>转换为右值引用的转换函数的调用表达式</li></ul></li></ul><pre><code class=" mermaid">graph TBvalue --拥有身份--&gt; glvalue[泛左值glvaule]value --可以移动--&gt; rvalue[右值rvalue]glvalue --不能移动--&gt; lvalue[左值lvalue]glvalue --可以移动--&gt; xvaluervalue --拥有身份--&gt; xvalue[亡值xvalue]rvalue --没有身份--&gt; prvalue[纯右值prvalue]</code></pre><blockquote><p><a href="https://www.jianshu.com/p/4538483a1d8a">https://www.jianshu.com/p/4538483a1d8a</a></p></blockquote><h3 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h3><ul><li><p><code>A &amp;</code> 只能引用左值</p></li><li><p><code>const A &amp;</code> 常量引用可以引用左值也可以引用右值</p></li><li><p><code>A &amp;&amp;</code> 只能引用右值</p></li></ul><h3 id="右值引用的目的"><a href="#右值引用的目的" class="headerlink" title="右值引用的目的"></a>右值引用的目的</h3><p>在C++11中，用左值去初始化一个对象或为一个已有对象赋值时，会调用拷贝构造函数或拷贝赋值运算符来拷贝资源，而当用一个右值（包括纯右值和将亡值）来初始化或赋值时，会调用移动构造函数或移动赋值运算符来移动资源，从而避免拷贝，提高效率。</p><p>除此之外还有移动语义和完美转发两个功能</p><ul><li>移动语义通过 <code>move()</code> 将左值变为右值，让左值也能通过移动构造函数来高效的进行</li><li>完美转发通过 <code>forward()</code> 实现参数在传递过程中保持其值属性的功能，即若是左值，则传递之后仍然是左值，若是右值，则传递之后仍然是右值。</li></ul><h3 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h3><ul><li>有时候我们会遇到这样一种情况，我们用对象a初始化对象b后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；</li><li>拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制；</li><li>C++引入了移动构造函数，专门处理这种，用a初始化b后，就将a析构的情况；</li><li>与拷贝类似，移动也使用一个对象的值设置另一个对象的值。但是，又与拷贝不同的是，移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。这里未命名的对象就是那些临时变量，甚至都不会有名称。典型的未命名对象就是函数的返回值或者类型转换的对象。使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象。做到这些，就要使用移动构造函数和移动赋值：当使用一个临时变量对象进行构造初始化的时候，调用移动构造函数。类似的，使用未命名的变量的值赋给一个对象时，调用移动赋值操作；</li></ul><h3 id="move-forward"><a href="#move-forward" class="headerlink" title="move() , forward()"></a><code>move()</code> , <code>forward()</code></h3><h2 id="指针相关"><a href="#指针相关" class="headerlink" title="指针相关"></a>指针相关</h2><h3 id="野指针和悬空指针"><a href="#野指针和悬空指针" class="headerlink" title="野指针和悬空指针"></a>野指针和悬空指针</h3><ul><li>野指针：没有初始化的指针</li><li>悬空指针：指针指向的对象被销毁</li></ul><h3 id="NULL和nullptr区别"><a href="#NULL和nullptr区别" class="headerlink" title="NULL和nullptr区别"></a><code>NULL</code>和<code>nullptr</code>区别</h3><ul><li><code>NULL</code> 开源于 C 语言，是一条宏指令，内容为0，在 C++ 中定义为整数 0，无法做到与整数的区分</li><li><code>nullptr</code> 是关键字，它本身就是有类型的，没有二义性的问题</li></ul><h3 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h3><ul><li>引用是别名，在声明的时候就要初始化，指针不用</li><li>指针可以实现多极指针，引用只能有一级</li><li>指针在运行的过程中可以改变所指向的对象，引用不行</li><li>指针本身在内存中占有空间，而引用根据编译器的不同而不同<ul><li>当编译器通过指针实现引用时，占内存</li><li>当编译器通过对象替换来实现引用时，不占内存</li></ul></li></ul><h3 id="常量指针和指针常量"><a href="#常量指针和指针常量" class="headerlink" title="常量指针和指针常量"></a>常量指针和指针常量</h3><ul><li>常量指针：指针指向一个常量，无法更改所指向对象的值</li><li>指针常量：指针是一个常量，无法更改所指向对象</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux快速入门</title>
    <link href="/2021/08/09/HUST/LinuxCrash/"/>
    <url>/2021/08/09/HUST/LinuxCrash/</url>
    
    <content type="html"><![CDATA[<p>本文是 Linux 命令行和一些小工具的笔记，方便忘记了回顾用</p><span id="more"></span><h1 id="Linux基本命令"><a href="#Linux基本命令" class="headerlink" title="Linux基本命令"></a>Linux基本命令</h1><h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><ul><li><code>pwd</code>：present workspace direction | 当前的位置</li><li><code>cd</code>：跳转目录<ul><li><code>cd ~</code>：跳转到全局变量 <code>HOME</code> 指向的目录</li><li><code>cd ..</code>：返回上一级</li><li><code>cd test</code>：进入当前目录下的 <code>test</code> 文件夹</li></ul></li><li><code>ls</code>：列出当前目录内的文件和文件夹<ul><li><code>ls -l</code>：将会显示文件和文件夹的详细信息，其中每行前10个字符的形式为 <code>drwxrwxrwx</code> ，第一个字符表示类型：文件夹为 <code>d</code> ，文件为 <code>-</code> ；后面每三个为一组，分别代表 <code>u</code> （作者），<code>g</code> （小组） 和 <code>o</code> （其他）这三类人群的读 <code>r</code> 、写 <code>w</code> 和运行 <code>x</code> 的权限</li></ul></li><li><code>chmod o-rw filename.txt</code> ：去除其他（<code>o</code>）这类人的读（<code>r</code>）写（<code>w</code>）权限</li><li><code>chmod u+x filename.txt</code>：增加作者（<code>u</code>）这类人的运行（<code>x</code>）权限</li></ul><blockquote><p>这里也可以使用二进制更改，如 <code>chmod 444 filename.txt</code> 会使得  <code>filename.txt</code> 文件的权限变为 <code>r--r--r--</code></p></blockquote><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><ul><li><code>cp filename.txt target.txt</code>：将 <code>filename.txt</code> 复制一份并命名为 <code>target.txt</code></li><li><code>mkdir dirname</code>：创建一个名为 <code>dirname</code> 的文件夹</li><li><code>rmdir</code>：删除空文件夹</li><li><code>rm</code>：删除文件（<code>rm -rf dirname</code> 可以实现删除有内容的文件夹，<code>r</code> 代表向下递归，<code>f</code> 代表强制删除）</li></ul><p><span class="label label-danger">Linux没有回收站，需要谨慎使用<code>rm</code> 命令，尤其涉及到 <code>rm -rf</code> </span></p><ul><li><code>touch filename.txt</code>：创建名为 <code>filename.txt</code> 的文件</li><li><code>mv filename.txt tragetname.txt/tragerdir</code> ：将文件重命名为 <code>tragetname.txt</code> 或者把文件移动到 <code>tragetdir</code> 目录下</li><li><code>cat filename.txt</code>：在终端输出 <code>filename.txt</code> 的文件内容</li><li><code>less filename.txt</code>：在终端输出 <code>filename.txt</code> 的文件内容，不过一次加载一面，按 <code>Q</code> 退出</li><li><code>diff filename1.txt filename2.txt</code> ：输出 <code>filename1.txt</code> 和 <code>filename2.txt</code> 中不同的地方</li><li><code>head filename.txt -n 6</code>：查看 <code>filename.txt</code> 文件前 6 行的内容</li><li><code>tail filename.txt -n6</code>：查看 <code>filename.txt</code> 文件后 6 行的内容</li><li><code>wc filename.txt</code>：查看 <code>filename.txt</code> 的行数(<code>-l</code>)、单词书(<code>-w</code>)和字符数(<code>-c</code>)</li><li><code>find</code>：文件查找指令<ul><li><code>find . -name filename.txt -type -d</code>  ：在当前目录下查找名字为 <code>filename.txt</code> 的文件夹（<code>type -f</code> 表示文件）</li><li><code>find / -size +10M</code>：找到所有文件大小大于 10M 的文件</li><li><code>find / -ctime -1</code>：找到所有修改时间在一天内的文件 （可替换为<code>-cmin</code>表示1min之内修改，<code>+1</code> 表示一天/min前修改的文件，<code>c</code> 表示更改、<code>a</code> 表示读）<ul><li><code>-ctime</code>：文件 <code>iNode</code> 信息发生改变</li><li><code>-mtime</code>：文件内容发生改变</li><li><code>-atime</code>：文件查看</li></ul></li><li><code>find . -maxdepth 3 -name filename.txt</code> ：找到当前文件夹下文件层数最多为3文件名称为 <code>filename</code> 的文件</li></ul></li></ul><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ul><li><code>grep Text filename.txt</code>：在 <code>filename.txt</code> 中查找 <code>Text</code> ，会把所有存在的输出（所在的那一行打印）<ul><li><code>grep TT* filename.txt</code> ：首字母是 <code>T</code>，随后跟着0~n个 <code>T</code> 所在的那一行</li><li><code>grep ^Tex filename.txt</code> ：以 <code>Tex</code> 开头的那一行</li><li><code>grep T.xt filename.txt</code>：存在 <code>T</code> <code>任意字母</code> <code>xt</code> 的那一行，如 <code>Text</code> 和 <code>Taxt</code></li><li><code>grep [Tt]ex[A-Za-z] filename.txt</code>：包含首字母是 <code>T</code> 或 <code>t</code> ，中间是 <code>ex</code> ，最后一个是任意字母序列的那一行</li><li><code>grep -n Text filename.txt</code> ：输出行号</li><li><code>-r</code>：递归子路径</li><li><code>-A 2</code>：输出找到的那一行和它下面2行（After）</li><li><code>-B 2</code> ：输出找到的那一行和它上面2行（Before）</li></ul></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><code>date</code>：当前日期时间</li><li><code>cal</code>：当月日历<ul><li><code>cal 2020</code></li><li><code>cal 1 2020</code></li></ul></li><li><code>grep tex filename.txt | wc</code> ：<code>|</code> 表示命令的组合，把 <code>|</code> 前面得出的结果传递给这个符号后面的命令，这个例子的输出是统计 <code>filename.txt</code> 文件里包含 <code>tex</code> 序列的行数、单词书和字符数</li></ul><h1 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h1><ul><li>Linux的脚本文件以 <code>.sh</code>结尾，使用 <code>sh test.sh</code> 运行（当有 <strong>数组</strong> 时，使用 <code>bash test.sh</code> ）</li><li><code>&gt;</code> 和 <code>&lt;</code> ：重定向命令，把输出打到文件或者把文件内容当成输入</li><li><code>a=10</code>：给变量 <code>a</code> 赋值为 10，注意 <code>=</code> 两端不能有空格</li><li><code>$a</code> ：使用变量 <code>a</code> </li><li><code>echo $a Text</code>：输出的命令，相当于 <code>cout &lt;&lt; a &lt;&lt; &quot; Text&quot;;</code> </li><li><code>read a</code> 输入保存到变量 <code>a</code></li><li><p><code>c=&#39;expr $a + $b&#39;</code> ：计算表达式，其中 <code>&#39;</code> 是键盘上 <code>~</code> 对应的飘号，注意运算符两边要有空格</p></li><li><p><code>*,(,)</code>号无法当作乘号，应该在前面加上转义符号 <code>\</code> </p></li><li><p>判断</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -gt <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$a</span><br><span class="hljs-keyword">else</span> <br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$b</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><ul><li>对于数字，用 <code>-gt,-lt,-gq,le,-eq,-ne</code> 表示 $\gt,\lt,\ge,\le,=,\ne$</li><li>对于字符串，可以直接使用 <code>&gt;,=,&lt;</code></li></ul></li><li><p>循环</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> 1..3<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span><br><span class="hljs-keyword">done</span><br>a=10<br><span class="hljs-keyword">while</span> [a -gt 0]<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$a</span><br>a=`expr <span class="hljs-variable">$a</span> - 1`<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure></li><li><p><code>-z a</code> ：判断 <code>a</code> 是否是空，相反，用 <code>-n</code> 可以判断 <code>a</code> 是否不空</p></li><li>数组初始化：<code>array=(1 2 3)</code></li><li>数组元素的使用：<code>echo $&#123;array[2]&#125;</code></li><li>数组的遍历</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-variable">$&#123;array[@]&#125;</span><br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h1 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h1><p>编辑器</p><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left"><code>:w</code></td><td style="text-align:left">保存文件</td></tr><tr><td style="text-align:left"><code>:q</code></td><td style="text-align:left">关闭文件，<code>:wq</code> 表示保存并关闭文件，<code>:q！</code> 表示强制关闭文件</td></tr><tr><td style="text-align:left"><code>j/J</code> <code>k/K</code> <code>h/H</code> <code>l/L</code></td><td style="text-align:left">让光标进行上、下、左、右的移动</td></tr><tr><td style="text-align:left"><code>3gg/GG</code> <code>3j/J</code> <code>3k/K</code></td><td style="text-align:left">让光标移动到第3行、光标向上移动3行、光标向下移动3行</td></tr><tr><td style="text-align:left"><code>/string</code></td><td style="text-align:left">查找字符串 <code>string</code> 文件中的所有该字符串都会高亮显示 <code>n/N</code> 可以让光标定位到下一个 <code>string</code>。 <code>Ctrl+n/N</code> 可以让光标定位到上一个 <code>string</code></td></tr><tr><td style="text-align:left"><code>CC</code> <code>Y</code> <code>P</code> <code>U</code></td><td style="text-align:left">剪切所在行、复制、粘贴、撤销</td></tr><tr><td style="text-align:left"><code>V</code></td><td style="text-align:left">进入 Visual 模式，可以大规模选中</td></tr></tbody></table></div><h1 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h1><p>编译器</p><blockquote><p>官方文档：<a href="https://gcc.gnu.org/onlinedocs/gcc-11.2.0/gcc.pdf">https://gcc.gnu.org/onlinedocs/gcc-11.2.0/gcc.pdf</a></p></blockquote><h2 id="阶段停止的命令"><a href="#阶段停止的命令" class="headerlink" title="阶段停止的命令"></a>阶段停止的命令</h2><pre><code class=" mermaid">graph LRA[hello.cpp] --预处理器-E--&gt; B[hello.i]B --编译器-S--&gt; C[hello.s]C --汇编器-c--&gt; D[hello.o]D --链接器--&gt; E[hello]F[printf.o] --链接器--&gt; E[hello]</code></pre><div class="table-container"><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left"><code>-E</code></td><td style="text-align:left">只运行预编译器，生成修改了的源程序文本文件</td></tr><tr><td style="text-align:left"><code>-S</code></td><td style="text-align:left">只运行到编译器，生成汇编程序（文本文件）</td></tr><tr><td style="text-align:left"><code>-c</code></td><td style="text-align:left">只运行到汇编器，生成二进制的可重定位目标程序</td></tr></tbody></table></div><h2 id="debug相关"><a href="#debug相关" class="headerlink" title="debug相关"></a>debug相关</h2><div class="table-container"><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left"><code>-g</code></td><td style="text-align:left">生成调试信息。GNU 调试器可利用该信息。</td></tr><tr><td style="text-align:left"><code>-Og</code></td><td style="text-align:left">不进行优化处理。</td></tr><tr><td style="text-align:left"><code>-O1</code> <code>-O2</code> <code>-O3</code></td><td style="text-align:left">优化生成代码，数字越大，优化程度越高</td></tr></tbody></table></div><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><h3 id="gcc-命令的常用选项"><a href="#gcc-命令的常用选项" class="headerlink" title="gcc 命令的常用选项"></a>gcc 命令的常用选项</h3><div class="table-container"><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left"><code>-o FILE</code></td><td style="text-align:left">生成指定的输出文件，用在生成可执行文件时</td></tr><tr><td style="text-align:left"><code>-pthread</code></td><td style="text-align:left">用于生成多线程的可执行文件</td></tr></tbody></table></div><h1 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h1><p>调试器</p><h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><p>解决多文件编译输入命令麻烦的问题</p><p>假如有以下文件需要编译成一个可执行程序</p><pre><code class=" mermaid">graph LRmain.cppmain.cpp --&gt; math.cpp --&gt; math.hmain.cpp --&gt; tool.cpp --&gt; tool.h</code></pre><p>用下面的命令可以将这些程序编译为名字为 <code>main</code> 的可执行程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ main.cpp math.cpp tool.cpp -o main<br></code></pre></td></tr></table></figure><p>但是当文件很多时，这样写就很麻烦，这时候就需要 Makefile 了</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile">CC = g++<span class="hljs-comment"># 定义变量</span><br><span class="hljs-section">main: main.cpp math.o tool.o# 从这一句开始一次查找依赖, 发现需要 math.o tool.o</span><br><span class="hljs-variable">$(CC)</span> main.cpp math.o tool.o -o main<br><span class="hljs-section">math.o: math.cpp# 构建 main 需要 math.o, 执行这一步</span><br><span class="hljs-variable">$(CC)</span> -c math.cpp<br><span class="hljs-section">tool.o: tool.cpp# 同上</span><br><span class="hljs-variable">$(CC)</span> -c tool.cpp<br><span class="hljs-section">clear:# 构建 main 不需要执行 clear, 因此不会执行这一步</span><br>rm *.o main<br></code></pre></td></tr></table></figure><p>Makefile文件的名称必须是 <code>Makefile</code> 或 <code>makefile</code> ，编译的时候，在命令行中执行下面的语句就可以了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make<br></code></pre></td></tr></table></figure><p>执行 <code>clear</code> 执行需要在命令行中执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make clear<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2021/06/25/HUST/OperatorSystem/"/>
    <url>/2021/06/25/HUST/OperatorSystem/</url>
    
    <content type="html"><![CDATA[<p>操作系统的笔记和总结，方便日后回顾用</p><span id="more"></span><h1 id="操作系统基础"><a href="#操作系统基础" class="headerlink" title="操作系统基础"></a>操作系统基础</h1><p>操作系统是介于硬件与应用程序之间的一层，它管理着计算机的硬件，让用户更加高效的使用计算机。用户只能通过操作系统的接口来使用硬件。用户既可以通过应用程序间接使用操作系统，也可以直接使用。</p><p>计算机最重要的东西就是CPU和内存，操作系通过进程管理CPU。对于Linux来说，万物都是I/O设备。所有的外部硬件都是通过I/O管理的。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210531094301.png" alt=""></p><p>总的来说，操作系统有两大重要的组成部分，一个是多进程视图，一个是文件视图。多进程视图中主要研究进程管理和内存管理，文件视图主要研究文件管理和IO管理。</p><h2 id="系统启动"><a href="#系统启动" class="headerlink" title="系统启动"></a>系统启动</h2><p>一切从操作系统的启动开始。当电源上电时，硬件电路会初始化PC的值为 <code>0xFFFF0</code> ，内存中这一段地址是 BIOS，负责对程序的硬件进行检测。检测成功后，利用BIOS的输入功能将启动磁盘的启动扇区读入内存，将 PC 的值设置为 <code>0x7C00</code>，这一段是 <code>bootsects.s</code>（此时还不算是操作系统的启动）</p><blockquote><p>PC：CPU中的程序计数器</p></blockquote><p>当PC进入到 <code>bootsect.s</code> 中时，操作系统开始启动。<code>bootsect.s</code> 的作用是将启动的另一段程序 <code>setup.s</code> 读入内存、向显示器显示LOGO和正在启动信息、将操作系统内容读入内存。随后，PC将进入 <code>setup.s</code></p><p><code>setup.s</code> 的主要作用是读取硬件信息，并将操作系统从 16 位的实模式切换位 64 位的保护模式。从此之后，操作系统将以64位的模式进行工作。切换之后，PC将跳转到 <code>head.s</code> 文件</p><blockquote><p>保护模式的PC的译码方式改变了。保护模式的PC查询 GDT 表，间接得到要访问的地址。</p><blockquote><p>GDT：global decriptor table 全局描述表</p></blockquote></blockquote><p><code>head.s</code> 的主要作用就是初始化 IDT表和 GDT表和页表。<code>head.s</code> 运行完毕后，PC将跳转到 <code>0x0</code> 地址处，也就是操作系统的函数 <code>main.c</code>。</p><blockquote><p>IDT：interrupt decriptor table 中断描述表。</p><p>页表：主要作用是内存管理</p><p><code>setup.s</code> 为了在保护模式下能跳转到 <code>head.s</code> 也进行了 IDT 和 GDT 表的初始化，不过 <code>head.s</code> 中的是临时建立的， <code>head.s</code> 是正式建立</p></blockquote><p><code>main.c</code> 负责初始化一些硬件表，初始化其他重要的数据结构，创建进程，启动 Shell</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20210531104930510.png" alt=""></p><h2 id="系统接口"><a href="#系统接口" class="headerlink" title="系统接口"></a>系统接口</h2><p>为了保证系统内核的安全，应用程序是直接对硬件进行操作的，要想使用计算机硬件，只能通过操作系统的接口。这些接口函数由操作系统提供，同时又以函数的形式调用，因此称为<strong>系统调用</strong>。</p><blockquote><p>系统调用连接了计算机硬件和应用程序</p><p>系统调用由 IEEE 指定的 <strong>POSIX 标准</strong>定义，常见的系统调用有 fork(), open(), read(), write() 等</p></blockquote><p>为了实现这一目标，操作系统将内存设置了不同的权限（特权级），CPU在运行的时候通过硬件电路来检测特权级。CPU读取当前特权级（CPL）和目标特权级（DPL），将其比较，当 CPL &lt;= DPL 时执行。</p><blockquote><p>通过硬件电路是为了提高效率</p><p>特权级从小到大，权限越来越低。0是内核态，3是用户态。系统内核的 DPL 是0，CPU在运行用户代码是 CPL被设为 3 。因此无法直接访问内存地址。</p><p>CPL在CPU寄存器存放，DPL是 GDT 表中存放的数据</p></blockquote><p>应用程序要访问内核态的数据就需要依赖于系统调用了。操作系统给应用程序留了一个 <code>0x80</code> 号中断作为应用程序进入操作系统的入口。以 C 语言的 <code>printf</code> 函数为例。<code>printf</code> 里面就有一段内联汇编，里面涉及到 <code>0x80</code> 中断，同时传入系统调用号来区别不同的系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *buf, <span class="hljs-keyword">off_t</span> count)</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> __res;<br>    __asm__volatile(<span class="hljs-string">&quot;int 0x80&quot;</span> : <span class="hljs-string">&quot;=a&quot;</span>(__res) : <span class="hljs-string">&quot;&quot;</span>(__NR_write)), <span class="hljs-string">&quot;b&quot;</span>((<span class="hljs-keyword">long</span>)(fd)), <span class="hljs-string">&quot;c&quot;</span>((<span class="hljs-keyword">long</span>)(buf)), <span class="hljs-string">&quot;c&quot;</span>((<span class="hljs-keyword">long</span>)(count));<br>    <span class="hljs-comment">// __NR_write 就是系统调用号，&quot;b&quot;((long)(fd))表示将 fd 赋值给 %ebx</span><br>    <span class="hljs-comment">// 核心就是使用 int 0x80 中断，然后将系统调用号传入</span><br>&#125;<br></code></pre></td></tr></table></figure><p>操作系统收到 <code>int 0x80</code> 后进行中断处理，根据系统调用号查询 IDT 表，跳转到相应的中断处理函数执行操作。跳转到中断处理函数后，CPL = 0，就可以进行对系统内核和硬件的操作了。总的来说就是一下步骤：</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20210531113501809.png" alt=""></p><h2 id="系统调用Linux命令"><a href="#系统调用Linux命令" class="headerlink" title="系统调用Linux命令"></a>系统调用Linux命令</h2><p><code>strace</code>：查看进程调用了哪些系统调用</p><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><p>进程管理其实就是对计算机CPU的管理。CPU的工作流程就是不断的取址执行、取址执行，给CPU一个初始地址就可以让它工作了</p><p>这样效率很低，一旦某个程序在进行I/O操作，CPU就必须等待硬件的读写完成。为了提高效率，有必要让CPU在不同的程序之间切换，多个程序同时出发，交替运行。在切换时要记录当前程序的相关信息以便切换回来能够恢复上下文，保存的这个数据结构就是 <strong>PCB（程序控制块）</strong>。这种在运行的程序就叫做 <strong>进程</strong></p><blockquote><p>进程于程序的主要区别就是一个在运行，内存中有PCB，一个没有在运行</p></blockquote><h2 id="多进程视图"><a href="#多进程视图" class="headerlink" title="多进程视图"></a>多进程视图</h2><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210602205247.png" alt=""></p><h3 id="多进程的组织"><a href="#多进程的组织" class="headerlink" title="多进程的组织"></a>多进程的组织</h3><p>一个进程会有不同的状态，操作系统是通过状态队列来管理多个进程的</p><p>进程主要有3种状态：就绪态、运行态、阻塞态</p><p>操作系统对每个状态有一个队列，队列中存放的就是一个个进程</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">运行态  :  [<span class="hljs-attribute">PID</span>=1,PC=...]<br>就绪态队列:[<span class="hljs-attribute">PID</span>=2,PC=...], [<span class="hljs-attribute">PID</span>=4,PC=...]<br>阻塞态队列:[<span class="hljs-attribute">PID</span>=3,PC=...], [<span class="hljs-attribute">PID</span>=5,PC=...]<br></code></pre></td></tr></table></figure><p>根据发生的事件，各个程序在不同的状态中进行切换</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210602211326.png" alt=""></p><ul><li>运行态到就绪态的切换：当一个进程运行了很多时间，超过了操作系统给它分配的时间片后，这个进程将会被剥夺CPU，进入运行态</li><li>就绪态到运行态的切换：当CPU出现空闲，比如刚刚一个进程的CPU被剥夺，就会调用调度算法，在就绪态中找到一个进程，然后把这个进程变为运行态。</li><li>运行态到阻塞态的切换：当一个进程遇到例如IO操作这种操作，它就必须等待IO执行完毕才能执行下一条指令，此时CPU就空出，这个进程就从运行态变成了阻塞态</li><li>阻塞态到就绪态的切换：当IO操作执行完毕之后，设备将会给CPU发送一个中断信号。CPU收到中断信号之后查中断表，执行对应的中断处理函数，操作系统在中断处理函数中将唤醒阻塞态中对应的进程，这个进程就进入了就绪态。</li></ul><h3 id="进程间切换"><a href="#进程间切换" class="headerlink" title="进程间切换"></a>进程间切换</h3><p>本文底下 <strong>用户级线程</strong> 和 <strong>核心级线程</strong> 有更深的介绍</p><h3 id="进程间分离"><a href="#进程间分离" class="headerlink" title="进程间分离"></a>进程间分离</h3><p>如果进程A要读取内存中的一段数据，进程B修改了这个数据，那么进程A就会得到错误的结果</p><p>为了防止这种事情的发生，操作系统进行了<strong>内存映射</strong>，在运行的时候查 GDT 表来实现地址的分离</p><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>最基本的模式就是两个进程在一块共享缓存区中读写</p><p>此时，如果一个进程还没执行完，就执行另外一个，此时就会出现错误</p><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">process1:<br><span class="hljs-keyword">void</span> A &#123; a = file.<span class="hljs-built_in">read</span>(); a += <span class="hljs-number">3</span>; file.<span class="hljs-built_in">write</span>(a); &#125;<br>⬆ PC在此次跳转到process2，a就会发生错误<br>process2:<br><span class="hljs-keyword">void</span> B &#123; b = file.<span class="hljs-built_in">read</span>(); b *= <span class="hljs-number">2</span>; file.<span class="hljs-built_in">write</span>(b); &#125;<br></code></pre></td></tr></table></figure></blockquote><p>解决方法就是在执行 process1 的时候一次性执行完全。或者说设置共享缓冲区的控制权，让 process2 无法操作文件</p><p>本文底下 <strong>进程同步</strong> 有深入的介绍</p><h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><p>进程的切换包括两个部分，一个是指令流的切换，一个是资源的切换。而指令流刚好是CPU的切换，也是线程的切换。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是同一个程序中的并行。这个程序的代码间共享的资源非常多，但是又有子程序交替执行的特点，就有了多线程的概念。</p><blockquote><p>例如一个浏览器，既要通过网络下载，又要在客户端显示。一个比较好的实现方法就是网络下载和客户端显示同时开始，交替进行（两个线程并行）。这就需要支持多线程。</p></blockquote><p>为了能恢复线程的上下文，线程也有一个记录 CPU 寄存器信息等资源的内容，成为 TCB（线程控制块）</p><blockquote><p>不过由于资源的切换少，线程的切换比进程快很多。</p></blockquote><p>线程有两类：用户级线程和内核级线程。用户级线程是应用程序自己实现多线程，在操作系统眼里还是单线程。而核心级线程是深入操作系统中，操作系统会分配相应的硬件资源。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210603203318.png" alt=""></p><blockquote><p>MMU 是 CPU 中的共享储存管理部件（Memory Management unit）。进程切换不仅需要切换 PC 指针，还需要切换 MMU，而线程切换不需要切换 MMU</p><p>进程的切换就是在内核级线程的切换 + 映射表等资源的切换</p></blockquote><h3 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h3><p>多个线程共用一个栈时，跳转时要进行压栈存放下一步的 PC 值，这时多个线程的 PC 值就混在一起了。因此，一个线程对应一个栈</p><blockquote><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">Thread1:</span><br><span class="hljs-class">A </span>&#123; B(); ... &#125;<br><span class="hljs-class">B </span>&#123; Yield(Thread2); ... &#125;<br><span class="hljs-symbol">Thread2:</span><br><span class="hljs-class">C </span>&#123; D(); ... &#125;<br><span class="hljs-class">D </span>&#123; Yield(Thread1); ... &#125;<br><span class="hljs-symbol">Stack:</span> [ A B C D<br></code></pre></td></tr></table></figure><p>Thread2 跳转回 Thread1 后，理想状态下将返回到 B，但是此时栈底是 D，将跳转到 D</p></blockquote><p>用户级线程的核心是<strong>一个线程一个栈</strong> 以及 <strong>Yield()</strong></p><p>应用程序想要切换时，调用 <code>Yield()</code> 函数即可。<code>Yield()</code> 会将当前栈指针 <code>%rsp</code> 和其他寄存器保存在 TCB 中，然后找到下一个线程的 TCB，然后取出新 TCB 中的 <code>%rsp</code> 完成栈的切换，并恢复上下文。</p><p><strong>用户级线程的创建</strong> 就是在内存中分配一块地址给线程的栈和TCB，并初始化</p><blockquote><p>用户级线程不是函数调用，在操作系统无多线程的时候有用，不过用户级线程无法处理一个线程堵塞导致其他线程卡死的现象。这种需要核心级线程解决</p></blockquote><h3 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h3><p>核心级线程需要由于涉及到操作系统，因此需要通过中断 <code>int 0x80</code> 进入操作系统内核，通过中断返回 <code>iret</code> 从操作系统返回到用户态代码。</p><p>如果一个线程继续使用一个栈，这个栈中可能存放着一些危险代码，内核在执行时会以内核态的特权级执行，因此不安全，需要将栈分为用户态的栈和内核态的栈。内核态的栈中存放着用户栈的首尾地址和中断进入内核前的 PC 值，以便能够回到原来的地方继续执行，同时内核栈中还存放在中断返回代码的地址。</p><p>内核级线程的切换包括代码的切换（PC指针的切换）、TCB的切换、用户栈的切换和内核栈的切换。PC指针压在栈中，切换的时候弹栈赋值；栈的切换主要是 <code>%rsp</code> 的变化。有5个步骤</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210603222854.png" alt=""></p><ol><li><p>进入操作系统核心。应用进程通过中断来到操作系统核心，将用户栈的首尾位置、PC指针位置等信息压入内核栈。执行中断处理函数。</p><blockquote><p>用户代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov %eax, __NR_fork<br>INT 0x80#进入系统内核<br>mov res, %eax<br></code></pre></td></tr></table></figure><p>接下来操作系统就会执行系统调用的函数 <code>system_call</code></p></blockquote></li><li><p>调用 <code>schedule()</code> ，找到下一个执行的线程的 TCB。找到下一个进程的过程在后面进程调度中会介绍</p><blockquote><p>系统调用：<code>system_cal</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push %ds ... # 将CPU寄存器记录到内核栈中<br>call sys_fork<br>push %eax<br>...<br>cmpl $0 counter(%eax)# 判断是否阻塞或超时<br>je schedule()# 如果阻塞或超时就切换<br>ret_from_sys_call:<br></code></pre></td></tr></table></figure><blockquote><p><code>sys_fork</code> 在后面内核级线程的创建会介绍</p></blockquote></blockquote></li><li><p>进行内核栈的切换。根据 TCB 的信息完成内核栈的切换</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">schedule:<br>next = ...;<br>call switch_to(next);<br>switch_to:<br>TCB[curr].esp = %esp;<br>%esp = TCB[next].esp;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>中断返回。从内核态重新返回为用户态。</p><blockquote><p>系统调用：<code>system_cal</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ret_from_sys_call:<br>popl %eax ...# 将用户态还原<br>iret# 中断返回<br></code></pre></td></tr></table></figure></blockquote></li><li><p>进行用户栈的切换。根据中断返回将PC设置为内存栈中的PC，还原之前压入栈的寄存器。</p></li></ol><p><strong>内核级线程的创建</strong> 的关键是为TCB和内存栈申请内存，初始化TCB、内核栈、完成和用户栈的绑定</p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>应用程序有着不同的性质，一类对反馈性要求高，即希望CPU的切换时间短；另外一类对任务的周转时间要求高，就是希望任务能够尽快做完，即希望CPU给出充足的时间让它一次性做完。</p><p>操作系统的进程调用要尽量满足两种应用的需求。</p><p>常见的调度方法有以下一些部分</p><ul><li>FCFS：先到先服务</li><li>SJF：短作业优先</li><li>RR：时间片轮转</li><li>多极队列调度<ul><li>前台队列 RR</li><li>后台队列 SJF</li></ul></li></ul><p>在实际的操作系统中，使用的是 <strong>多极反馈队列调度</strong>。动态根据应用运行时间和等待时间调节进程的优先级</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">schedule</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        foreach(task : taskqueue) &#123;<br>            <span class="hljs-keyword">if</span>(task.state == TASK_RUNNING &amp;&amp; task.counter &gt; c) &#123; <br>                next = task; c = task.counter; <br>            &#125; <br>        &#125;<span class="hljs-comment">// 在运行队列中找到最大count最大的那个</span><br>        <span class="hljs-keyword">if</span>(next.counter == <span class="hljs-number">0</span>) &#123;<br>            foreach(task : taskqueue) &#123;<br>                <span class="hljs-comment">// 增加时间，使得从就绪态到运行态的新进程和等的久的进程先执行</span><br>                task.counter = (task.counter &gt;&gt; <span class="hljs-number">1</span>) + task.priority;<br>            &#125;<span class="hljs-comment">// 所有进程</span><br>        &#125;<span class="hljs-comment">// 运行队列的时间片清零了</span><br>        <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">break</span>; &#125;<span class="hljs-comment">// 这个进程的时间片还有剩余时间</span><br>    &#125;<br>    <span class="hljs-built_in">switch_to</span>(next);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>两个进程之间会存在合作依赖关系（例如消费者-生产者模型，生产者生产后消费者才能消费）。进程同步使得多个进程之间的合作合理有序，实现了两个进程之间的依赖关系。</p><p>操作系统是通过：一个进程在需要同步的时候停下，等待依赖进程。当依赖进程执行完毕后，该进行继续执行的办法实现进程同步。</p><blockquote><p>通过对进程走走停停，来让多个进程步调一致，合理有序的推进，实现进程同步</p></blockquote><p>应用进程在需要同步的地方将自己阻塞，等待信号；当各个进程协调一致了，就会发射一个信号给操作系统。操作系统收到信号后，会将进程唤醒。</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量就是告诉应用进程在什么时候停，在什么时候走的一个信号。应用进程通过信号量的值来执行等待或唤醒操作。信号量的结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore</span> &#123;</span><br>    <span class="hljs-keyword">int</span> value;<span class="hljs-comment">// 信号的量</span><br>    PCB *<span class="hljs-built_in">queue</span>;<span class="hljs-comment">// 等待在该信号量上的进程队列</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">P</span><span class="hljs-params">(semaphore s)</span> </span>&#123;<br>    --s.value;<br>    <span class="hljs-keyword">if</span>(s.value &lt; <span class="hljs-number">0</span>) &#123; sleep(s.<span class="hljs-built_in">queue</span>); &#125;<br>&#125;<span class="hljs-comment">// 使用资源的进程通过该函数判断是否等待</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">V</span><span class="hljs-params">(semaphore s)</span> </span>&#123;<br>    ++s.value;<br>    <span class="hljs-keyword">if</span>(s.value &lt;= <span class="hljs-number">0</span>) &#123; wake_up(s.<span class="hljs-built_in">queue</span>); &#125;<br>&#125;<span class="hljs-comment">// 生产资源的进程通过该函数唤醒对应进程</span><br></code></pre></td></tr></table></figure><blockquote><p>其中，<code>s.value</code> 表示剩余资源的数量。消费者调用 <code>P(s)</code> 时，<code>value &lt; 0</code> 说明生产者生产的资源不够，消费者需要等待；生产者调用 <code>V(s)</code> 时，<code>value &lt;= 0</code> 说明有 <code>1 - value</code> 个进行正在等待，而此时生产了一个资源，需要唤醒一个进程消耗。</p></blockquote><p>生产者-消费者模型是信号量的一个很好的应用</p><blockquote><p>OS：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">&gt;semaphore full = <span class="hljs-number">0</span>;<span class="hljs-comment">// 占用缓冲区</span><br>&gt;semaphore empty = BUFFER_SIZE;<span class="hljs-comment">// 空闲缓冲区</span><br>&gt;semaphore entry = <span class="hljs-number">1</span>;<span class="hljs-comment">// 是否进行读写了</span><br></code></pre></td></tr></table></figure><p>生产者：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">&gt;<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>   <span class="hljs-built_in">P</span>(empty);<span class="hljs-comment">// 判读是否有空闲缓冲区资源</span><br>   <span class="hljs-built_in">P</span>(entry);<span class="hljs-comment">// 判断是否其他进程正在使用缓冲区</span><br>   buffer[i] = item; i = (i + <span class="hljs-number">1</span>) % BUFFER_SIZE;<span class="hljs-comment">// 写内容</span><br>   <span class="hljs-built_in">V</span>(entry);<br>   <span class="hljs-built_in">V</span>(full);<span class="hljs-comment">// 生产后占用了的缓冲区会增加，空闲缓冲区减少</span><br>&gt;&#125;<br></code></pre></td></tr></table></figure><p>消费者：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">&gt;<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>   P(full);<span class="hljs-comment">// 判断缓冲区是否为空</span><br>   P(entry);<span class="hljs-comment">// 判断是否其他进程正在使用缓冲区</span><br>   item = buffer[o]; o = (o + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br>   V(entry);<br>   V(empty);<span class="hljs-comment">// 生产后空闲缓冲区会增加，占用了的缓冲区会减少</span><br>&gt;&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="信号量的保护"><a href="#信号量的保护" class="headerlink" title="信号量的保护"></a>信号量的保护</h4><p>信号量的语义必须是正确的，进程的交互才能继续完成。而对信号量的修改实在两条语句中，可能会被 CPU切换掉，导致信号量表示的信息与实际情况不一样。</p><p>操作系统的解决方案就是在更改信号量的地方设置临界区保护区</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">... (进入区代码)<br>++s.value;<br>... (退出区代码)<br></code></pre></td></tr></table></figure><p>使得一次只有一个进程进入临界区。</p><p>有三种解决方式</p><ul><li><p>软件解决：面包店算法：轮换 + 标记</p><ul><li><p>轮换：每个进程一个序号，序号最小的进入</p></li><li><p>标记：进程离开是序号为0，不为0的序号为标记</p></li></ul></li><li><p>硬件解决</p><ul><li>开关中断法：在进入临界区后关掉CPU中断，不让指令切换，只适合单CPU</li><li>硬件原子指令法：把进入区代码用硬件实现，只需一条指令即可完成所有工作，不会发生在临界区切换指令的行为</li></ul></li></ul><blockquote><p>面包片算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    choosing[i] = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 对 number[i]的保护</span><br>    number[i] = <span class="hljs-built_in">max</span>(number.<span class="hljs-built_in">begin</span>(), number.<span class="hljs-built_in">end</span>()) + <span class="hljs-number">1</span>;<span class="hljs-comment">// 序号小（先申请）的进程先执行</span><br>    choosing[i] = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; number.<span class="hljs-built_in">size</span>(); ++j) &#123;<br>        <span class="hljs-keyword">while</span>(choosing[j]) &#123; ; &#125;<span class="hljs-comment">// 其他进程在未给number赋初值时就切出了</span><br>        <span class="hljs-keyword">while</span>(number[j] != <span class="hljs-number">0</span> &amp;&amp; number[j] &lt; number[i]) &#123; ; &#125;<span class="hljs-comment">// 有序号小的进程在队列中</span><br>    &#125;<br>    ...<span class="hljs-comment">// 临界区代码</span><br>    number[i] = <span class="hljs-number">0</span>;<span class="hljs-comment">// 表示修改信号量执行完毕</span><br>&#125;<br></code></pre></td></tr></table></figure><p>临界区的代码需要满足<strong>互斥进入</strong>、<strong>有空让进</strong>和<strong>有限等待</strong>的要求</p></blockquote><h4 id="信号量的实现"><a href="#信号量的实现" class="headerlink" title="信号量的实现"></a>信号量的实现</h4><p>在实际的操作系统中(Linux 0.11)，信号量的定义和上文所说的有所不同</p><p>上文用正负代表进程是否需要阻塞 / 唤醒。而在操作系统中，用 1 代表阻塞，用 0 代表唤醒</p><p>在唤醒时，一次性唤醒所有的进程，在阻塞时，将信号量置为 1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sleep_on</span>(PCB *queue)&#123;<br>    PCB temp = *queue; *queue = current;<span class="hljs-comment">// 将当前PCB添加到信号量进程队列的队首</span><br>    current.state = TASK_BLOCK;<span class="hljs-comment">// 将当前PCB状态设置为阻塞</span><br>    <span class="hljs-built_in">schedule</span>();<span class="hljs-comment">// 通过调度切换到下一个进程（有优先级）</span><br>    <span class="hljs-keyword">if</span>(temp) &#123;<br>        temp.state = TASK_RUN;<span class="hljs-comment">// 信号量进程队列的下一个进程设为就绪态</span><br>    &#125;<br>&#125;<br><span class="hljs-built_in">wake_up</span>(PCB *queue) &#123;<br>    <span class="hljs-keyword">if</span>(queue &amp; queue.<span class="hljs-built_in">first</span>()) &#123; queue.<span class="hljs-built_in">first</span>().state = <span class="hljs-number">0</span>; &#125;<br>&#125;<br><span class="hljs-built_in">P</span>(semaphore s)&#123;<br>    <span class="hljs-built_in">cli</span>();<span class="hljs-comment">// 进入区</span><br>    <span class="hljs-keyword">while</span>(s.value &amp;&amp; s.queue) &#123; <span class="hljs-built_in">sleep_on</span>(s.queue); &#125;<span class="hljs-comment">// s = 1, 阻塞所有请求的进程</span><br>    s.value = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">sti</span>();<span class="hljs-comment">// 离开区</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>操作系统的实现方式将进程的切换用调度函数实现，考虑了优先级因素。</p></blockquote><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>信号的话是异常控制流中的一种，一般用来结束（<code>kill</code>）进程。通过 <code>kill -l</code> 命令可以查看所有的信号。</p><h4 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h4><p>通过 <code>kill &lt;PID&gt;</code> 可以发送 <code>SIGTEM</code> 信号，通过 <code>Ctrl+C</code> 可以发送 <code>SIGINT</code> 信号，<code>C++</code> 中还提供了 <code>kill()</code> 函数来发送信号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;csignal&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;[SendError]: Inpur Error!&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 发射信号的函数，第一个参数是PID，第二个是信号</span><br>        <span class="hljs-built_in">kill</span>(std::<span class="hljs-built_in">stoi</span>(argv[<span class="hljs-number">1</span>]), SIGINT);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[Send]: Send SIGINT to PID:&quot;</span> &lt;&lt; argv[<span class="hljs-number">1</span>] &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="接收信号"><a href="#接收信号" class="headerlink" title="接收信号"></a>接收信号</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;csignal&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> signal_number)</span> </span>&#123; <span class="hljs-comment">// 信号处理函数</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[Recive]: Caught SIGNAL &quot;</span> &lt;&lt; signal_number &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 注册信号处理函数</span><br>    <span class="hljs-keyword">if</span>(std::<span class="hljs-built_in">signal</span>(SIGINT, handler) == SIG_ERR) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[ReciveError]&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;&#125;<span class="hljs-comment">// 用来暂停</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道就是把一个进程的输出当作另外一个进程的输入</p><h4 id="匿名管道（PIPE）"><a href="#匿名管道（PIPE）" class="headerlink" title="匿名管道（PIPE）"></a>匿名管道（PIPE）</h4><p>匿名管道就是 <code>cat test.cpp | grep include</code> </p><p>在 C++ 中，可以通过</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pipe</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pipefd[<span class="hljs-number">2</span>])</span></span>; <br><span class="hljs-comment">// 管道两端用fd[0]和fd[1]来描述，读的一端用fd[0]表示，写的一端用fd[1]表示。</span><br></code></pre></td></tr></table></figure><p>创建匿名管道。父子进程中，一个进程通过写文件的方式操作管道，另外一个进程通过读文件的方式操作管道</p><p>匿名管道是在父子进程之间使用的。父进程在创造子进程前打开管道文件，然后产生子进程。此时子进程拷贝父进程的虚拟地址空间，父子进程在此时虚拟地址空间的映射的文件相同，能够访问这个管道文件。</p><p>这个管道只能在父子进程间使用，其他进程无法访问管道文件</p><h4 id="有名管道（FIFO）"><a href="#有名管道（FIFO）" class="headerlink" title="有名管道（FIFO）"></a>有名管道（FIFO）</h4><p>通过 <code>mkfifo &lt;fifo_name&gt;</code> 命令可以创建有名管道</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mkfifo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">mode_t</span> mode)</span></span>;<br><span class="hljs-comment">// pathname：即将创建的FIFO文件路径，如果文件存在需要先删除。</span><br><span class="hljs-comment">// mode：和open()中的参数相同。</span><br></code></pre></td></tr></table></figure><p>有名管道是一个文件，文件类型为 <code>p</code> ，此时这个文件相当于有了一个全局的名称，任何不想管的进程都可以进行访问。</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列是由操作系统维护的以字节流为基本单位的一种进程通信机制。</p><p>相比于 FIFO，消息队列具有以下优点：</p><ul><li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li><li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li><li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li></ul><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>让多个进程的虚拟地址映射到同一个物理内存的地址，在多进程程序中，应该显示的使用</p><h3 id="进程通讯机制-IPC-系统调用"><a href="#进程通讯机制-IPC-系统调用" class="headerlink" title="进程通讯机制(IPC)系统调用"></a>进程通讯机制(IPC)系统调用</h3><div class="table-container"><table><thead><tr><th style="text-align:center">文件I/O</th><th style="text-align:center">IPC</th></tr></thead><tbody><tr><td style="text-align:center"><code>open()</code></td><td style="text-align:center"><code>msgget()</code>、<code>shmget()</code>、<code>semget()</code></td></tr><tr><td style="text-align:center"><code>read(),write()</code></td><td style="text-align:center"><code>msgsnd(), msgrcv()</code>、<code>shmat(), shmdt()</code>、<code>semop()</code></td></tr><tr><td style="text-align:center"><code>close()</code></td><td style="text-align:center"><code>msgctl()</code>、<code>shmctl()</code>、<code>semctl()</code></td></tr></tbody></table></div><h2 id="死锁现象"><a href="#死锁现象" class="headerlink" title="死锁现象"></a>死锁现象</h2><p>当进程 $P_0$ 在某个时刻需要停下来等 $P_1$ 进程，而 $P_1$ 进程又需要停下来等待 $P_0$ 进程，这时候这两个进程都会因为在等待对方而停下来。两个进程因为进程同步而相互等待，无法继续执行的现象就叫做 <strong>死锁现象</strong></p><p>解决死锁问题的方式有四种</p><ul><li><strong>死锁预防</strong>：就是限制死锁发生的条件</li><li><strong>死锁避免</strong>：检测资源的请求，如果造成死锁则拒绝</li><li><strong>死锁检测/恢复</strong>：每隔一段时间检测死锁发生与否，发生了则恢复</li><li><strong>死锁忽略</strong>：不处理</li></ul><h4 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h4><ul><li><strong>资源互斥</strong>：资源不等被共享，1 个资源只能 1 个进程用</li><li><strong>不可剥夺</strong>：进程已经获得的资源，只能由这个进程释放</li><li><strong>占有等待</strong>：已经得到了某个资源的进程可以再请求新的资源</li><li><strong>循环等待</strong>：若干进程形成首尾相接的环状请求等待链</li></ul><h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><ul><li><p>一次性请求所有资源（破环请求保持条件）：应用进程一次性请求所有可能需遇到的资源，之后就不存在请求资源等待其他进程了，这次请求由于没有占用任何资源，也不会造成死锁现象</p><blockquote><p>资源的利用率低；而且应用程序需要对未来的需求有判断，编程比较困难</p></blockquote></li><li><p>资源按顺序申请（破坏循环等待条件）：这样就不会形成环路了</p><blockquote><p>造成资源的浪费</p></blockquote></li></ul><h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><p><strong>银行家算法</strong> 实现，通过判断是否存在一条可以执行下去的序列，进而判断这条请求是否造成死锁。如果存在一条序列，系统就处于 <strong>安全状态</strong> </p><p>操作系统会设置一个表，记录各个进程占有的资源、请求需要的资源和目前可以分配的资源</p><blockquote><p>当目前操作系统有可分配的资源 $A:1,B:5,C:2,D:0$ 个时，当前的所有请求如下</p><div class="table-container"><table><thead><tr><th style="text-align:center">进程</th><th style="text-align:center">占有资源</th><th style="text-align:center">请求资源</th><th style="text-align:center">请求后可分配资源</th><th style="text-align:center">执行顺序</th></tr></thead><tbody><tr><td style="text-align:center">$P_0$</td><td style="text-align:center">$A:0,B:0,C:1,D:4$</td><td style="text-align:center">$A:0,B:6,C:5,D:6$</td><td style="text-align:center">$A:2,B:8,C:8,D:8$</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">$P_1$</td><td style="text-align:center">$A:1,B:4,C:3,D:2$</td><td style="text-align:center">$A:1,B:9,C:4,D:2$</td><td style="text-align:center"></td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">$P_2$</td><td style="text-align:center">$A:1,B:3,C:5,D:4$</td><td style="text-align:center">$A:1,B:3,C:5,D:6$</td><td style="text-align:center">$A:2,B:8,C:7,D:4$</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">$P_3$</td><td style="text-align:center">$A:1,B:0,C:0,D:0$</td><td style="text-align:center">$A:1,B:7,C:5,D:0$</td><td style="text-align:center">$A:3,B:8,C:8,D:8$</td><td style="text-align:center">3</td></tr></tbody></table></div></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">Available</span><span class="hljs-params">(m)</span></span>;<span class="hljs-comment">// m类资源对应可分配的资源数</span><br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">Need</span>(n, <span class="hljs-built_in">vector</span>(m));<span class="hljs-comment">// n个进程各自请求的资源数</span><br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">Allocation</span>(n, <span class="hljs-built_in">vector</span>(m));<span class="hljs-comment">// n个进程各自占有的资源数</span><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">isFinish</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>;<span class="hljs-comment">// 进程是否结束</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">bool</span> isVaild = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(isFinish[i] == <span class="hljs-literal">false</span>) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123; <br>                <span class="hljs-keyword">if</span>(Need[i][j] &gt; Available[j]) &#123; <span class="hljs-keyword">bool</span> = <span class="hljs-literal">false</span>; <span class="hljs-keyword">break</span>; &#125; &#125;<br>            <span class="hljs-keyword">if</span>(isVaild) &#123;<br>               <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123; Available[j] += Allocation[i][j]; &#125;<br>                isFinish[i] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123; <span class="hljs-built_in"><span class="hljs-keyword">throw</span></span>(); &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>请求出现时，先假装分配，任何调用银行家算法</p><h4 id="死锁检测-恢复"><a href="#死锁检测-恢复" class="headerlink" title="死锁检测/恢复"></a>死锁检测/恢复</h4><p>定时检测或发现资源利用率低的时候检测。检测的算法和 银行家 算法一样</p><h4 id="死锁忽略"><a href="#死锁忽略" class="headerlink" title="死锁忽略"></a>死锁忽略</h4><p>一般 PC 机都使用 死锁忽略，因为</p><ul><li>死锁忽略处理代价小</li><li>死锁影响小，重启就可以解决</li><li>死锁预防让编程困难</li></ul><h2 id="进程管理Linux命令"><a href="#进程管理Linux命令" class="headerlink" title="进程管理Linux命令"></a>进程管理Linux命令</h2><ul><li><code>PS</code>：参看进程信息</li><li><code>TOP</code>：类似于任务管理器，和 <code>PS</code> 差不多作用</li></ul><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>内存管理的核心就是要让程序存入内存中。</p><p>程序编译的时候，都是从0地址开始。而程序在运行时，肯会用到物理内存中的任意一处。因此，当程序变为进程的时候，就需要进行重定位。将编译器中的地址转换为实际的物理地址。</p><p>在编译和载入时重定位都存在自己的问题，因此在运行时重定位。（指令执行的时候把逻辑地址转换为物理地址）。这时候进程中的物理地址就相当于是 <strong>基址 + 偏移量</strong>，进程第一句地址就是 <strong>基址</strong> ，程序里的逻辑地址就相当于是 <strong>偏移量</strong> 。在CPU中，MMU负责内存地址的转换。</p><blockquote><p>重定位就指的是把逻辑地址转换为物理地址的过程</p></blockquote><p>这样在切换进程的时候，除了切换用户态栈、内核态栈、PC指针、PCB外，还需要切换基址寄存器来实现内存的切换。</p><h2 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h2><p>分段是因为在程序中，有些数据是常数，有些数据是代码，有些数据是变量。这些数据具有不同的属性，把不同属性的数据分开存放比较好。因此有了分段的概念</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210617221554.png" alt=""></p><p>分段后一个基址就表示不了所有的数据，这时候，引入<strong>LDT（局部描述符表）</strong>。进行地址转换的时候就通过段号查询 LDT 表获取基址，然后通过 基址+ 偏移 来获得最终的地址。切换进程的时候，除了换掉进程管理的那些，还需要换掉 CPU 的 LDTR 寄存器。</p><blockquote><p>例如常数和代码就是只读的，变量就是可读可写的</p></blockquote><h2 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h2><p>进程执行前需要载入内存中，执行完之后要从内存中释放掉，而不同的进程占用的内存大小不同，因此就会有碎片。</p><p>当给一个进程分配新的内存时，有不同的分配方法：最差适配、最佳适配和最先适配。然而这些分配方法都只适用于特殊情况，因此引入了分页。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>将所有内存离散化，划分为一片一片固定大小的内存，应用程序使用时就给它完整的片，释放也是释放完整的片。这样就没有内存碎片的问题了，每个进程最多浪费其中一页。</p><p>为了能够还原出原来的程序，需要 <strong>页表</strong> 来记录这个进程每一页对应的物理地址。由于每一页都是固定的大小，因此根据偏移量可以计算出代码对应的页号，根据页号查询页表，找到对应的物理地址即可。</p><h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>页划分太细的话页表占据的空间就会很大。</p><p>采用多级页表。页表被分为两级，一个是页目录表，一个是页表。页目标中某一项完全没有使用，就不需要建立它的页表，这样就节省了空间</p><h3 id="时间优化"><a href="#时间优化" class="headerlink" title="时间优化"></a>时间优化</h3><p>采用快表。</p><p>把最近使用的页号和物理地址的对应关系用硬件记录下来，这样就节省了时间</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210618093943.png" alt=""></p><ol><li>将物理内存分页并以页为单位进行内存分配，解决内存碎片的问题</li><li>分页后通过页表实现地址转换</li><li>采用多极页表降低存放页表造成的空间开销</li><li>采用快表降低多极页表造成的时间开销</li></ol><h2 id="段页结合"><a href="#段页结合" class="headerlink" title="段页结合"></a>段页结合</h2><p>对应用程序来说，希望在操作系统中分段，把每个段分开存储，独立编址。对物理硬件来说，希望在操作系统中分页，提高物理内存的使用效率。因此，操作系统既要实现分段也要实现分页。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210618100546.png" alt=""></p><p>解决方法是，先将程序分段，并建立映射，储存在一个中间结构中，然后每一段在存储的时候分页存储在物理内存中，并建立页与页框的映射。</p><p>这个中间结构就是虚拟内存，虚拟内存是连接分段和分页的桥梁。</p><blockquote><p>一个操作系统一个虚拟内存，一个进程一个虚拟地址空间</p></blockquote><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210618101628.png" alt=""></p><blockquote><p>目前的操作系统放弃了分段，只保留了分页</p></blockquote><h2 id="内存的换入换出"><a href="#内存的换入换出" class="headerlink" title="内存的换入换出"></a>内存的换入换出</h2><p>对 64 位系统的每一个进程，其虚拟地址空间大小是18,446,744,073G，对32位系统，其虚拟地址空间的大小是4G。然而，实际的物理内存没有这么大，因此就需要时不时把内存中的数据释放掉，给下一个进程。然后等下次用到时再从硬盘中读取。</p><h3 id="内存换入"><a href="#内存换入" class="headerlink" title="内存换入"></a>内存换入</h3><p>内存换入的核心就是从硬盘中将数据移入物理内存，并将虚拟内存和物理内存进行关联。内存是一页一页的分配给内存的，同样也是一页一页从硬盘中调取的，因此内存换入是通过 <strong>申请调页</strong> 来实现的。</p><p>在页表中有一项用来表示这页内存是否在物理内存中。MMU在地址转换前会查看页表中的那个位置是否存在。如果存在就将转换后的地址发到地址总线；如果不存在，说明这一页不在物理内存中，就会申请调页。调页结束后将地址发送到地址总线。</p><h4 id="请求调页"><a href="#请求调页" class="headerlink" title="请求调页"></a>请求调页</h4><p>操作系统通过中断来实现。当不在内存中时，触发缺页中断。</p><p>中断处理函数会找到一块空闲的物理内存，然后把硬盘中对应的数据写入到那一页，然后修改页表建立联系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">do_no_page</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> error_code, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> address)</span> </span>&#123;<br>    address &amp;= <span class="hljs-number">0xfffff000</span>;<span class="hljs-comment">// 找到对应的页</span><br>    page = get_free_page();<br>    bread_page(page, current-&gt;executable-&gt;i_dev, nr);<span class="hljs-comment">// 找到磁盘中当前运行的可执行程序，把那一页赋值到空闲页中</span><br>    put_page(page, address);<span class="hljs-comment">// 在页表中将空闲页与虚拟地址关联起来</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="内存换出"><a href="#内存换出" class="headerlink" title="内存换出"></a>内存换出</h3><p>在上面 <code>get_free_page()</code> 中要找到一个空闲页。当物理内存全部填充满了就需要将一页内存换出了。而将哪一页换出则需要看采用了什么 <strong>页面换出算法</strong></p><ul><li>FIFO</li><li>LRU（Least Recently Used）算法：将最近最少使用的页置换出去。具体实现就是对每一页记录上次访问到现在的时间，时间最长的那一页就是需要置换出去的页。（该算法在实际过程中维护这个参数需要耗费太长的时间，不适用）</li><li>clock算法：近似的LRU算法。对每一个页维护一个 <code>bool</code> 类型的值 <code>R</code>。<code>R</code> 为 <code>true</code> 表示最近访问过；<code>R</code> 为 <code>false</code> 表示最近没访问过，有换下的风险。设置两个指针，一个移动快的指针负责更新最近使用的信息，一个移动慢的指针负责选出要换出的页。<ul><li>快的指针 (<strong>扫描指针</strong>)：定期扫描所有的页面，将页面中所有页的 <code>R</code> 改为 <code>false</code></li><li>慢的指针 (<strong>换出指针</strong>)：在缺页的时候工作，扫描页，将 <code>R</code> 为 <code>false</code> 的那一页换出</li></ul></li></ul><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><h3 id="虚拟内存的作用"><a href="#虚拟内存的作用" class="headerlink" title="虚拟内存的作用"></a>虚拟内存的作用</h3><ul><li>保护了每个进程的地址空间不被其他进程破坏</li><li>虚拟内存为每个进程提供了相同的内存模型，便于内存的管理</li><li>虚拟内存能够让进程使用比物理内存大的内存空间</li></ul><h3 id="虚拟内存的使用（地址翻译）"><a href="#虚拟内存的使用（地址翻译）" class="headerlink" title="虚拟内存的使用（地址翻译）"></a>虚拟内存的使用（地址翻译）</h3><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210914161148.png" alt=""></p><p>CPU想要访问内存中的数据时，</p><ol><li><p>将这个数据的虚拟地址（VA）发送给内存管理单元（MMU）</p></li><li><p>MMU拿到VA后，取出VA中的虚拟页表号VPN，然后再快表（TLB）中进行查询</p></li><li><p>如果在TLB中找到了VPN对应的物理页表项（PTE），则返回PTE给MMU</p><blockquote><p>PTE的key是VPN，表项有物理页号、这块页的权限、这块页是否对应有物理内存等信息</p></blockquote></li><li><p>如果在TLB中没有找到</p><ol><li><p>在内存中的页表中根据VPN进行查找。如果是多级页表，只有最底层的页表中存放的是PTE，其他级的页表存放着VTE，VA中分出多级VPN，然后一级一级的查找，最终查询到最底层的页表得到PTE</p><blockquote><p>VTE表的项目就是下一级页表的地址了</p></blockquote></li><li><p>将得到的PTE返回给MMU，MMU将新的到的PTE存放在TLB中</p></li></ol></li><li><p>MMU对得到的PTE判断这块页是否对应有物理内存</p></li><li><p>如果有物理内存，计算PV</p></li><li><p>如果没有物理内存</p><ol><li>MMU将触发一个缺页中断，CPU运行缺页中断对应的系统调用</li><li>缺页处理函数判断这个地址是否合法、访问这个地址是否合法（此时是内核态）</li><li>缺页处理函数选择一个牺牲页，如果这个牺牲页被修改过，就把它换出磁盘</li><li>缺页处理函数换入新页，并更新内存和TLB中的PTE</li><li>MMU计算PV</li></ol></li><li><p>根据PV对物理内存进行访问等操作</p></li></ol><h2 id="内存相关Linux命令"><a href="#内存相关Linux命令" class="headerlink" title="内存相关Linux命令"></a>内存相关Linux命令</h2><p><code>free</code></p><p><code>free</code> 命令负责查看内存的使用情况</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pi</span>@raspberrypi:~ $ free -h<br>              <span class="hljs-attribute">total</span>        used        free      shared  buff/cache   available<br><span class="hljs-attribute">Mem</span>:          <span class="hljs-number">1</span>.<span class="hljs-number">8</span>Gi       <span class="hljs-number">104</span>Mi       <span class="hljs-number">1</span>.<span class="hljs-number">5</span>Gi       <span class="hljs-number">8</span>.<span class="hljs-number">0</span>Mi       <span class="hljs-number">250</span>Mi       <span class="hljs-number">1</span>.<span class="hljs-number">6</span>Gi<br><span class="hljs-attribute">Swap</span>:          <span class="hljs-number">99</span>Mi          <span class="hljs-number">0</span>B        <span class="hljs-number">99</span>Mi<br></code></pre></td></tr></table></figure><blockquote><p><code>-h</code> 表示用人类友好的输出样式，不加就是以 <code>k</code> 为单位的显示</p></blockquote><ul><li><code>Mem</code> 表示实际的物理内存大小，<code>Swap</code> 表示磁盘交换分区的大小</li><li><code>free</code> 表示真正空闲的内存大小（不含缓存），<code>share</code> 表示多个进程共享的内存，<code>buff/cache</code>表示缓存的大小</li></ul><p><code>pmap</code>：查看进程的内存映射</p><h1 id="IO管理"><a href="#IO管理" class="headerlink" title="IO管理"></a>IO管理</h1><p>IO管理就是对外部设备的管理，操作系统将不同的外部设备统一抽象成了文件，对外设的使用，就是读写外设对应的文件。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210618223922.png" alt=""></p><blockquote><p>操作系统中有几种类型的文件：普通文件、字符特殊文件和块特殊文件。字符特殊文件和块特殊文件对应外设。字符特殊文件用于输入输出（键鼠、显示器和网络），块特殊文件用于磁盘。</p></blockquote><p>在管理外部设备时，有两条主线</p><ul><li>CPU发送指令给外设</li><li>外设工作完后通过中断通知CPU</li></ul><p>下面以显示器驱动为例介绍 CPU 发送命令给外设，以键盘为例介绍外设中断通知 CPU</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210619094437.png" alt=""></p><h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><p>在 C++ 中，我们通过</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ofstream <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;Demo.txt&quot;</span>)</span></span>;<br>file &lt;&lt; <span class="hljs-string">&quot;Test&quot;</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>向 <code>Demo.txt</code> 文件输出 <code>Test</code> 文字。</p><p>而磁盘的使用是通过CHS（柱面cylinder、磁头magnetic head和扇区sector）这几个数据让磁头移动到对应的位置，然后读取磁盘上的数据。</p><p>操作系统通过一层层抽象，将CHS这些物理数据变成了 路径名+文件名 的形式。</p><h2 id="生磁盘的使用"><a href="#生磁盘的使用" class="headerlink" title="生磁盘的使用"></a>生磁盘的使用</h2><h3 id="抽象1：从磁盘块到CHS"><a href="#抽象1：从磁盘块到CHS" class="headerlink" title="抽象1：从磁盘块到CHS"></a>抽象1：从磁盘块到CHS</h3><p>磁盘的访问每次都需要告诉磁盘驱动器CHS三个数值，这样十分麻烦，可以使用一个词 <strong>磁盘号</strong> 代替这些</p><p>由于磁盘花费时间：寻道（移动磁臂到指定柱面） &gt; 磁头 &gt; 扇区。因此磁盘中数据的排列要从扇区开始，转完了一个扇区，就到下一个磁头，再到下一个柱面。因此磁盘中的每一个位置 <code>(C,H,S)</code> 就都可以通过一个整数 <code>sector</code> 编码。其中，<code>Sectors</code> 表示一个扇区的大小，<code>Headers</code> 表示一个磁头的大小</p><script type="math/tex; mode=display">sector=C\times(\text{Headers}\times\text{Sectors})+H\times\text{Sectors}+S</script><p><code>(C,H,S)</code> 就很容易从 <code>sector</code> 反推出来了</p><script type="math/tex; mode=display">S=sector\%\text{Sectors}\\H=sector/\text{Sectors}\%\text{Headers}\\C=sector/\text{Sectors}/\text{Headers}</script><p>由于磁盘的旋转速度很快，操作系统为了提高系统运行速度，一次性读取多个扇区，这多个扇区被叫做盘块。</p><script type="math/tex; mode=display">sector=blocknr\times\text{blocksize}</script><p>其中，<code>blocksize</code> 就是盘块中扇区的大小</p><h3 id="抽象2：多进程队列"><a href="#抽象2：多进程队列" class="headerlink" title="抽象2：多进程队列"></a>抽象2：多进程队列</h3><p>上面描述了一个进程使用盘块的情景，多个盘块使用就需要考虑到调度问题，要考虑用哪一个进程访问，就需要调度。</p><p>因此进程向操作系统发出使用磁盘的请求，操作系统从请求队列中选择一个请求，读取出其中的盘块号，计算出CHS，然后通过 <code>out</code> 指令发送给磁盘控制器。</p><p>常见的磁盘调度算法有</p><ul><li>FCFS：先来先服务</li><li>SSTF(Short seek time first)：最短寻道时间优先，不过这样对磁盘的请求服务机会会不均等</li><li>SCAN：磁盘调度扫描算法，向一个方向进行扫描，并处理经过的所有磁盘请求，位于中间的请求还是占便宜了</li><li>CSCAN：循环扫描算法，在SCAN的基础上当这个方向没有请求后，就迅速复位到另一个方向的最大请求位置</li></ul><h3 id="抽象3：高速缓存"><a href="#抽象3：高速缓存" class="headerlink" title="抽象3：高速缓存"></a>抽象3：高速缓存</h3><p>由于程序具有一定的局部性，因此同一个文件可能会被多次访问，频繁访问磁盘会显著降低系统运行效率，因此可以把最近访问的数据存储到内存中，当用户请求的盘块号在高速缓存中，操作系统会直接将信息返回。</p><h2 id="基于文件的磁盘的使用"><a href="#基于文件的磁盘的使用" class="headerlink" title="基于文件的磁盘的使用"></a>基于文件的磁盘的使用</h2><h3 id="抽象4：从文件到多进程队列"><a href="#抽象4：从文件到多进程队列" class="headerlink" title="抽象4：从文件到多进程队列"></a>抽象4：从文件到多进程队列</h3><p>这层抽象处理 <code>file &lt;&lt; &quot;Test&quot; &lt;&lt; endl;</code> 语句。对用户来说，文件就是一个字符流，访问文件就是读取字符流，在文件中写内容就是在字符流中的某个位置添加字符。这一层就是通过字符流和它的偏移量来找到对应的盘块号。这层抽象的关键就是建立 <code>(文件,偏移量)</code> 到盘块号的映射。</p><p>这种映射有多种方式：</p><ul><li>顺序存储（有些浪费）</li><li>链式存储（查询效率低）</li><li>索引存储</li></ul><p>UNIX采用的是多极索引，小文件不索引，中等文件一级索引，大文件二级索引</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210624211552.png" alt=""></p><p>在访问时，根据文件找到其FCB，然后根据偏移量的大小分别进行直接读取、一级索引、二级索引操作，得到系统的盘块号，然后根据盘块号计算CHS，进行数据的读取。而 <code>file</code> 变量与文件的 FCB有关</p><blockquote><p>FCB也称为 <code>iNode</code> 。在 Linux 操作系统中，可以使用 <code>df -i</code> 查看 FCB 的使用情况</p><p>关于inode(index node)这里有一篇很好的文章：<a href="http://www.ruanyifeng.com/blog/2011/12/inode.html">http://www.ruanyifeng.com/blog/2011/12/inode.html</a></p></blockquote><h3 id="抽象5：从文件名到文件"><a href="#抽象5：从文件名到文件" class="headerlink" title="抽象5：从文件名到文件"></a>抽象5：从文件名到文件</h3><p>这层抽象处理从文件名找到FCB，即 <code>ofstream file(&quot;Demo.txt&quot;);</code> </p><p>磁盘在用户眼中是一颗目录树。因此，磁盘管理器和操作系统就需要将树构造出来。目录的信息存放在 FCB 中（目录和文件都有 FCB ）。每一层目录的FCB中都存放一个散列表，里面存放 <code>&lt;string name, int number&gt;</code> (key 是 文件/目录名，value是文件的/目录的FCB号)。</p><p>进行目录解析时，例如当前目录为 <code>/data</code> 要进入子目录 <code>/data/test</code> ，操作系统会在 <code>/data</code> FCB中的 inode 数组中匹配 <code>test</code> ，得到 <code>/data/test</code> 的 FCB号，然后根据 FCB号就可以读到 <code>/data/test</code> 的 FCB，也就进入了 <code>/data/test</code> 目录，迭代下去就可以找到最终的文件。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210625101016.png" alt=""></p><p>当磁盘格式化的时候，会在 0 位置存放一些信息：引导块、超级块、空间空闲管理、FCB、根目录和数据区。（超级块中存放超级块、空闲空间管理等的大小）操作系统在启动的时候就会根据超级块中存放的信息将根目录的 FCB 找到。</p><blockquote><p>在Linux操作系统中，可以使用<code>ls -i</code> 查看FCB号</p></blockquote><h2 id="文件管理总结"><a href="#文件管理总结" class="headerlink" title="文件管理总结"></a>文件管理总结</h2><p>操作系统管理磁盘的步骤是</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/%E7%A3%81%E7%9B%98%E5%A4%9A%E8%BF%9B%E7%A8%8B%E9%98%9F%E5%88%97.png" alt=""></p><ol><li>安装操作系统时，将磁盘格式化为如上图 <code>root</code> 所示样式</li><li>系统启动的时候，在初始化过程中，将磁盘根目录FCB找到，将磁盘 <code>inode</code> 数组找到，放入内存中</li><li>用户创建的进程继承这个根目录的FCB</li><li>用户打开文件，根据路径名进行目录解析，找到该文件对应 FCB</li><li>用户发出读写指令，进程根据文件和字符流位置，找到对应的盘块号</li><li>操作系统读取高速缓存，如果命中，直接复制它，并返回给用户态缓存；如果没有命中，将在高速缓存中申请一块空白区域</li><li>发起磁盘读写请求，加入电梯队列，然后睡眠进程</li><li>磁盘读取完毕后，发生中断，取出该请求，计算出 CHS ，并向磁盘管理器发送指令，读取对应的数据</li><li>读取完毕后产生磁盘中断，唤醒对应的应用进程。</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPU、操作系统和网络中的流水线</title>
    <link href="/2021/06/10/HUST/PipelineInCPU&amp;OS&amp;Net/"/>
    <url>/2021/06/10/HUST/PipelineInCPU&amp;OS&amp;Net/</url>
    
    <content type="html"><![CDATA[<p>流水线在优化效率中特别常见，这里就对比一下这三块中用到的方法，把他们串起来</p><span id="more"></span><p>从最底层的CPU，再到操作系统，最后到网络一层层向上</p><h1 id="CPU中的流水线"><a href="#CPU中的流水线" class="headerlink" title="CPU中的流水线"></a>CPU中的流水线</h1><p>CPU中，一条指令的执行可以分为 <strong>取指、译码、执行、访存、写回和PC更新</strong> 6个阶段，当执行到某一阶段时，其他电路就会停下来等待，这样就造成了资源的浪费。因此采用流水线当一条指令还没执行完，就开始执行下一条指令。</p><ul><li><p>取指（Fetch）：CPU根据 PC 寄存器从内存中取出指令字节。并从字节中识别指令类型，判断是否含有寄存器指示符、常数等，计算指令长度。</p><blockquote><p>指令类型由 <code>icode</code> 和 <code>ifun</code> 两个值表示</p></blockquote></li><li><p>译码（Decode）：从寄存器文件读取数据</p></li><li><p>执行（Execute）：ALU进行运算（有三种类型的运算：算术逻辑运算、有效地址的计算和 <code>push,pop</code> 指令中栈的计算）</p></li><li><p>访存（Memory）：内存的读写</p></li><li><p>写回（Write back）：将计算结果写回到寄存器中</p></li><li><p>PC更新：将PC设置为下一条指令的地址。当涉及到条件判断时，采用 <strong>分支预测</strong> 策略，先假定要执行其中一个。如果预测失败，在进行相应的回退</p></li></ul><blockquote><p>一条指令执行的 6 个部分不一定全部都执行</p></blockquote><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210612103026.png" alt=""></p><blockquote><p>在第5个时刻，CPU的所有部件都运行起来了</p></blockquote><p>引入流水线后，相邻指令之间就会出现一些问题，可以分为 2 类</p><ul><li>数据冒险：当一条指令的执行需要用到正在运行的指令的结果，如果不进行处理，就会产生错误</li><li>控制冒险：当遇到 <code>jmp,ret</code> 或调用这些指令时，需要计算下一个指令的地址，可能会出现错误</li></ul><h2 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h2><p>解决数据冒险最简单的策略就是 <strong>暂停</strong>，在各个阶段的电路中运行一段空的指令（气泡）。气泡不会改变寄存器和CPU的状态</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210612105638.png" alt=""></p><p>有些数据在写回阶段前就已经计算出了结果，因此为了提高效率，可以直接把执行阶段的计算结果 <strong>转发</strong> 给译码阶段</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210612111310.png" alt=""></p><blockquote><p>当然，有些指令到了后期才出结果，就算转发也会出现数据冒险（如 <code>mov (%rbx),  %rax</code> ），这时候就要 转发 + 暂停 结合使用</p></blockquote><h2 id="控制冒险"><a href="#控制冒险" class="headerlink" title="控制冒险"></a>控制冒险</h2><p>当执行 <code>ret</code> 指令时，下一条指令的地址在内存栈中，因此要在访存阶段才会得到下一条指令的地址。再就是 <code>jmp</code> 指令不好预测</p><p>对 <code>ret</code> 指令，就是通过暂停来解决控制冒险</p><p>对 <code>jmp</code> 指令，当发现预测错误，就立即停止正在执行的错误代码，然后向后面的阶段 <strong>插入气泡</strong> ，重新执行正确的代码</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210612113714.png" alt=""></p><p>当然，执行的时候可能出现不止一个错误。采用暂停 + 插入气泡的方式解决</p><h1 id="操作系统中的流水线"><a href="#操作系统中的流水线" class="headerlink" title="操作系统中的流水线"></a>操作系统中的流水线</h1><p>操作系统中的流水线主要就是CPU进程的切换。当进程因为 IO 或超时计时器到时了，操作系统就需要切换应用进程，保证CPU一直处于工作中。</p><p>和CPU中的流水线相比，操作系统麻烦的地方在于数据的保存。由于切换后需要恢复进程的上下文，同时，由于涉及到对操作系统核心的保护，操作系统的切换分成了 5 段</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210612135352.png" alt=""></p><h1 id="网络中的流水线"><a href="#网络中的流水线" class="headerlink" title="网络中的流水线"></a>网络中的流水线</h1><p>计算机网络中的流水线有两个地方</p><ul><li>应用层 HTTP1.1 中采用持续性链接的 HTTP，在同一个 TCP 连接中，一个请求的响应还没接收就继续发送下一个请求</li><li>传输层中 TCP 连接发送报文段。设置发送缓冲区 &gt; 1 以实现流水线发送，根据接收缓冲区的大小有两种流水方式，第一种是 GBN 协议，另外一种是 SR 协议</li></ul><p>网络中的流水线不需要考虑到计算出错，也不需要考虑恢复状态，因此简单很多，只需要考虑差错恢复。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由于不同的使用环境，导致流水线不同的关注重点。CPU要求执行不能出错，因此 CPU 流水线对相邻指令干扰的情况设置了暂停、气泡的方式；操作系统要求切换前后状态不变，因此操作系统流水线设置了 5 段以及映射表的切换，来实现切换前后进程的栈、PCB和内存是不变的；网络丢失了重发就可以，因此只需要考虑差错恢复，设置重发的规则即可。</p>]]></content>
    
    
    <categories>
      
      <category>计算机相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2021/05/02/HUST/ComputerNetworking/"/>
    <url>/2021/05/02/HUST/ComputerNetworking/</url>
    
    <content type="html"><![CDATA[<p>计算机网络的笔记和总结，方便日后回顾用</p><span id="more"></span><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="因特网"><a href="#因特网" class="headerlink" title="因特网"></a>因特网</h3><p>网络是节点和边，计算机网络就是以计算机为节点的网络。因特网就是全球节点数量最多，覆盖范围最大的一个计算机网络。</p><blockquote><ul><li><p>节点就是主机和路由器交换机</p></li><li><p>边就是通信链路。通信链路有接入链路（与主机相连）和主干链路。</p></li></ul><blockquote><p>主机包括个人电脑、手机、平板物联网系统，还有公司的服务器等等</p></blockquote></blockquote><p>因特网是一个非常复杂的网络，它有两种解读方式。</p><ul><li><p>从组成来看，因特网是由网络边缘、网络核心和接入网构成的</p></li><li><p>从功能来看，因特网是分布式应用进程和为分布式进程提供服务的基础设施</p><blockquote><p>分布式应用进程就是各种需要网络的软件</p></blockquote></li></ul><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>对等通信实体之间交换的报文的规范的集合(包括语法、语义、时序等)</p><h2 id="因特网的组成"><a href="#因特网的组成" class="headerlink" title="因特网的组成"></a>因特网的组成</h2><p>网络可以分为网络边缘（就是主机）和网络核心，还有接入网</p><p>网络边缘就是主机，网络核心是网络中的交换节点，通讯链路将网络边缘接入网络核心</p><blockquote><p>主机和端系统是同一个东西</p></blockquote><h3 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h3><p>网络的边缘就是一堆主机。这些主机的通讯有两种模式，它们的通讯也有两种服务</p><p>根据主机（应用）之间通讯的模式，可以分为</p><blockquote><p>这里的模式是主机和主机之间的通讯，不考虑网络核心和接入网的内容。</p></blockquote><ul><li>C/S 模式：就是客户端/服务器模式。这里向服务器发出指令的就是客户端，接受指令并返还数据给客户端的就是服务器。一般一台服务器需要服务很多客户端。这种模式的弊端就是可拓展性差，当服务器不够时，需要耗费很高的成本来更新。</li><li>P2P模式：就是对等模式，P2P模式没有服务器，或服务器非常少。这里的主机既是服务器，又是客户端，各自为各自提供服务。</li></ul><p>根据网络其他部分为它提供的服务，可以分为</p><ul><li>面向连接的服务（TCP服务）：数据传输之前要先握手，同时保证数据传输的可靠有序，同时提供流量控制和拥塞控制的服务</li><li>无连接的服务（UDP服务）：数据传输不需要握手，直接传，不保证数据一定到达。适用于流媒体等的应用程序</li></ul><h3 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h3><p>接入网就是把主机连入网络核心。</p><h4 id="接入方式"><a href="#接入方式" class="headerlink" title="接入方式"></a>接入方式</h4><p>网络的接入方式有以下几种</p><ul><li><p>住宅接入</p><ul><li>DSL ( Digital Subscriber Line ), ADSL：电话线用来当网线</li><li>电缆接入 ( cable Internet access )：电视线当网线</li><li>FTTH ( Fiber To The Home )光纤入户</li></ul></li><li><p>企业接入</p><ul><li>以太网 ( Ethernet )</li></ul></li><li>无线接入<ul><li>无线局域网 (LAN)：WiFi</li><li>广域无线接入：4G，5G</li></ul></li></ul><h4 id="物理媒体"><a href="#物理媒体" class="headerlink" title="物理媒体"></a>物理媒体</h4><ul><li>引导型媒体：双绞铜线（电话线），同轴电缆（电视），光纤</li><li>非引导型媒体：微波、LAN (WiFi)、广域 (蜂窝数据)、卫星</li></ul><h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><p>网络的核心就是链路、路由器和交换机的地盘了。</p><p>这一块的核心就是数据的传输。有两种传输方式</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210502221923.png" alt=""></p><ul><li><p>电路交换</p><p>把链路划分成一份一份的（按照原理不同可以分为 时分(TDM)、频分(FDM)和波分 ）。进行数据传输时，建立起一条从源主机到目标主机连接，同时这个连接独占所经过的链路的其中一份。</p><p>这种方式常被电话网络使用。连接独占资源，有性能保障。</p><blockquote><p>电路交换并不适合于计算机网络。因为计算机网络具有突发性，比较浪费，同时建立连接的时间比较久</p></blockquote></li><li><p>分组交换</p><p>把传输的数据分成一组一组的。传输的时候每个数据组单独传输，独占这条链路的所有资源，同时路由器会把数据组存储起来，等数据组传输完毕后再转发到下一个路由器，最终一个个分组被传输到目标主机。</p><p>分组交换有两个关键功能：路由和转发</p><ul><li>路由：决定分组采用的源到目标的路径</li><li>转发：将分组从路由器的输 入链路转移到输出链路</li></ul><p>分组交换也有两种方式：数据报（分组的目标地址决定下一跳，在不同的阶段，路由可以改变）和虚电路（在呼叫建立时决定路径，在整个呼叫中路径保持不变。每个分组都带标签，标签决定下一跳）</p><blockquote><p>路由器存储的目的时为了实现资源的共用。不存储的话，就相当于直接独占了整个链路。</p><p>线路交换能够实现多路复用，提高资源利用率，容纳更多的应用</p></blockquote></li></ul><h2 id="因特网的结构"><a href="#因特网的结构" class="headerlink" title="因特网的结构"></a>因特网的结构</h2><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210502222124.png" alt=""></p><p>松散的层次结构</p><ol><li>各个接入ISP 接入一个全球 ISP</li><li>有多个全球 ISP相互竞争又相互连接（通过IXP连接）</li><li>业务进行细分，出现区域ISP</li><li>内容提供商 (ICP) 建立自己的网络</li></ol><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20210502222226054.png" alt=""></p><blockquote><p>ISP之间的连接：对等连接、IXP</p></blockquote><h2 id="因特网的实现"><a href="#因特网的实现" class="headerlink" title="因特网的实现"></a><strong>因特网的实现</strong></h2><p>这一块是最关键的。</p><p>复杂的功能通过分层来实现。总共有 5 层：</p><blockquote><p>分层实现结构清晰，易于维护和升级，但是效率低。</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">作用</th><th style="text-align:center">例子</th><th style="text-align:center">数据单元</th></tr></thead><tbody><tr><td style="text-align:center">应用层</td><td style="text-align:center">网络应用</td><td style="text-align:center">HTTP, FTP</td><td style="text-align:center">报文 Message</td></tr><tr><td style="text-align:center">传输层</td><td style="text-align:center">主机之间的数据传输，区分进程</td><td style="text-align:center">TCP, UDP</td><td style="text-align:center">报文段 Segment (TCP : 段，UDP: 数据报)</td></tr><tr><td style="text-align:center">网络层</td><td style="text-align:center">为数据报从源到目的选择路由(端对端通信)</td><td style="text-align:center">IP, 路由协议</td><td style="text-align:center">分组 Packet</td></tr><tr><td style="text-align:center">链路层</td><td style="text-align:center">相邻网络节点间的数据传输(点对点通信)</td><td style="text-align:center">以太网, WiFi</td><td style="text-align:center">帧 Frame</td></tr><tr><td style="text-align:center">物理层</td><td style="text-align:center">在线路上传送bit</td><td style="text-align:center"></td><td style="text-align:center">位 Bit</td></tr></tbody></table></div><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210502231712.png" alt=""></p><p>每层通过层间接口访问下层服务获取报文，从而为上层提供服务，最终实现复杂功能。</p><blockquote><p>服务(Service)：低层实体向上层实体提供它们之间的通信的能力，是通过原语(primitive)来操作的</p><blockquote><p>服务有两种类型：面向连接的服务（事先要建立连接，通信结束后去除连接）和无连接的服务</p><p>上层使用下层提供的服务通过层间的接口，这个接口叫做服务访问点</p></blockquote><p>协议(protocol) ：对等层实体(peer entity)之间在相互通信的过程中，需要遵循的规则的集合</p><p>本层协议的实现要靠下层提供的服务来实现，本层实体通过协议为上层提供更高级的服务</p></blockquote><p>各层传输时，对加上本层的信息，对数据进行封装和解封装</p><blockquote><p>封装和解封装的过程</p><ul><li>第 n 层要往第 n + 1 层发送的数据包括这一层的头和上一层的数据单元，这个数据叫做服务数据单元(SDU)。往下层发的时候，不光要发SDU，还要发送一些接口控制信息(ICI)（类似于n + 1层采用什么样的协议这些的）。</li><li>ICI 和 SDU 在服务访问点把数据传递给 n + 1 层（SAP可以当作是一些函数）。</li><li>n + 1 层拿到数据后把 ICI 和 SDU 分开，并且把SDU重新整合（分组或者合并）载加上自己的头，就形成了协议数据单元(PDU)。当 n + 1 层向下传递时，PDU就变成了SDU（本层的PDU为下层的SDU，本层的SDU为上层的PDU）</li></ul></blockquote><h2 id="因特网的性能"><a href="#因特网的性能" class="headerlink" title="因特网的性能"></a>因特网的性能</h2><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210502223243.png" alt=""></p><ul><li>延时：有四种延时<ul><li>传播延时：当两台主机距离过长的时候，就要考虑光的传播速度了</li><li>传输延时：数据在网线中传播要考虑网线的带宽</li><li>处理延时：路由器存储转发过程中的处理的时间</li><li>排队延时：当路由器正在发的时刻，数据又来了，新的数据就需要排队等待路由器发完</li></ul></li><li>流量强度 $L\alpha/R$：</li><li>吞吐量</li><li>丢失<ul><li>缓冲区溢出</li><li>出错抛弃</li></ul></li></ul><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>应用层是网络存在的理由。应用层的特点是协议很多，比较重要的有HTTP，SMTP等等，然后DNS也是运行在应用层当中的。</p><h2 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h2><h3 id="网络应用的体系架构"><a href="#网络应用的体系架构" class="headerlink" title="网络应用的体系架构"></a>网络应用的体系架构</h3><p>应用层有三种体系架构</p><ul><li><p>C/S 模式</p></li><li><p>P2P 模式：拓展性强，管理困难</p></li><li><p>混合模式：一部分任务在C/S模式，一部分在P2P模式</p><blockquote><p>例如文件传输应用，文件的检索可以是C/S模式，文件到的下载是P2P模式；即时通讯软件：在线状态的判断是C/S模式，两个用户聊天的时候是P2P模式</p></blockquote></li></ul><h3 id="应用需要解决的问题"><a href="#应用需要解决的问题" class="headerlink" title="应用需要解决的问题"></a>应用需要解决的问题</h3><p>两个应用进程之间通讯，如果是同一台主机，就使用操作系统的通信方式，如果是不同的主机，就要用到网络了。</p><p>写应用要考虑三个问题</p><h4 id="如何区分主机的应用进程"><a href="#如何区分主机的应用进程" class="headerlink" title="如何区分主机的应用进程"></a>如何区分主机的应用进程</h4><p>这个就是靠Socket了。Socket是一个整数，代表了 IP + 端口号了。</p><ul><li>对于TCP，Socket是两个主机的 IP 和 端口号。两边的IP确定了主机就确定了，两边的端口号确定了，对应的应用进程也就确定了。这四个数字就可以唯一确定一条连接。</li><li>对于UDP，Socket是本地的 IP 和 端口号。</li></ul><h4 id="如何用传输层提供的服务"><a href="#如何用传输层提供的服务" class="headerlink" title="如何用传输层提供的服务"></a>如何用传输层提供的服务</h4><p>传输层向应用层提供的服务有两类</p><ul><li>TCP（面向连接）<ul><li>可靠保序字节流</li><li>流量控制</li><li>拥塞控制</li></ul></li><li>UDP（无连接）<ul><li>快速</li></ul></li></ul><p>对于任何一个连接，需要告诉别人三个东西</p><ul><li>目标主机IP和应用进程的端口号（收件人）</li><li>自己的主机IP和应用进程端口号（寄件人）</li><li>要传输的报文（寄出去的东西）</li></ul><p>有了这3个内容后，就可以选择一种传输层的服务往下传了</p><p>在实际传输过程中，对TCP，前两个被打包成了 socket ；对UDP，只把第二个打包成了socket，但是传输过程中要额外提供第一个。</p><h4 id="如何实现编写程序"><a href="#如何实现编写程序" class="headerlink" title="如何实现编写程序"></a>如何实现编写程序</h4><p>这个就靠协议了。</p><h2 id="C-S模式"><a href="#C-S模式" class="headerlink" title="C/S模式"></a>C/S模式</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>为了实现Web应用，就有了HTTP协议。</p><p>Web是由对象构成的。一个对象就是一个文件（像是图像、文本这些的）。Web一般会有Html文件。Html文件包含文本，还包含其他对象（比如说图片）。这些对象在Html中是以url地址的形式储存的。浏览器绘制网页时，就一个个找出html文件中的对象，然后把他们画出来。</p><blockquote><p>url 格式：<code>Prot://user:psw@www.someSchool.edu/someDept/pic.gif:port</code></p></blockquote><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p><strong>HTTP协议采用 C/S 模式，通过 TCP 协议进行传输，端口号为80，无状态</strong></p><blockquote><p>无状态：HTTP不保存任何用户相关的信息</p></blockquote><p>HTTP协议有两种非持续性连接（HTTP 1.0）和持续性连接（HTTP 1.1）</p><ul><li><p>非持续性连接：客户端收到服务器的响应后关掉TCP连接</p></li><li><p>持续性连接：客户端收到服务器的响应后依然保持连接，超过一定时间后关闭</p><p>这里还可以细分</p><ul><li>流水线模式：请求收到回复前接着请求</li><li>非流水线模式：一个请求得到回复后再发另外一个请求</li></ul></li></ul><h4 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h4><p>HTTP有两种报文格式：请求报文和响应报文</p><ul><li><p>请求报文</p><p>有GET，POST，HEAD，PUT，DELETE等命令</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th>内容举例</th></tr></thead><tbody><tr><td style="text-align:center">请求行</td><td><code>GET /somedir/page.html HTTP/1.1</code></td></tr><tr><td style="text-align:center">首部行</td><td><code>Host: www.someschool.edu</code>\n<code>User-agent: Mozilla/4.0</code>\n<code>Connection: close</code>\n  <code>Accept-language:fr</code></td></tr><tr><td style="text-align:center">空行</td><td></td></tr><tr><td style="text-align:center">实体主体</td><td>（数据）</td></tr></tbody></table></div><blockquote><p>客户端向服务器提交信息不是必须使用POST请求，还可以使用 GET + 参数 的形式</p></blockquote><ul><li><p>响应报文</p><p>有一些状态码</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">响应状态码</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">200 OK</td><td style="text-align:center">请求成功，请求对象包含在响应报文的后续部分</td></tr><tr><td style="text-align:center">301 Moved Permanently</td><td style="text-align:center">请求的对象已经被永久转移了；新的URL在响应报文的Location: 首部行中指定；客户端软件自动用新的URL去获取对象</td></tr><tr><td style="text-align:center">400 Bad Request</td><td style="text-align:center">一个通用的差错代码，表示该请求不能被服务器解读</td></tr><tr><td style="text-align:center">404 Not Found</td><td style="text-align:center">请求的文档在该服务上没有找到</td></tr><tr><td style="text-align:center">505 HTTP Version Not Supported</td><td style="text-align:center">-</td></tr></tbody></table></div><p>  报文的形式大概是这样的</p><div class="table-container"><table><thead><tr><th>名称</th><th>内容举例</th></tr></thead><tbody><tr><td>状态行</td><td><code>HTTP/1.1 200 OK\r\n</code></td></tr><tr><td>首部行</td><td><code>Connection close\r\n Date: Thu, 06 Aug 1998 12:00:15 GMT\r\n Server: Apache/1.3.0 (Unix) \r\n</code></td></tr><tr><td>空行</td><td></td></tr><tr><td>数据</td><td>（数据）</td></tr></tbody></table></div><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>由于Http是无状态的，但是网页有识别应用的需求。因此就有了Cookie来让Http识别。</p><p>Cookie的实现是这样的</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210505212724.png" alt=""></p><p>Cookie的四个组成部分</p><ul><li>在HTTP响应报文中有 一个cookie的首部行</li><li>在HTTP请求报文含有 一个cookie的首部行</li><li>在用户端系统中保留有 一个cookie文件，由用户的浏览器管理</li><li>在Web站点有一个后端数据库</li></ul><h4 id="Web缓存（代理服务器）"><a href="#Web缓存（代理服务器）" class="headerlink" title="Web缓存（代理服务器）"></a>Web缓存（代理服务器）</h4><p>Web由于采用C/S模式，源服务器压力会很大，为了改善上网体验就有了Web缓存，可以不直接访问源服务器就可以获取请求内容。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210505212533.png" alt=""></p><p>用户设置浏览器通过缓存访问Web后，浏览器将所有的HTTP 请求发给缓存，然后根据</p><ul><li>对象在缓存中：缓存 直接返回对象</li><li>对象不在缓存：请求原始服务器，然后再将对象返回给客户端</li></ul><p>有了缓存，有以下的好处：</p><ul><li>降低客户端的请求响应时间</li><li>可以大大减少一个机构内部网络与Internent接入链路上的流量</li><li>互联网大量采用了缓存，可以使较弱的ICP也能够 有效提供内容</li></ul><p>为了实现缓存的功能，Http添加了条件Get语句</p><ul><li>缓存器: 在HTTP请求中指 定缓存拷贝的日期 <code>If-modified-since:&lt;date&gt;</code> </li><li>服务器: <ul><li>如果缓存拷贝陈旧，则正常响应报文，比如：<code>HTTP/1.0 200 OK</code></li><li>如果缓存拷贝最新，则响应 <code>HTTP/1.0  304 Not Modified</code></li></ul></li></ul><h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210506202700.png" alt=""></p><p>文件传输协议</p><p><strong>HTTP协议采用 C/S 模式，通过 TCP 协议进行传输，端口号为21，有状态，将数据与控制分开</strong></p><p>FTP协议需要两条TCP连接</p><ul><li>控制连接：获得身份认证，以及实现浏览远程目录</li><li>数据连接：收到传输命令后开始连接，这个连接就专门用来传输文件</li></ul><blockquote><p>这种控制与数据分开的连接就叫做 <strong>带外传送</strong></p></blockquote><p>FTP的响应报文和Http一样</p><h3 id="邮件"><a href="#邮件" class="headerlink" title="邮件"></a>邮件</h3><p>邮件系统由 <strong>用户代理、邮箱服务器和SMTP</strong> 组成。</p><p>用户写完邮件之后把文件通过用户代理发送给邮件服务器。</p><ul><li>用户代理：管理邮件，撰写、编辑和阅读邮件都在这个上面</li><li>邮箱服务器：收、发、管理邮件</li></ul><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210506203343.png" alt=""></p><p>发送邮件的过程：</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210506205056.png" alt=""></p><ol><li>用户写好邮件后，用户代理将用户的邮件发送到发件人的邮件服务器，</li><li>发件人邮件服务器将邮件放入外出报文队列中。</li><li>当队列积攒到一定程度后，发送方邮件服务器与接收方邮件服务器建立TCP连接，使用SMTP协议传输文件。</li><li>接收方将收到的邮件放入对应用户的邮箱中</li><li>接收方通过用户代理访问接收方邮件服务器的该用户的邮件内容</li></ol><h4 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h4><p><strong>HTTP协议采用 C/S 模式，通过 TCP 协议进行传输，端口号为25</strong></p><p>SMTP与HTTP的区别</p><ul><li><p>HTTP是一个拉协议，用户通过请求拉取服务器的内容。</p><p>SMTP是一个推协议，用户把文件推向服务器</p></li><li><p>HTTP把文件中的图片这些对象封装在其他的响应报文中</p><p>SMTP把所有对象都放在一个报文中</p></li><li><p>HTTP报文可以是非7位ASCII码</p><p>SMTP报文必须是7位ASCII码，图片这些通过MIME转成ASCII</p></li></ul><blockquote><p>MIME: 多媒体邮件拓展</p></blockquote><h4 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h4><p>邮件的访问是通过邮件访问协议实现的</p><ul><li>POP3：有用户身份确认 (代理&lt;—&gt;服务器) 、事务处理（用户代理获取邮件、删除邮件）、更新三个阶段。无状态</li><li>IMAP：在POP3的基础上增加的很多新的内容，比如说文件夹的管理。有状态。</li><li>Http</li></ul><h2 id="P2P模式"><a href="#P2P模式" class="headerlink" title="P2P模式"></a>P2P模式</h2><p>P2P有以下3类</p><ul><li>集中式目录</li><li>完全分布式</li><li>混合体</li></ul><p>P2P 模式相比 C/S 模式的有点是可拓展性强。并且随着节点数量的增加，C/S 模式的文件分发时间随线性增加，P2P 模式增加的很慢</p><blockquote><p>假设服务器要分发N个大小为F的同一个文件给用户，服务器的上传带宽为 $u_s$，客户端的下载带宽为 $d$。</p><ul><li>C/S 模式，服务器需要一个一个的发出去，分发的时间为 $t_{\text{C/S}}=\max\{\frac{NF}{u_S},\frac{F}{d_\min}\}$ </li><li>P2P 模式，服务器只需要发送一个文件，其余的各个P2P的对等体互相传输，分发的时间为  $t_{\text{P2P}}=\max\{\frac{F}{u_S},\frac{F}{d_{\min}},\frac{NF}{u_s+\sum u}\}$</li></ul></blockquote><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210508213145.png" alt=""></p><blockquote><p>典型 P2P 应用：Napster，Gnutella，KaZaA，BT，DHT</p></blockquote><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>应用层层面的网络基础设施</p><p><strong>DNS是运行在53号端口上的应用服务，是网络运行在应用层上的核心功能，主要使用UDP实现</strong></p><p><strong>DNS的作用主要是把域名变为IP地址</strong>，不过还有其他作用</p><ul><li>主机别名与规范名之间的转换</li><li>邮件服务器别名与规范名之间的转换</li><li>负载分配</li></ul><p><strong>DNS的主要思路是</strong></p><ul><li>分层次、基于域的名字划分</li><li>分布式的数据库完成域名到IP的转换</li></ul><h3 id="IP地址的划分"><a href="#IP地址的划分" class="headerlink" title="IP地址的划分"></a>IP地址的划分</h3><p>DNS采用层次树结构的命名方法，域名的根在全球13个根名字服务器上。这些根被划分成了很多顶级域。从顶级域往下，划分为若干子域名。树的叶子就是一个主机。</p><blockquote><p>顶级域大致有两类：通用的（<code>.com</code>）和国家的（<code>.cn</code>）</p></blockquote><h3 id="域名到IP的转换"><a href="#域名到IP的转换" class="headerlink" title="域名到IP的转换"></a>域名到IP的转换</h3><p>由于使用单服务器会产生单点故障、拓展性差和距离远近等问题，DNS采用分布式的数据库。</p><p>每个域被划分成一块一块的区域，一个区域内的主机有一个权威名字服务器，权威名字服务器中记录这个区域中每个主机的IP和域名的对应关系，找到权威名字服务器就找到了这个区域所有主机域名和IP的对应关系。同时，每个ISP都有一个本地服务器</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20210507221622319.png" alt=""></p><p>DNS服务器以资源记录（RR格式）的方式记录域名和IP的对应关系</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型名称</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">Domain_name</td><td style="text-align:center">域名</td></tr><tr><td style="text-align:center">Ttl</td><td style="text-align:center">生存时间(权威，缓冲记录)</td></tr><tr><td style="text-align:center">Class</td><td style="text-align:center">对于Internet，值为IN</td></tr><tr><td style="text-align:center">Value</td><td style="text-align:center">可以是数字，域名或ASCII串</td></tr><tr><td style="text-align:center"><strong>Type</strong></td><td style="text-align:center">见下表</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">Name</th><th style="text-align:center">Value</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center">主机</td><td style="text-align:center">IP地址</td></tr><tr><td style="text-align:center">CNAME</td><td style="text-align:center">规范名别名</td><td style="text-align:center">规范名</td></tr><tr><td style="text-align:center">NS</td><td style="text-align:center">域名</td><td style="text-align:center">该域名的权威服务器域名</td></tr><tr><td style="text-align:center">MX</td><td style="text-align:center">邮件服务器别名</td><td style="text-align:center">邮件服务器规范名</td></tr></tbody></table></div><p>域名解析有以下步骤</p><ul><li>域在DNS缓存中或在就在该区域中：直接访问这个区域的本地DNS服务器就可以得到IP地址</li><li>域不在缓存中或该区域中：联系根名字服务器顺着根 -&gt; TLD 一直找到权威名字服务器</li></ul><blockquote><p>通过缓存可用提高效率，缓存中每个记录有TTL来实现数据更新</p></blockquote><p>这种查询分为迭代查询和递归查询两种</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210507223553.png" alt=""></p><blockquote><p>递归查询问题是根服务器负担过大</p></blockquote><h3 id="DNS的维护"><a href="#DNS的维护" class="headerlink" title="DNS的维护"></a>DNS的维护</h3><p>DNS的请求和响应报文格式相同：</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210507224547.png" alt=""></p><h2 id="互联网视频服务"><a href="#互联网视频服务" class="headerlink" title="互联网视频服务"></a>互联网视频服务</h2><p>随着因特网视频的火热，需要为成千上万的人提供并行的视频播放服务，这时候需要解决两个问题</p><ul><li>同时向超大规模的用户提供并行的服务（告示文件+域名解析重定向+CDN内容靠近客户）</li><li>不同的用户，处理数据的能力不同（DASH协议）</li></ul><p>CDN就是来解决着两个问题的</p><h3 id="DASH协议"><a href="#DASH协议" class="headerlink" title="DASH协议"></a>DASH协议</h3><p>Dynamic Adaptive Streaming over HTTP，经HTTP的动态适应流。用来解决第二个问题的</p><ol><li>对服务器的每个视频，把视频写成一块一块的，然后处理成各个不同清晰度的版本。通过告示文件提供各个版本的URL。</li><li>客户端根据网络情况动态的请求不同清晰度的版本。 </li></ol><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>由于单服务器有 <strong>单点故障、服务器到客户端跳数多、网络重复流量多</strong>，因此采用CDN的服务。</p><p>CDN在全球部署服务器，视频提供商购买CDN的服务，预先将视频缓存到CDN的服务器上。用户通过域名的重定向，访问离用户最近的缓存节点，从而实现加速。</p><blockquote><p>CDN部署服务器有两种策略</p><ul><li><strong>深入</strong>，CDN在local ISP的附近部署缓存节点。跳数少，用户享受服务好，但是服务器多，维护成本高</li><li><strong>邀请做客</strong>，在少数一些关键的地方设置缓存节点</li></ul></blockquote><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210508224817.png" alt=""></p><h2 id="套接字编程"><a href="#套接字编程" class="headerlink" title="套接字编程"></a>套接字编程</h2><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210510220523.png" alt=""></p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210510221254.png" alt=""></p><blockquote><p>cad 和 sad 是两个结构体，里面放着 IP 和端口号，cad是客户端的，sad是服务器的</p></blockquote><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>传输层就只有两个协议了，TCP和UPD，这一章的重点是TCP保证数据传输可靠的原理</p><p>传输层的服务是保证应用进程之间的逻辑通信，而网络层的服务是保证主机之间的逻辑通信，而这样的逻辑通信往往是不可靠的。传输层就是要通过自己把不可靠的服务变为可靠的服务。</p><blockquote><p>提供了<strong>进程的区分</strong>，<strong>加强了网络层的服务</strong></p></blockquote><p>有一个很好的例子</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">应用报文</span>=<span class="hljs-string">信件上的字符</span><br><span class="hljs-string">进程=堂兄弟姐妹</span><br><span class="hljs-string">主机=家庭</span><br><span class="hljs-string">运输层协议=把家里的信分给个人</span><br><span class="hljs-string">网络层协议=邮政服务</span><br></code></pre></td></tr></table></figure><h2 id="传输层多路复用-解复用"><a href="#传输层多路复用-解复用" class="headerlink" title="传输层多路复用/解复用"></a>传输层多路复用/解复用</h2><p><strong>多路复用 </strong>就是发送方应用层给传输层很多不同的Socket，传输层把Socket对应的IP和端口号封装在头部生成报文段，从而可以统一通过网络层发送的过程。</p><blockquote><p>多个应用都采用 TCP 或 UDP 传输数据</p></blockquote><p><strong>多路分解（解复用）</strong> 就是接收方传输层从报文中提取IP和端口号，把报文信息交给对应的应用进程</p><blockquote><p>数据解封装，区分应用进程</p></blockquote><h3 id="TCP多路复用解复用"><a href="#TCP多路复用解复用" class="headerlink" title="TCP多路复用解复用"></a>TCP多路复用解复用</h3><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210511220138.png" alt=""></p><p>TCP 的 Socket 是一个包含源IP，源端口，目标IP，目标端口的一个四元组，因此只要其中一个不同，就是不同的Socket，分发给不同的应用进程</p><h3 id="UDP多路复用解复用"><a href="#UDP多路复用解复用" class="headerlink" title="UDP多路复用解复用"></a>UDP多路复用解复用</h3><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210511220005.png" alt=""></p><p>UDP 的 Socket 是 本地 IP，本地端口的二元组</p><h2 id="UDP-1"><a href="#UDP-1" class="headerlink" title="UDP"></a>UDP</h2><p>User Datagram Protrol。UDP就是在 IP 的基础上加了多路复用解复用的功能和校验和的功能，其他基本上和 IP 的一样。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>不会建立连接（建立连接有额外的延时）</li><li>简单</li><li>报文头部开销少</li><li>无拥塞控制和流量控制，可以尽可能快的发送数据</li></ul><h3 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h3><p>就8个字节，4个字段。每个字段两个字节，分别是：目标IP，目标端口，长度和校验和</p><h3 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h3><p>校验和的目的就是将报文段的内容看成 16bit 的数字，然后这些数字和校验和相加后，每一位都要是1</p><blockquote><p>校验和的计算：将报文段看成 16bit 的整数加起来，最高位进位了则回卷（在结果的最低位加1）。得到的数字取反就是校验和</p></blockquote><h2 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h2><p>传输模型如下</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210524151830.png" alt=""></p><h3 id="rdt1-0"><a href="#rdt1-0" class="headerlink" title="rdt1.0"></a>rdt1.0</h3><p>假设：网络层提供的服务是可靠的（不出错，不丢失）</p><p>实现：此时只需要封装解封装就可以了，只起到一个区分应用进程的作用</p><h3 id="rdt2-0"><a href="#rdt2-0" class="headerlink" title="rdt2.0"></a>rdt2.0</h3><p>假设：传输的数据可能出错</p><p>实现：增加 <strong>差错检测</strong>、<strong>接收方反馈</strong> 和 <strong>重传</strong></p><p>问题：没有考虑反馈出错的可能性</p><h3 id="rdt2-1"><a href="#rdt2-1" class="headerlink" title="rdt2.1"></a>rdt2.1</h3><p>实现：增加序号</p><blockquote><p>rdt2.2 ：把<strong>NAK</strong>变为了<strong>ACK+序号</strong>的机制</p></blockquote><h3 id="rdt3-0"><a href="#rdt3-0" class="headerlink" title="rdt3.0"></a>rdt3.0</h3><p>假设：传输的数据既可能出错，又可能丢失</p><p>实现：增加超时重传机制</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210524154505.png" alt=""></p><h3 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h3><p>rdt3.0的是停止转发协议。发一下停一下，效率比较低。然后通过设置缓冲窗口，可以用流水线的方式来提高效率.</p><p>就是在未经确认的情况下，连续发送多个分组。</p><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">发送窗口</th><th style="text-align:center">接收窗口</th></tr></thead><tbody><tr><td style="text-align:center">停止转发</td><td style="text-align:center">= 1</td><td style="text-align:center">= 1</td></tr><tr><td style="text-align:center">GBN</td><td style="text-align:center">&gt; 1</td><td style="text-align:center">= 1</td></tr><tr><td style="text-align:center">SR</td><td style="text-align:center">&gt; 1</td><td style="text-align:center">&gt; 1</td></tr></tbody></table></div><blockquote><p>发送窗口的大小就是未经确认分组的数量</p></blockquote><h4 id="GBN协议"><a href="#GBN协议" class="headerlink" title="GBN协议"></a>GBN协议</h4><p>回退N步协议（Go Back N）</p><p>对于发送方，一次性的把发送窗口中的所有的数据全部发送出去，并且缓存不抛弃，然后等待接收方的反馈。</p><ul><li>收到接收方的接收成功的数据：把成功的那个数据包和它之前的标记为已发送，然后抛弃掉，后面的数据包进入发送窗口，向接收方发送</li><li>接收超时：把发送窗口中的所有发送未确认的数据包全部依次发送给接收方</li></ul><blockquote><p>累计确认</p></blockquote><p>对于接收方：只能顺序的接收分组</p><ul><li>接收到正常分组：向发送方发送ACK对应序号</li><li>收到重复分组，或者不是接收方正在等待的分组：抛弃，并发送之前的确认信号</li></ul><blockquote><p>序号是0，1，2，3，4：如果2出错了，即使3，4正常收到了也丢弃掉</p></blockquote><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210524162249.png" alt=""></p><blockquote><p>其中的2，4号数据传过去了但是抛弃掉了，就很浪费</p></blockquote><h4 id="SR协议"><a href="#SR协议" class="headerlink" title="SR协议"></a>SR协议</h4><p>选择重传协议（Selective Repeat）</p><p>由于接收窗口也可以缓存了，那么就可以乱序的接受分组了。另外，接收方的确认也不再是累计确认，而是收到一个发送对应的确认。</p><p>对于接收方，分组只对没有收到确认回复的分组重新发送</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210524163039.png" alt=""></p><div class="table-container"><table><thead><tr><th style="text-align:center">项目</th><th style="text-align:center">GBN</th><th style="text-align:center">SR</th></tr></thead><tbody><tr><td style="text-align:center">优点</td><td style="text-align:center">简单，占用资源少</td><td style="text-align:center">出错时重传代价大</td></tr><tr><td style="text-align:center">缺点</td><td style="text-align:center">一旦出错，回退N步，代价大</td><td style="text-align:center">复杂，占用资源多</td></tr><tr><td style="text-align:center">用途</td><td style="text-align:center">出错率很低的情况</td><td style="text-align:center">链路容量大的情况</td></tr></tbody></table></div><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center">校验和</td><td style="text-align:center">确认分组是否正确</td></tr><tr><td style="text-align:center">肯定确认</td><td style="text-align:center">确认分组是否收到</td></tr><tr><td style="text-align:center">序号</td><td style="text-align:center">检查重复</td></tr><tr><td style="text-align:center">定时器</td><td style="text-align:center">处理丢失</td></tr><tr><td style="text-align:center">流水线</td><td style="text-align:center">解决停止转发效率低的问题</td></tr></tbody></table></div><h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><h3 id="拥塞原因与代价"><a href="#拥塞原因与代价" class="headerlink" title="拥塞原因与代价"></a>拥塞原因与代价</h3><p>原因是主机向网络核心发送的数据过多，超过了网络核心所能承载的能力</p><p>代价：</p><ul><li>当分组的到达速率接近链路容量时，路由器的排队延时会趋向于无限大</li><li>网络延时很大，造成丢包严重。</li><li>发送包在遇到大的时延，会发送重复的副本，降低链路的利用率</li><li>分组丢失使得上游路由器的传输容量浪费了</li></ul><h3 id="拥塞控制手段"><a href="#拥塞控制手段" class="headerlink" title="拥塞控制手段"></a>拥塞控制手段</h3><ul><li><p>端到端的拥塞控制</p><p>TCP就是使用的这种，端系统根据自己的探知，判断网络的拥塞情况。</p></li><li><p>网络辅助的流量控制</p><p>网络核心向发送网络拥塞的状态信息给端系统</p></li></ul><h2 id="TCP-1"><a href="#TCP-1" class="headerlink" title="TCP"></a>TCP</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>可靠保序字节流，流水线，流量控制，拥塞控制；面向连接，全双工</li></ul><blockquote><p>单工：$A\rightarrow B$</p><p>双工：$A\leftrightarrow B$</p><p>全双工：$A\rightleftharpoons B$</p></blockquote><h3 id="段结构"><a href="#段结构" class="headerlink" title="段结构"></a>段结构</h3><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210524165127.png" alt=""></p><ul><li><p>TCP的序号：TCP的序号发送端和接收端是不同的，一般来说这个序号是一个随机的序号。这个序号表示PDU首字符在字节流中的位置。确认是对下一个字节的期待（顺序收到的字节的最后一个+ 1）。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210524195953.png" alt=""></p><blockquote><p>TCP连接在连接握手阶段两台主机会事先交换各自的序列号</p><p>发送端和接收端是不同的原因：这两个不同目的是为了防止老的TCP连接的数据对新TCP连接的数据造成干扰</p></blockquote></li></ul><h3 id="超时时间的设置"><a href="#超时时间的设置" class="headerlink" title="超时时间的设置"></a>超时时间的设置</h3><script type="math/tex; mode=display">\text{TimeoutInterval=EstimateRTT+4DevRTT}\\\text{EstimateRTT}=(1-\alpha)\text{EstimateRTT}+\alpha \text{SampleRTT}\\\text{DevRTT}=(1-\beta)\text{DevRTT}+\beta\text{|\text{SampeRTT-DevRTT}|、}</script><p>$\alpha,\beta$ 是任取的，推荐 $\alpha=0.125.\beta=0.25$ </p><p>公式不重要。主要是超时时间的设置是一个平均数+4倍的方差的形式。然后这个平均数是指数移动平均，随着时间的增加，前面的数据会越来越不重要。</p><h3 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h3><p>TCP用的是GBN和SR的混合，它和GBN一样是采用的累计确认的方式。</p><p>它还增加了 <strong>快速重传</strong>（在超时定时器中断之前，如果连续3个冗余的ACK的，它会立即重传）</p><p>同时当它还会 <strong>延迟确认</strong>，当对另一个按序报文段的到达最多等待500ms。如果下一个报文段在这个时间间隔内到达，立即发第二个的ACK。没有到达，则发送一个自己的ACK。</p><p>还有超时事件发生时，超时间隔会加倍。</p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>目的：防止淹没接收方</p><p>手段：将接收窗口以捎带的方式发送给发送端，发送端发送的数据始终小于接收方的缓存空间。</p><h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p>连接管理就两个部分，连接的建立和拆除</p><h4 id="3次握手"><a href="#3次握手" class="headerlink" title="3次握手"></a>3次握手</h4><p>因为发送端和接收端的序号是不同的，3次次握手主要是为了交换这个序号，并且做确认。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210524205456.png" alt=""></p><blockquote><p>如果这两边的序号相同，就只需要两次握手了，但是两次握手会产生两个问题，第一个是半连接（只在服务器维护了连接），还有一个是老数据当新数据接收了</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/image-20210524203925071.png" alt=""></p></blockquote><h4 id="4次挥手"><a href="#4次挥手" class="headerlink" title="4次挥手"></a>4次挥手</h4><p>采用对称式的设计，有两军问题，靠定时器凑活解决</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210524211756.png" alt=""></p><blockquote><p>这里等 2MSL 是为了防止服务器的FIN丢失，重传的那一段，保证客户端发送的最后一个ACK报文能够到达服务器。同时，可以防止老的数据</p></blockquote><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><h4 id="探知"><a href="#探知" class="headerlink" title="探知"></a>探知</h4><ul><li>超时定时器超时</li><li>收到3个冗余的分组</li></ul><h4 id="行为"><a href="#行为" class="headerlink" title="行为"></a>行为</h4><p>发送端需要维护一个发送窗口，和一个发送窗口警戒值的两个值。</p><ul><li>发送端超时定时器超时：发送窗口变为1，发送窗口警戒值变为原来的一半</li><li>收到3个冗余的分组：发送窗口变为原来的一半+3MSS，发送窗口警戒值变为发送窗口的一半 <strong>快速恢复阶段</strong></li><li>正常情况：<ul><li>发送窗口 &lt; 发送窗口警戒值：每发送一个发送窗口就翻倍 <strong>慢启动阶段</strong></li><li>发送窗口 &gt; 发送窗口警戒值：每发送一个发送窗口 + 1 <strong>拥塞避免阶段</strong></li></ul></li></ul><blockquote><p>MSS 最大报文长度，一般是1460字节. 他需要保证加上一个TCP和一个IP的头部（20+20）后能在链路中传输（1500字节）</p></blockquote><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210525112748.png" alt=""></p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>网络层提供的服务主要是主机到主机之间的通讯。</p><p>网络层有两大功能：<strong>路由</strong>、<strong>转发</strong></p><ul><li>路由：路由器相互配合，传递路由信息，然后根据路由选择算法来计算路由表。</li><li>转发：路由器收到一个分组后，把分组缓存下来，匹配分组的字段，根据路由表决定这个分组应该从那个端口发出去</li></ul><p>网络层的协议包括 IP 协议、路由选择协议和 ICMP协议</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>由于网络层本身十分的复杂，根据网络层两个重要功能，网络层可以被分为两个部分</p><ul><li>数据平面：负责实现转发的功能，决定从输入路由器的数据报要输出到那个输出链路。</li><li>控制平面：负责实现路由的功能，控制数据报从源主机到目标主机的传输路径。</li></ul><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210526132854.png" alt=""></p><p>网络层的这两个平面有两种实现方式</p><ul><li>传统方式<ul><li>数据平面和控制平面竖直的集成在每一个设备中（路由器）</li><li>路由器分布式的计算路由表</li></ul></li><li>SDN通用转发方式(Software Define Network)<ul><li>控制平面与数据平面分离，在不同的设备上实现</li><li>SDN控制器上的网络层应用集中式的计算流表，SDN控制器向路由器下发流表</li><li>路由器根据分组的多个字段匹配流表，进行转发</li></ul></li></ul><h2 id="数据平面"><a href="#数据平面" class="headerlink" title="数据平面"></a>数据平面</h2><h3 id="路由器原理"><a href="#路由器原理" class="headerlink" title="路由器原理"></a>路由器原理</h3><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210526111550.png" alt=""></p><p>路由器由三个部分组成：输入端口、交换机构、输出端口、路由处理器</p><ul><li><p>输入端口和输出端口都实现物理层、链路层和网络层的功能。其中输入端口负责查询路由表，输出端口涉及到分组调度</p><blockquote><p> 为了防止堵塞的情况，输入端口和输出端口的都有缓存，以实现排队</p></blockquote></li><li><p>交换机构有三种实现方式：经内存交换、经总线交换、经互联网络交换</p><blockquote><p>这个互联网络是电路上的一种称呼，与本文的互联网概念完全不同</p></blockquote></li><li><p>路由处理器协调各个部分的工作</p></li></ul><h3 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h3><p>IP协议为上层提供的服务是尽力而为的一种服务(可能会丢包、乱序、重复)</p><h4 id="报文格式-1"><a href="#报文格式-1" class="headerlink" title="报文格式"></a>报文格式</h4><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210526133629.png" alt=""></p><blockquote><p>分片重组的原因：分组的大小超过了链路的MTU(最大传输单元)</p><p>分片的实现：IP协议的报文中有 <code>identifier,flags,fragment offset</code> 三个值。<code>identifier</code> 用于表示这些分片所属的分组，<code>flag</code> 判断是否是最后一个分片，<code>fragment offset</code> 表示这个分片数据的首字节在整个分组中的偏移量。</p></blockquote><h4 id="IPv4编址"><a href="#IPv4编址" class="headerlink" title="IPv4编址"></a>IPv4编址</h4><p>IP地址：主机或路由器网络接口的标识，分为网络部分和主机部分</p><p>网络层为了提高效率，有 <strong>路由汇聚</strong> 的效应：连续子网前缀的子网可达信息可以做汇聚，以减少路由器路由表计算胡传输。(同一个子网的前缀相同，这样，他们就可以通过一个IP计算可达信息)</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210526150228.png" alt=""></p><p>子网：</p><ul><li>子网内的主机通信不需要借助路由器，链路层交换机即可</li><li>子网内主机的网络部分(子网前缀)相同</li></ul><p>子网掩码</p><p>子网掩码和IP地址配合使用，子网掩码为 1 表是这个位在IP地址中是网络位。</p><p>IP地址分类</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210526144028.png" alt=""></p><blockquote><p>其中 D 类是多播，E类是预留的IP地址</p></blockquote><h4 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h4><p>上网的主机通过DHCP获取 IP、子网掩码、默认网关和 Local Name Server</p><blockquote><p> 主机加入互联网后，向同一子网的所有主机广播 DHCP发现报文。同一子网的多个 DHCP 服务器收到报文后，广播DHCP提供报文，并在报文中附上自己的IP。主机收到 DHCP提供报文后</p></blockquote><h4 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h4><p>网络地址转换，工作方式如下</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210526150617.png" alt=""></p><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>从32位变为128位</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210526151510.png" alt=""></p><p>IPv4到IPv6的迁移：隧道</p><h3 id="SDN"><a href="#SDN" class="headerlink" title="SDN"></a>SDN</h3><p>工作原理</p><ul><li><p>模式匹配 + 行动</p><blockquote><p>SDN一次匹配报文的多个字段(传统模式下只匹配目标IP一个字段)，行动除了传统的转发之外，还有泛洪、阻塞和修改字段等等</p></blockquote></li><li><p>分组按照各级字段匹配流表，然后按照响应的行为动作执行</p></li><li>按照优先级进行判断，之后统计计数</li></ul><p>优点</p><ul><li>集中在控制器上实现逻辑，使得网络可编程，实现复杂网络的功能</li><li>形成开发生态（控制器，网络应用在一个框架下协作）</li><li>分组交换机按照流表转发，十分便宜，通用，便于升级</li></ul><h2 id="控制平面"><a href="#控制平面" class="headerlink" title="控制平面"></a>控制平面</h2><p>控制平面的功能是<strong>路由</strong>：按照某种指标，找到源到目标的较好路径</p><p>网络层提供主机到主机的数据传输，或者说是 IP 到 IP 的数据传输，但是 IP 数量太大了，为每一个 IP 提供路由成本太高，现实是将IP汇集，实现从子网到子网的数据传输，这样大大减少了网络路由节点的数量。</p><h3 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h3><h4 id="链路状态算法-LS"><a href="#链路状态算法-LS" class="headerlink" title="链路状态算法 (LS)"></a>链路状态算法 (LS)</h4><p>链路状态算法是一种全局的、集中式的算法。该算法在计算之前就拥有所有节点之间的联通性和链路开销信息。</p><p>具体过程：</p><ol><li>发现相邻节点，获取对方IP</li><li>测量相邻节点代价</li><li>组装LS分组，描述相邻节点之间代价</li><li>以泛洪的方式扩散分组到其他路由器。路由器获得各节点LS分组，从而得到整个网络拓扑。</li><li>运用 Dijkstra 算法找出最短路径</li></ol><blockquote><p>Dijkstra 算法回顾：<a href="https://www.bilibili.com/video/BV1ts41157Sy">https://www.bilibili.com/video/BV1ts41157Sy</a></p><p>链路状态法会出现震荡的现象，当一条路径代价是0的时候，所有用LS算法的路由器都将将分组指向这条链路，从而使得这条链路代价增大。</p></blockquote><h4 id="距离向量算法-DV"><a href="#距离向量算法-DV" class="headerlink" title="距离向量算法 (DV)"></a>距离向量算法 (DV)</h4><p>距离矢量算法是一种局部的、分散式的算法。该算法维护自己和邻居节点之间的连通性和和链路开销信息。算法以迭代的方式最终到目标。</p><p>每个节点维护一个距离矢量(表)，上面记录它到所有其他节点的下一跳和代价值。它和邻居节点定期交换 DV</p><p>DV算法使用 Bellman-Ford 公式不断迭代生成到所有目标的代价和响应的下一跳。</p><script type="math/tex; mode=display">d_x(y)=\min\{c(x,v),d_v(y)\}</script><blockquote><p>从 x 到 y 的代价 $d_x(y)$ = 从 x 到它邻居 v 的代价 $c(x,v)$ +  从 v 到 y 的代价</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210527165007.png" alt=""></p></blockquote><p>DV算法具有好消息传的快，坏消息传的慢的特点。</p><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ul><li>报文复杂性：LS &gt; DV</li><li>收敛速度：LS &gt; DV</li><li>健壮性：LS &gt; DV</li></ul><h3 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h3><p>由于互联网过于复杂，实际的情况是采用层次化的结构。互联网被分为一个个 <strong>自治系统 (AS)</strong>  ，他们之间有一个路由选择协议。各个自治系统中的路由器也有自己的路由选择协议。因此实际的路由选择协议被分为 <strong>内部网关协议</strong> 和 <strong>外部网关协议</strong> 。</p><blockquote><p>层次化解决了规模性问题和管理性问题</p><p>规模性：路由设备数量大，路由选择信息的通信开销十分巨大</p><p>管理性：ISP希望按照自己的意愿运行路由器，同时希望对外界隐藏细节</p></blockquote><h4 id="内部网关协议"><a href="#内部网关协议" class="headerlink" title="内部网关协议"></a>内部网关协议</h4><p>自治系统内一个主机到任意一个主机的路由选择协议，<strong>比较关注效率和性能</strong></p><ul><li>OSPF开放最短路优先：基于LS算法</li></ul><h4 id="外部网关协议"><a href="#外部网关协议" class="headerlink" title="外部网关协议"></a>外部网关协议</h4><p>自治区之间的路由选择协议，<strong>比较关注经济策略和政治策略</strong></p><p>外部网关协议只有一个，就是 <strong>BGP</strong> 边界网关协议。BGP协议将因特网中数以前千计的ISP连接起来，基于DV算法。</p><p>BGP协议中，每个AS有一个连接其他AS的网关，这个网关既参与内部网关的运算，又参与外部网关的运算。该网关将自身AS中的每一个设备进行路由聚集，通报给其他AS中的网关。其他网关收到消息后，发送给这个自治区内部的所有路由器</p><p>BGP在 DV 算法的基础上增加了一个 AS-PATH 字段，这个字段包含了已经走过的AS，用于进行环路检测。</p><h3 id="SDN控制平面"><a href="#SDN控制平面" class="headerlink" title="SDN控制平面"></a>SDN控制平面</h3><p>关键特征：</p><ul><li>数据平面与控制平面分离</li><li>基于流的 匹配 + 行动模式</li><li>控制平面功能在数据交换设备外实现</li><li>网络可编程</li></ul><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210528112352.png" alt=""></p><h3 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3><p>作用：主机和路由器之间沟通网络层消息。常见的消息有差错报告（404这些的）</p><h1 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h1><p>链路层提供端到端的通信</p><blockquote><p>网络层相当于是从 武汉 到 宁波，链路层相当于是其中的 公交车-高铁-公交车-走路 其中一段。</p></blockquote><p>链路有两种类型的信道，一种是点到点的广播式的信道（多点连接），另外一种是多点连接的通信链路</p><blockquote><p>多点连接的方式适合于局域网，点到点的连接方式适合于广域网</p></blockquote><p>链路层在主机和路由器上的网卡实现</p><h2 id="链路层提供服务"><a href="#链路层提供服务" class="headerlink" title="链路层提供服务"></a>链路层提供服务</h2><ul><li>成帧（封装解封装）</li><li>链路访问控制</li><li>检错和纠错</li><li>相邻节点进行可靠数据传输</li><li>流量控制：使发送方和接收方的速度匹配</li><li>全双工和半双工服务</li></ul><blockquote><p>以上是一般化的链路层服务，对电缆等一些本来就很可靠的链路就不需要可靠数据传输，像 WiFi 这样的需要。</p></blockquote><h2 id="差错检测和纠正"><a href="#差错检测和纠正" class="headerlink" title="差错检测和纠正"></a>差错检测和纠正</h2><h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p>发送方附加一个比特，使得整个数据比特1的个数和为偶数/奇数</p><p>还可以将数据分组，形成二维偶校验</p><h3 id="校验和方法"><a href="#校验和方法" class="headerlink" title="校验和方法"></a>校验和方法</h3><p>将数据以 k 位为一组作为一个整数，然后把整个帧的所有整数加起来，用得到的和作为差错检测比特。</p><h3 id="CRC（循环冗余检测）"><a href="#CRC（循环冗余检测）" class="headerlink" title="CRC（循环冗余检测）"></a>CRC（循环冗余检测）</h3><p>这个比较重要，CRC主要应用到了异或。发送方的帧给接收方后要恰好被能被 $G$ 整除</p><script type="math/tex; mode=display">(D\ll r)\ \text{XOR}\ R=nG</script><blockquote><p>$D$ 表示要发送的数据比特，$R$ 表示跟在 $D$ 后面的 $r$ 位CRC 比特。国际标准规定了 $G$ 的值。</p></blockquote><p>因此发送方只需要在原有的数据 $D$ 上增加</p><script type="math/tex; mode=display">R=(D\ll r)\%G</script><p>的比特位即可</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">|</span>&lt;--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">d</span> <span class="hljs-comment">比特</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span>&gt;<span class="hljs-comment">|</span>&lt;--<span class="hljs-comment">d</span> <span class="hljs-comment">比特</span>--&gt;<span class="hljs-comment">|</span><br><span class="hljs-comment">┏</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">┯</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">┒</span><br><span class="hljs-comment">┃D:</span> <span class="hljs-comment">被发送的数据比特┃</span> <span class="hljs-comment">R:</span> <span class="hljs-comment">CRC比特</span> <span class="hljs-comment">┃</span><br><span class="hljs-comment">┗</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">┺</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">┛</span><br></code></pre></td></tr></table></figure><blockquote><p>CRC 能检测数据比特小于 r + 1 位的差错，对大于 r + 1 位的有 $1-0.5^r$ 概率被检测到</p></blockquote><h2 id="多路访问协议"><a href="#多路访问协议" class="headerlink" title="多路访问协议"></a>多路访问协议</h2><p>就是多点连接的协议，还有一种是单点访问协议，那个比较简单，就完成封装解封装和校验就可以了。多点访问主要需要解决的问题是冲突（多个点一起发送）。有 3 种方式</p><ul><li>信道划分：将信道划分为时分、频分和码分</li><li>随机访问：允许冲突的产生，并且检测冲突。遇到冲突了就等待一会重新发送</li><li>轮流</li></ul><h3 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h3><ul><li>TDMA</li><li>FDMA</li><li>CDMA</li></ul><h3 id="随机接入协议"><a href="#随机接入协议" class="headerlink" title="随机接入协议"></a>随机接入协议</h3><h4 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h4><p><strong>具有碰撞检测的载波监听多路访问</strong>（Carrier Sense Multiple Access with Collision Detection），用于局域网。</p><p>主要特点是</p><ul><li><p>发送之前先监听（<strong>载波监听</strong>）：如果此时链路中有一小段时间没有传输数据，才开始发送数据</p></li><li><p>如果于其他人在同时说话，则停止（<strong>碰撞检测</strong>）：传输时一直监听信号，如果检测到另一个节点传输了干扰帧，就停止传输</p><blockquote><p>中止传输后，发送方会随机的选择一个时间发送。这里采用 <strong>二进制指数退避</strong> 的方法进行：当此时连续发生了 $n$ 次碰撞，就在 $\{0,1,2,\cdots,2^n-1\}$ 中随机选择一个数设为等待时间</p></blockquote></li></ul><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20210602142847.png" alt=""></p><h4 id="CSMA-CA"><a href="#CSMA-CA" class="headerlink" title="CSMA/CA"></a>CSMA/CA</h4><p>用于无线局域网。由于无线局域网有 信号强度随距离递减、有其他源的干扰、多路径传播 等特点，和有限局域网使用同样的逻辑就不太适用了。无线局域网还有隐藏终端和信号太弱无法检测的问题</p><p>无线局域网使用的是 <strong>带碰撞避免的CSMA/CA</strong> （CSMA with Collision Avoidance）</p><ul><li>当发送方检测到信道空闲时，发送方会等待一个短时间后，进行发送，无论是否冲突把帧一次性发完。发送完毕后等待接收方的确认。<ul><li>收到确认：如果要发下一帧，执行下面的操作（发送方检测到信道正在传输时对应的操作）</li><li>没收到确认：执行下面的操作（发送方检测到信道正在传输时对应的操作）</li></ul></li><li>当发送方检测到信道正在传输时，发送方会选择一个随机的等待时间，信道空闲的时候等待时间递减。当等待时间减少到 0 时，发送整个数据帧</li></ul><p>CSMA/CA 还有一个可选项：就是遇到大文件要传输时，先发送一个很短的 RTS 帧。接收方收到后向其邻居发送 CTS 帧。发送方收到后等一段时间开始发送，接收方的邻居收到后延迟发送。</p><h3 id="轮流协议"><a href="#轮流协议" class="headerlink" title="轮流协议"></a>轮流协议</h3><ul><li>令牌传递协议</li></ul><h2 id="交换局域网"><a href="#交换局域网" class="headerlink" title="交换局域网"></a>交换局域网</h2>]]></content>
    
    
    <categories>
      
      <category>计算机相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵论笔记</title>
    <link href="/2020/11/22/HUST/MatrixTheorem/"/>
    <url>/2020/11/22/HUST/MatrixTheorem/</url>
    
    <content type="html"><![CDATA[<p>矩阵论就是线性代数Plus，然后线性代数就是把一堆矩阵分解为一些简单的矩阵</p><span id="more"></span><h1 id="线性代数复习"><a href="#线性代数复习" class="headerlink" title="线性代数复习"></a>线性代数复习</h1><p>Review of Linear Algebra</p><h2 id="常见的分解"><a href="#常见的分解" class="headerlink" title="常见的分解"></a>常见的分解</h2><p>Basic</p><ul><li>$A=CR=\left[ \begin{array}{c}\\\\\end{array} \right] \left[ \begin{matrix}&amp;\\\end{matrix} \right]$ ：将 A 分解为所有列都不相关的矩阵 C</li><li>$A=LU=\left[\begin{matrix}{}\diagdown\ 0\\\ \ \ \ \ \ \diagdown\\\end{matrix} \right]\left[ \begin{matrix}{}\diagdown \ \ \ \ \ \\0 \ \diagdown\\\end{matrix} \right]$ ：将 A 分解为上三角矩阵 U 和下三角矩阵 L </li><li>$A=QR=\left[ \begin{matrix}|&amp;|\\ \boldsymbol {q_1}&amp;\boldsymbol{q_n} \\ |&amp;|\end{matrix} \right]\left[ \begin{matrix}{}\diagdown \ \ \ \ \ \\0 \ \diagdown\\\end{matrix} \right]$ ：将 A 分解为正交矩阵 Q ，其实跟第一个是一样的</li><li>$S=Q\Lambda Q^T,Q^T=Q^{-1}$ ：将一个对称矩阵 S 分解为正交矩阵 Q 和特征值 $\Lambda$ 组成的矩阵</li><li>$A=X\Lambda X^T$：将方阵 A 分解为特征向量组成的矩阵 X 和特征值 $\lambda$ 组成的矩阵 $\Lambda$</li><li>$A=U\varSigma V^T$：将矩阵 A 分解为正交向量组组成的矩阵 $U,V$ （$U^TU=V^TV=I$）和奇异值 $\sigma=\sqrt{\lambda(A^TA)}$ 组成的矩阵 $\varSigma$</li></ul><h2 id="矩阵的列空间"><a href="#矩阵的列空间" class="headerlink" title="矩阵的列空间"></a>矩阵的列空间</h2><p>The column space of Matrixes</p><p>A的列空间 $C(A)$ ：A中所有列向量的线性组合</p><h3 id="A-CR"><a href="#A-CR" class="headerlink" title="$A=CR$"></a>$A=CR$</h3><p>举例</p><script type="math/tex; mode=display">A=\begin{bmatrix}1&4&5\\3&2&5\\2&1&3\end{bmatrix}=\begin{bmatrix}1&2\\3&2\\2&1\end{bmatrix}\begin{bmatrix}1&0&1\\0&1&1\end{bmatrix}=CR</script><p>对于一个 $m\times n$ 的矩阵 A，如果 A 中有 r 个线性无关的列向量，则可以分解为 $m\times r,r\times n$ 的两个矩阵 C 和 R。</p><ul><li><p>C 的列向量就是那 r 个线性无关的列向量</p></li><li><p>R 的行向量包含 $r\times r$ 的单位矩阵 $I$ -&gt; R 也线性无关</p></li></ul><p>对 $A\boldsymbol x=\boldsymbol 0$ 来说，有 $n-r$ 个线性无关的解</p><ul><li>秩为1的矩阵：如果 A 中所有的列都是第一列的倍数，那么 A 就可以分解为一个列向量和一个行向量</li></ul><h2 id="线性代数一览"><a href="#线性代数一览" class="headerlink" title="线性代数一览"></a>线性代数一览</h2><p>The Big Picture of Linear Algebra</p><h3 id="四个子空间"><a href="#四个子空间" class="headerlink" title="四个子空间"></a>四个子空间</h3><script type="math/tex; mode=display">Ax=\begin{bmatrix}\text{row}1\\\vdots\\\text{row}n\\\end{bmatrix}\begin{bmatrix}\\x\\\\\end{bmatrix}=\begin{bmatrix}0\\\vdots\\0\\\end{bmatrix}=0</script><p>x 在 A 的零空间中，与 A 中的每一个行向量都不相关。$N(A)\perp C(A^T),N(A^T)\perp C(A)$</p><ul><li><p>$N(A)$：所有使 $A\boldsymbol x=\boldsymbol 0$ 的向量张成的空间，$R^n$中维度为 $n-r$ 的空间</p></li><li><p>$C(A^T)$：A行向量张成的空间，$R^n$中维度为 $r$ 的空间</p></li><li><p>$N(A^T)$：所有使得 $\boldsymbol yA^T=\boldsymbol 0$ 的向量张成的空间，$R^m$ 中维度为 $m-r$ 的空间</p></li><li><p>$C(A)$：A列向量张成的空间，$R^m$ 中维度为 $r$ 的空间</p></li></ul><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20201015182427.png" alt=""></p><h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><p>有两种特殊的方法，有时候会算的快一些</p><script type="math/tex; mode=display">B C=\left[\begin{array}{cccc}\mid & \mid & & \mid \\\boldsymbol b_{1} & \boldsymbol b_{2} & \cdots & \boldsymbol b_{n} \\\mid & \mid & & \mid\end{array}\right]\left[\begin{array}{ccc}- & \boldsymbol c_{1}^{*} & - \\- & \boldsymbol c_{2}^{*} & - \\& \vdots & \\- & \boldsymbol c_{n}^{*} & -\end{array}\right]=\boldsymbol b_{1} \boldsymbol c_{1}^{*}+\boldsymbol b_{2} \boldsymbol c_{2}^{*}+\cdots+\boldsymbol b_{n} \boldsymbol c_{n}^{*}</script><script type="math/tex; mode=display">A\left[\begin{array}{cccc}\mid & \mid & & \mid \\\boldsymbol b_{1} & \boldsymbol b_{2} & \cdots & \boldsymbol b_{n} \\\mid & \mid & & \mid\end{array}\right]=\left[\begin{array}{cccc}\mid & \mid & & \mid \\A\boldsymbol b_{1} & A\boldsymbol b_{2} & \cdots & A\boldsymbol b_{n} \\\mid & \mid & & \mid\end{array}\right]</script><h3 id="A-LU"><a href="#A-LU" class="headerlink" title="$A=LU$"></a>$A=LU$</h3><p>LU分解的一大作用就是解方程，这个分解只考虑行向量的加减和数乘运算，如果考虑行的交换，原式需要变为 $PA=LU$</p><p>这个分解来源于解方程 $Ax=b$</p><p>分解方法就是去逐行消元</p><script type="math/tex; mode=display">\begin{aligned}A&=\begin{bmatrix}1\\l_{21}\\\vdots\\l_{n1}\end{bmatrix}\left[\begin{array}{ccc}- & a_{1} & - \\\end{array}\right]+\begin{bmatrix}0&0&0&0\\0\\0&&A_2\\0\end{bmatrix}\\&=\left[\begin{array}{cccc}1 & 0 & 0 & 0 \\\ell_{21} & 1 & & \\\vdots & \vdots & 1 & 0 \\\ell_{n 1} & \ell_{n 2} & \ell_{n 3} & 1\end{array}\right]\left[\begin{array}{ccc} {\text { row } 1 \text { of } A} \\0 & {\text { row } 1 \text { of } A_{2}} \\\vdots & \vdots & \ddots \\0 & 0 & 0 &\quad \text { row } 1 \text { of } A_{n}\end{array}\right]\end{aligned}</script><h3 id="求解-A-boldsymbol-x-boldsymbol-b"><a href="#求解-A-boldsymbol-x-boldsymbol-b" class="headerlink" title="求解$A\boldsymbol x=\boldsymbol b$"></a>求解$A\boldsymbol x=\boldsymbol b$</h3><p>$A\boldsymbol x=\boldsymbol b$ 的通解可以分解为 $A\boldsymbol x =\boldsymbol 0$ 的通解加上 $A\boldsymbol x= \boldsymbol b$ 的特解</p><p>先求解 $A\boldsymbol x=\boldsymbol 0$ 的通解，初等行变换并不会改变矩阵的行空间， $N(A)=N(R)$</p><script type="math/tex; mode=display">A=\left[\begin{array}{lllll}p & p & f & p & f \\\mid & \mid & \mid & \mid & \mid\\\mid & \mid & \mid & \mid & \mid\\\mid & \mid & \mid & \mid & \mid\\\end{array}\right],R=\left[\begin{array}{lllll}\mathbf{1} & 0 & a & 0 & c \\0 & \mathbf1 & b & 0 & d \\0 & 0 & 0 & \mathbf{1} & e \\0 & 0 & 0 & 0 & 0\end{array}\right],\boldsymbol s_1=\left[\begin{array}{c}-a\\-b\\\mathbf1\\0\\\mathbf0\end{array}\right]\boldsymbol s_2=\left[\begin{array}{c}-c\\-d\\\mathbf0\\-e\\\mathbf1\end{array}\right]\\x=c_1\boldsymbol s_1+c_2\boldsymbol s_2</script><p>然后求解 $A\boldsymbol x=\boldsymbol b$ 的特解，$A\boldsymbol x =\boldsymbol b\Rightarrow R\boldsymbol x=\boldsymbol d$</p><h2 id="正交向量"><a href="#正交向量" class="headerlink" title="正交向量"></a>正交向量</h2><p>Orthogonal Vectors</p><ul><li>$Q^T=Q^{-1}$，对于单位正交矩阵，有 $Q^TQ=I$，注意 $QQ^T\ne I$</li><li>$||Q\boldsymbol x||=\boldsymbol x^TQ^TQ\boldsymbol x=\boldsymbol x^T\boldsymbol x=||\boldsymbol x||$</li></ul><h3 id="应用：最小二乘法"><a href="#应用：最小二乘法" class="headerlink" title="应用：最小二乘法"></a>应用：最小二乘法</h3><p>当 $A\boldsymbol x=\boldsymbol b$ 无解，求解 $A^TA\boldsymbol x =A^T\boldsymbol b$ 可以得到最相近的</p><p>最小二乘法是数据很多时的一个曲线拟合，求解使 $\min(||A\boldsymbol x-\boldsymbol b||^2)$ 的 $\boldsymbol x$ ，其中 A 为 $m&gt;n$ 的数据矩阵。然后可以将问题转化为求解 $\boldsymbol b$ 在 $ C(A)$ 上的投影 $\boldsymbol p$ 和 $A\boldsymbol x = \boldsymbol p$</p><ul><li><p>直线上的投影</p><ul><li>$\hat x=(a^Tb)/(a^Ta)$： $a\perp(e=b-p)\Rightarrow a·(b-\hat xa)=0$</li><li>$p=a\hat x=(aa^Tb)/(a^Ta)$</li><li>$p=Pb\Rightarrow P=(aa^T)/(a^Ta)$</li></ul></li><li><p>子空间投影</p><ul><li>$\hat x:A^T(b-A\hat x)=0\Rightarrow A^TAx=A^Tb$</li><li>$p:p=Ax=A(A^TA)^{-1}A^Tb$</li><li>$P:p=Pb\Rightarrow P=A(A^TA)^{-1}A^T$</li></ul></li><li><p>最小二乘法</p></li></ul><h3 id="A-QR-：Grant-Schmidt法"><a href="#A-QR-：Grant-Schmidt法" class="headerlink" title="$A=QR$：Grant-Schmidt法"></a>$A=QR$：Grant-Schmidt法</h3><p>这里是将一个可逆矩阵转化为正交矩阵的方法。</p><p>方法就是把一个个列向量（基向量）减去已经正交化的向量的投影</p><ul><li>$a_1’=a_1,q_1=a_1’/||a_1’||$</li><li>$a_i’=a_i-\frac{a_1^Ta_i}{a_1^Ta_1}a_1-\dots-\frac{a_{i-1}^Ta_i}{a_{i-1}^Ta_{i-1}}a_{i-1},q_i=a_i’/||a_i’||$</li></ul><p>分解如下</p><script type="math/tex; mode=display">A=\left[\begin{array}{c}|&|&|\\a_1 & a_2 & a_3\\|&|&|\end{array}\right]=\left[\begin{array}{c}|&|&|\\q_{1} & q_{2} & q_{3}\\|&|&|\\\end{array}\right]\left[\begin{array}{c}\begin{array}{c}q_{1}^{\mathrm{T}} a_1 \\0\\0\end{array} & \begin{array}{c}q_{1}^{\mathrm{T}} a_2 \\q_{2}^{\mathrm{T}} a_2 \\0\end{array} & \left.\begin{array}{c}q_{1}^{\mathrm{T}} a_3 \\q_{2}^{\mathrm{T}} a_3 \\q_{3}^{\mathrm{T}} a_3\end{array}\right]\end{array}\right.=QR</script><h2 id="特征值与特征向量"><a href="#特征值与特征向量" class="headerlink" title="特征值与特征向量"></a>特征值与特征向量</h2><p>Eigenvalue and Eigenvectors</p><p>线性代数解方程是一大块，特征值与特征向量就是另外一大块内容了。</p><h3 id="S-Q-Lambda-Q-T"><a href="#S-Q-Lambda-Q-T" class="headerlink" title="$S=Q\Lambda Q^T$"></a>$S=Q\Lambda Q^T$</h3><p>概念</p><ul><li><p>对称矩阵：$S=S^T$</p></li><li><p>特征值 $\lambda$ 与特征向量 $\boldsymbol x$ ：$A\boldsymbol x=\lambda\boldsymbol x$</p></li><li><p>所有特征值非负</p></li></ul><p>对于对称矩阵 $S$，有</p><script type="math/tex; mode=display">S\left[\begin{array}{c}|&|&|\\\boldsymbol{q}_{1} & \cdots & \boldsymbol{q}_{n}\\|&|&|\\\end{array}\right]=\left[\begin{array}{c}|&|&|\\\lambda_{1} \boldsymbol{q}_{1} & \cdots & \lambda_{n} \boldsymbol{q}_{n}\\|&|&|\\\end{array}\right]=\left[\begin{array}{c}|&|&|\\\boldsymbol{q}_{1} & \cdots & \boldsymbol{q}_{n}\\|&|&|\\\end{array}\right]\left[\begin{array}{ll}\lambda_{1} \\& \ddots \\&&\lambda_n\end{array}\right]\\SQ=Q\Lambda\Rightarrow S=Q\Lambda Q^{-1}=Q\Lambda Q^{T}</script><p>对称矩阵的特征向量是正交的，证明：</p><ul><li><p>假设有 $S\boldsymbol x=\lambda \boldsymbol x,S\boldsymbol y=\alpha \boldsymbol y,\lambda\ne\alpha$</p></li><li><p>$\boldsymbol x^TS\boldsymbol y=(S^T\boldsymbol x)^T\boldsymbol y=(S\boldsymbol x)^T\boldsymbol y=\lambda\boldsymbol x^T\boldsymbol y$，$\boldsymbol x^TS\boldsymbol y=\boldsymbol x^T\alpha\boldsymbol y=\alpha \boldsymbol x^T\boldsymbol y$ $\Rightarrow\boldsymbol x^T\boldsymbol y=0$</p></li></ul><p>正定矩阵：对所有 $\boldsymbol x&gt;0$ ， $\boldsymbol x^TS\boldsymbol x&gt;0$</p><h3 id="A-X-Lambda-X-1"><a href="#A-X-Lambda-X-1" class="headerlink" title="$A=X\Lambda X^{-1}$"></a>$A=X\Lambda X^{-1}$</h3><p>上面那个式子更一般的情况，这个对有 $n$ 个线性无关特征值的方阵</p><ul><li><p>$A^n=X\Lambda^nX^{-1}$</p></li><li><p>$\text{All: }|\lambda_i|&lt;1,\Lambda^n\rightarrow0,A^n\rightarrow0$</p></li></ul><p>特征向量与特征根的求解</p><ul><li><p>设 $\lambda$ ，计算 $\det(A-\lambda I)$</p></li><li><p>求解使 $\det(A-\lambda I)=0$ 的特征值 $\lambda$</p></li><li><p>对每个 $\lambda$，求解使 $(A-\lambda I)\boldsymbol x=\boldsymbol 0$ 的特征向量 $\boldsymbol x$</p></li></ul><p>其他的</p><ul><li><p>矩阵相似：特征值相同的两个矩阵相似 $\text{All } A=BCB^{-1}\sim C$</p></li><li><p>$\det(A)=\prod\lambda_i$</p></li><li><p>$\sum a_{ii}=\text{trace}=\sum\lambda_i$</p></li></ul><h2 id="奇异值与奇异矩阵"><a href="#奇异值与奇异矩阵" class="headerlink" title="奇异值与奇异矩阵"></a>奇异值与奇异矩阵</h2><p>Singular values and Singular vectors</p><p>特征值和特征向量是对于方阵而言的，奇异值和奇异矩阵是对非方阵而言的。</p><h4 id="A-U-varSigma-V-T"><a href="#A-U-varSigma-V-T" class="headerlink" title="$A=U\varSigma V^T$"></a>$A=U\varSigma V^T$</h4><ul><li><p>$A^TA\boldsymbol v_i=\sigma_i^2\boldsymbol v_i,AA^T\boldsymbol u_i=\sigma^2_i\boldsymbol u_i,A\boldsymbol v_i=\sigma\boldsymbol u_i$</p></li><li><p>$A^TA=(V\varSigma^T U^T)U\varSigma V^T=V\varSigma^2$</p></li><li><p>$AA^T=U\varSigma V^T(V\varSigma^TU^T)=U\varSigma^2U^T$</p></li><li><p>$AV=U\varSigma,V^TV=U^TU=I$</p></li></ul><h1 id="线性空间与线性变换"><a href="#线性空间与线性变换" class="headerlink" title="线性空间与线性变换"></a>线性空间与线性变换</h1><h2 id="线性空间"><a href="#线性空间" class="headerlink" title="线性空间"></a>线性空间</h2><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/2020%E7%9F%A9%E9%98%B5%E8%AE%BA%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4.png" alt=""></p><h2 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h2><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/2020%E7%9F%A9%E9%98%B5%E8%AE%BA%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2.png" alt=""></p><h1 id="矩阵的相似化简"><a href="#矩阵的相似化简" class="headerlink" title="矩阵的相似化简"></a>矩阵的相似化简</h1><h2 id="特征多项式与最小多项式"><a href="#特征多项式与最小多项式" class="headerlink" title="特征多项式与最小多项式"></a>特征多项式与最小多项式</h2><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/2020%E7%9F%A9%E9%98%B5%E8%AE%BA%E6%9C%80%E5%B0%8F%E5%A4%9A%E9%A1%B9%E5%BC%8F.png" alt=""></p><h2 id="Jordan标准型"><a href="#Jordan标准型" class="headerlink" title="Jordan标准型"></a>Jordan标准型</h2><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/2020%E7%9F%A9%E9%98%B5%E8%AE%BAJordan%E6%A0%87%E5%87%86%E5%9E%8B.png" alt=""></p><hr><p>2020©Fu_Qingchen, <strong>Learning</strong>By<strong>Sharing</strong></p>]]></content>
    
    
    <categories>
      
      <category>数学相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ Primer 阅读笔记</title>
    <link href="/2020/11/21/HUST/LearnCPP/"/>
    <url>/2020/11/21/HUST/LearnCPP/</url>
    
    <content type="html"><![CDATA[<p>为了准备C++的考试更新至：面向对象程序设计</p><p>PS：这本书可真厚实</p><span id="more"></span><p class="note note-primary">正在进行</p><p>相关练习：<a href="https://github.com/Fu-Qingchen/LearnCPP">https://github.com/Fu-Qingchen/LearnCPP</a></p><h1 id="开始-Getting-Started"><a href="#开始-Getting-Started" class="headerlink" title="开始 | Getting Started"></a>开始 | Getting Started</h1><ul><li><p>stream是字符序列，使用这个术语是想表达随着时间的推移，字符是顺序生成或消耗的。</p></li><li><p>操纵符，如<code>std::endl</code>，在读写流的时候操纵流本身</p></li><li><p>缓冲区：定义流对象时，会在内存开辟一个缓冲区，用来暂存输入输出流的数据。</p></li><li><p>对Windows系统，<code>Ctrl + Z</code>然后按<code>Enter</code>结束输入</p></li><li><p>C++的输出运算符<code>&lt;&lt;</code>和输入运算符<code>&gt;&gt;</code></p></li><li><p>《C++ Primer》P2提到<code>main</code>函数的返回类型必须为<code>int</code>，但是有些编译器也可以设置为 <code>void</code></p></li></ul><h1 id="C-基础-The-Basics"><a href="#C-基础-The-Basics" class="headerlink" title="C++基础 | The Basics"></a>C++基础 | The Basics</h1><p>这一块的难点主要是类型转换</p><h2 id="变量和基本类型-Variables-and-Basic-Types"><a href="#变量和基本类型-Variables-and-Basic-Types" class="headerlink" title="变量和基本类型 | Variables and Basic Types"></a>变量和基本类型 | Variables and Basic Types</h2><p>这一块可以分为基本类型、复合类型、常量和自定义类型</p><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ul><li><p>基本类型的选择</p><ul><li>明确知道数值部位负时，选用无符号类型</li><li>使<code>int</code> 进行整数运算</li><li>算术表达式中不使用<code>char</code>或<code>bool</code></li><li>使用<code>double</code>进行浮点数运算</li></ul></li><li><p>C++约定表示范围内正值和负值的数量要平衡，即<code>signed char</code>范围为<code>-127~127</code></p></li><li><p>C++中将浮点数赋值给整数时，小数点部分直接去掉</p></li><li><p>C++中将整数赋值给浮点数时，若整数超过浮点数的精度，浮点数将会对整数进行四舍五入</p></li><li><p>切勿混用带符号类型的数和无符号类型的数</p></li><li><p>C++中字符串结束的字符为<code>\0</code> ，<code>&#39;A&#39;</code>中有1个字符，<code>&quot;A&quot;</code>中有两个字符</p></li><li><p>由空格、缩进和换行连接的两个字符串其实是一个字符串</p></li><li><p><code>f/F</code>后缀或前缀只能用于浮点数类型的字面量，<code>1024F</code>是无效写法</p></li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li><p>数据类型决定</p><ul><li>变量/对象所占据的空间大小和布局方式</li><li>该空间所能储存值的范围</li><li>变量能进行的运算</li></ul></li><li><p>对象：一块能储存数据，并具有某种类型的储存空间</p></li><li><p>初始值不是赋值，初始化的含义是创建变量时赋予其一个初值，而赋值的含义是擦除当前的值，然后用一个新值来代替</p></li><li><p>声明和定义：</p><ul><li>声明：规定变量的类型和名字</li><li>定义：规定变量的类型和名字，申请储存空间，并可能为变量赋一个初始值<blockquote><p> 在多个文件使用同一个变量，必须将变量声明与定义分开（？？？）</p></blockquote></li></ul></li><li><p>变量的4种属性</p><ul><li>数据结构</li><li>储存类型</li><li>作用域</li><li>作用期</li></ul></li></ul><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><ul><li><p>引用即别名</p></li><li><p>建议初始化所有指针，如果实在是不清楚，可以将它初始化为<code>nullptr</code></p></li><li><p>指针与引用的主要区别</p><ul><li>指针是对象，在初始化和赋值后还可以更改、拷贝等</li><li>指针不需要在定义的时候初始化，引用需要</li></ul></li><li><p>为了在多个文件用到同一个变量，可以在其中一个文件定义，其他文件用<code>extern</code>仅声明不定义</p></li></ul><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul><li><p>常量引用是对<code>const</code>的引用</p></li><li><p>只有常量引用才能引用常量</p></li><li><p>初始化常量引用时允许引用类型与所引用对象的类型不一致</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> &amp;b = a;<br></code></pre></td></tr></table></figure></li><li><p>指向常量的指针：<code>const int a = 0; const int *b = &amp;a</code> 指针非常量，指向对象为常量</p><p><code>const</code>指针：<code>int a = 0; int *cosnt b = &amp;a</code>指针是常量，指向对象可以是非常量</p></li><li><p>顶层const：表示对象本身是个常量，如<code>const</code>修饰的基本类型和const指针</p><p>底层const：表示指针/引用所指对象是个常量</p></li><li><p>顶层const的拷贝不受影响，底层const的拷贝两个数据类型必须能够进行转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> v2 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> v1 = v2;<br><span class="hljs-keyword">int</span> *p1 = &amp;v1;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p2 = &amp;v2, *<span class="hljs-keyword">const</span> p3 = &amp;i;<br>p1 = p2;<span class="hljs-comment">// error</span><br>p1 = p3;<span class="hljs-comment">// error</span><br></code></pre></td></tr></table></figure></li><li><p><code>constexpr</code> 常量表达式</p></li></ul><h3 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h3><ul><li><p><code>typedef</code>类型重命名</p></li><li><p><code>auto</code> 自动检测赋值的类型</p><ul><li>自动去掉顶级<code>const</code>和引用</li><li>设置为引用时，其初始化的顶级<code>const</code>保留</li><li>一条语句定义多变量要保持一致</li></ul></li><li><p><code>decltype</code> 自动检测一个函数返回的类型，与<code>auto</code>的区别是可以赋其他值</p><ul><li>不去掉顶级<code>const</code>和引用</li><li><code>decltype(*p)</code>将会得到一个指针</li></ul></li><li><p>赋值的表达式语句本身是一种引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">typeof</span>(x = a)<span class="hljs-comment">//return int &amp; 类型</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="字符串、向量和数组-Strings-Vectors-and-Arrays"><a href="#字符串、向量和数组-Strings-Vectors-and-Arrays" class="headerlink" title="字符串、向量和数组 | Strings, Vectors, and Arrays"></a>字符串、向量和数组 | Strings, Vectors, and Arrays</h2><ul><li><p>头文件中不应该使用<code>using</code></p></li><li><p>用<code>string(int, char)</code>初始化得到给定字符重复n次。</p></li><li><p>字符数组无法进行整体赋值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">char</span> c[<span class="hljs-number">10</span>];<br><span class="hljs-comment">// c = &#123;&#x27;C&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;n&#x27;, &#x27;a&#x27;&#125;; error</span><br>c[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;C&#x27;</span>, c[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;h&#x27;</span>, c[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;i&#x27;</span>, c[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;n&#x27;</span>, c[<span class="hljs-number">4</span>] = <span class="hljs-string">&#x27;a&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>字符数组的最后一个字符并不要求是<code>\0</code>，但是为了统一，习惯性的在字符数组后面加一个</p></li><li><p><code>unsigned string::size()</code>，注意他和<code>int</code>比较时可能会发生意想不到的bug，<strong>不要在有<code>size()</code>的表达式中加入<code>int</code>类型的数据</strong></p></li><li><p>数组不支持拷贝和赋值</p></li></ul><h2 id="表达式-Expressions"><a href="#表达式-Expressions" class="headerlink" title="表达式 | Expressions"></a>表达式 | Expressions</h2><ul><li><p>左值-&gt;对象的身份（内存中的位置）</p><p>右值-&gt;对象的值（内容）</p></li><li><p><strong>C++没有规定运算符求解的顺序</strong>，如果表达式指向并修改了同一个对象，将产生错误并产生未定义的行为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> i;<br>cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ++i &lt;&lt; endl;<span class="hljs-comment">//不会报错，但是混淆</span><br></code></pre></td></tr></table></figure><p>除了<code>&amp;&amp;</code>、<code>||</code>、<code>,</code>、<code>?:</code></p></li><li><p>C++中<code>true == 0</code>，因此<code>-true == true</code></p></li><li><p><code>++i</code>比<code>i++</code>性能好</p></li><li><p><code>,</code> 返回逗号右侧的运算结果</p></li><li><p>当数组<strong>不</strong>转换为指针的情况</p><ul><li>作为<code>decltype</code>的参数</li><li>作为取地址符的对象</li><li><code>sizeof</code>的运算对象</li><li><code>typeid</code>的运算对象</li></ul></li><li><p>对指针来说， <code>static_cast</code> 必须保证转换后的类型就是指针所指的类型</p></li><li><code>reinterpret_cast</code> 可以为运算对象的位模式提供较低层次上的重新解释</li></ul><h2 id="语句-Statements"><a href="#语句-Statements" class="headerlink" title="语句 | Statements"></a>语句 | Statements</h2><ul><li>case标签后跟常量</li></ul><h2 id="函数-Functions"><a href="#函数-Functions" class="headerlink" title="函数 | Functions"></a>函数 | Functions</h2><ul><li><p>内置函数(函数名前加<code>inline</code>)的使用可以减少函数调用的时间，当一个函数只有少量代码且调用频繁时可以将其加入</p></li><li><p>指定默认值的参数必须放在形参表列的最右端</p></li><li><p>C++中名称有作用域，对象有生命周期</p></li><li><p>尽量使用引用避免拷贝，大的类类型的数据拷贝起来费时间</p></li><li><p>函数无须改变引用形参的值时，最好申明为常量引用</p></li><li><p>实参初始化形参时会默认去掉顶层const</p></li><li><p>函数重载不区分顶层const</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>)</span></span>;<span class="hljs-comment">//这两个申明不构成重载，是同一个函数</span><br></code></pre></td></tr></table></figure></li><li><p>尽量使用常量引用</p></li><li><p>虽然不存在引用的数组，但是可以写出来</p></li><li><p><code>initializer_list</code>可以实现可变参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;initializer_list&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test</span><span class="hljs-params">(initializer&lt;<span class="hljs-keyword">int</span>&gt; il)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> pointer = il.<span class="hljs-built_in">begin</span>(); pointer != il.<span class="hljs-built_in">end</span>(); pointer++)&#123;<br>        cout &lt;&lt; *pointer;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">Test</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>不要返回局部对象的指针或引用</strong></p></li><li><p>返回引用的函数返回的是左值（可以对函数赋值），返回其他类型的函数返回的是右值</p></li><li><p>给定作用域中形参只能给一次默认值</p></li><li><p><code>constexpr</code>函数不一定返回常量表达式，只是这个函数可以用于常量表达式；当起实参是常量表达式时，返回常量表达式</p></li><li><p>重载函数的函数匹配</p><ul><li>候选函数（所有调用点可见，重名的函数）</li><li>可行函数（实参与形参对应或可以进行类型转换的函数）</li><li>最优函数<ul><li>有一个实参的匹配优于其他</li><li>没有实参的匹配劣于其他</li></ul></li></ul></li><li><p>类型转换</p><ol><li>精确匹配<ul><li>类型相同</li><li>数组，函数 —&gt; 指针</li><li>顶层<code>const</code> —&gt; <code>const</code></li></ul></li><li>非<code>const</code> —&gt; <code>const</code></li><li>算术类型的提升</li><li>算术类型的转换，或指针的转换(<code>0</code>/<code>nullptr</code> —&gt; other; other —&gt; <code>void *</code>)</li><li>类类型的转换</li></ol></li></ul><h2 id="类-Classes"><a href="#类-Classes" class="headerlink" title="类 | Classes"></a>类 | Classes</h2><ul><li><p>不能在常量对象上调用普通成员函数，可以调用参数列表后有<code>const</code>的常量成员函数，它将返回<code>const</code>对象</p></li><li><p>IO类不允许拷贝，因此使用引用传递</p></li><li><p>执行输出任务的函数不应该有格式的控制</p></li><li><p>默认构造函数：不接受任何实参的函数</p></li><li><p>定义在块中内置类型或复合类型的数据默认初始化后的值时未确定的</p></li><li><p>友元函数 —&gt; 类相关的非成员函数，在类中申明友元只是说明了访问性，在类外也必须要申明和定义</p></li><li><p>类成员函数定义在外部时，其返回类型的作用域在类的作用域外(设置了别名时需要注意)</p></li><li><p>名字查找</p><ul><li>类的成员函数<ul><li>编译类的声明</li><li>完成后编译函数体</li></ul></li><li>其他<ul><li>在名字所在块中查找</li><li>外层作用域中查找</li></ul></li></ul></li><li><p>尽量使用初始化而不是赋值，后者底层效率更低</p></li><li><p>构造函数初始化顺序与成员在类定义出现的顺序一样</p></li><li><p><code>explicit</code>只对<strong>一个实参</strong>的构造函数有效，切只能以直接初始化的方式使用</p></li><li><p>聚合类没有类内初始值，没构造函数，也没基类</p></li><li><p><code>string</code>不是字面值类型的数据</p></li><li><p>静态成员函数无法声名成<code>const</code>，也无法使用<code>this</code></p></li><li><p>类外无法使用<code>friend, explicit, static</code>关键字</p></li><li><p>类的静态成员不应该在类内初始化，即使这样也要在类外定义一下</p></li><li><p>类：抽象和封装</p></li></ul><h1 id="C-标准库-The-C-Library"><a href="#C-标准库-The-C-Library" class="headerlink" title="C++标准库 | The C++ Library"></a>C++标准库 | The C++ Library</h1><h2 id="IO库-The-IO-Library"><a href="#IO库-The-IO-Library" class="headerlink" title="IO库 | The IO Library"></a>IO库 | The IO Library</h2><ul><li><p>不能拷贝IO对象或对IO对象赋值，因此进行IO操作的函数经常用引用来进行数据的传递</p></li><li><p>流一旦发生错误，后续的IO操作失效，因此代码通常在使用流之前对其进行检查</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(cin &gt;&gt; input)&#123;<span class="hljs-comment">/* */</span>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果一个程序中途崩溃，有些流信息可能就在缓冲区，无法输出。</p><blockquote><p>当调试时用输出判断执行位置时要注意，可能代码已经执行，程序崩溃后输出的语句卡在缓冲区无法输出</p></blockquote></li><li><p>每次都刷新缓冲区，可以使用<code>unitbuf</code>操作符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; unitbuff;<span class="hljs-comment">//之后的输出操作后会立即刷新缓冲区</span><br>cout &lt;&lt; nounitbuff;<span class="hljs-comment">//回到正常的模式</span><br></code></pre></td></tr></table></figure></li><li><p>关联了输出和输入的流，执行输入会默认刷新缓冲区（<code>cin, cout</code>就是关联在一起的），交互式系统一般都会关联</p></li><li><p>为了保留<code>out</code>模式打开的文件的内容，必须同时指定<code>app</code>模式</p></li><li><p><code>istringstream</code>的应用：数据先对整行进行存储，再对行内的每个单词进行存储</p></li><li><p><code>ostringstream</code>的应用：逐步构造输出，最后一起打印</p></li></ul><h2 id="顺序容器-Sequential-Containers"><a href="#顺序容器-Sequential-Containers" class="headerlink" title="顺序容器 | Sequential Containers"></a>顺序容器 | Sequential Containers</h2><ul><li><code>string</code> &amp; <code>vector</code> : 元素存储在连续的内存空间中，访问速度快，在尾部外的位置插入删除慢</li><li><code>list</code> &amp; <code>forward_list</code> :  双向和单向链表，插入删除很快，不支持随机访问</li><li><code>deque</code> : 两端队列，两端插入删除很快</li><li><code>array&lt;T, n&gt;</code> : 有固定大小</li><li><strong>标准库容器比旧版本性能快的多</strong>，因此现代C++程序应该使用标准库容器，而不是数组之类的。<strong>通常 <code>vector</code> 是最好的选择，除非有理由选择其他容器</strong></li><li>容器 <code>size_type</code> 为<strong>无符号整数</strong>类型。</li><li>程序中有很多小元素且额外的空间开销很重要：不选<code>list</code> 和 <code>forward_list</code> </li><li>如果程序仅在输入时要求在中间插入数据，可以在输入阶段使用<code>list</code>，然后将<code>list</code>中的拷贝到<code>vector</code>中</li><li>可以通过<code>vector</code>的<code>sort()</code>解决很多在中间插入的情况</li><li><strong>迭代器范围</strong>：<code>[begin, end)</code></li><li>通过迭代器范围对容器元素进行拷贝就不需要两个容器类型匹配，只需要可以互相转化 <code>vector&lt;string&gt; v1; vector&lt;chat *&gt; v2(v1.begin(), v1.end())</code></li><li><code>assign()</code>能够实现不同类型之间元素的拷贝</li><li>拷贝后之前的迭代器、指针和引用会失效</li><li><code>swap()</code>交换的是一整个容器，而不是单个元素</li><li>除<code>array</code> 外容器，<code>swap</code>不对任何数据进行操作，指向容器的迭代器、指针和引用依然有效，不过<code>swap</code>后他们指向的元素属于不同的容器了， $O(1)$时间复杂度<ul><li><code>array</code>容器：进行操作，迭代器、指针和引用所指元素不变，但是元素的值进行了交换，$O(n)$时间复杂度</li></ul></li><li><code>vector, string, deque, array</code>才支持下标和<code>at()</code>操作</li><li>访问容器的成员函数返回的都是引用，<strong>使用 <code>auto</code> 时必须将变量定义为引用类型</strong>，如<code>auto &amp;v = c.front(); v = 2; //c.front()的值也会变</code> </li><li><code>at()</code>是安全的随机访问函数，会检查越界，下标不会</li><li>在删除容器元素前，必须保证他们是存在的</li><li><strong>添加/删除元素前，必须考虑迭代器</strong>，特别是对于<code>vector</code>和<code>string</code></li><li>不要保存<code>end()</code>返回的迭代器 </li><li>复合赋值语句只能用于 <code>string</code>、<code>vector</code>、<code>deque</code>、<code>array</code></li><li><code>reserve(n)</code> 分配至少容纳 n 个元素的内存空间，不过这个函数不会减小容器咱用的容量</li><li><code>capacity</code> 与 <code>size</code> 的区别</li><li>容器适配器：<code>stack</code>，<code>queue</code>，<code>priority_queue</code></li><li><code>stack</code> 和 <code>queue</code>基于 <code>deque</code> 实现，<code>priority_queue</code> 基于 <code>vector</code> 实现</li><li><code>pop()</code>：<strong>删除不返回</strong>；<code>top</code>：返回不删除</li></ul><h2 id="泛型算法-Generic-Algorithm"><a href="#泛型算法-Generic-Algorithm" class="headerlink" title="泛型算法 | Generic Algorithm"></a>泛型算法 | Generic Algorithm</h2><ul><li><p>对于只读取不写入的泛型算法，可通常使用<code>cbegin()</code> 和<code>cend()</code></p></li><li><p>对用单一迭代器表示第二个序列的算法，默认认为第一个序列与第二个序列等长</p></li><li><p><code>accumulate()</code> 的第三个参数决定了返回类型</p></li><li><p><strong>泛型算法不检查写操作</strong>，不要越界</p></li><li><p>可调用对象：可以使用调用运算符<code>()</code>的对象或表达式，有四类</p><ul><li>函数</li><li>函数指针</li><li>lambda表达式</li><li>重载了函数调用运算符的类</li></ul></li><li><p>lambda表达式的形式：<code>[lambda在函数体中声明的局部变量](函数参数表)-&gt;返回类型&#123;函数体&#125;</code>。其中，可以忽略参数表和返回类型，即<code>[局部变量]&#123;函数体&#125;,[局部变量](函数参数表)&#123;函数体&#125;,``[lambda在函数体中声明的局部变量]-&gt;返回类型&#123;函数体&#125;</code></p></li><li><p>当以引用的方式捕获变量时，要注意它在 lambda 表达式执行时变量依然存在</p></li><li><p>要尽量减少捕获的数据量，避免捕获指针和引用（<code>int</code> 等就直接用值捕获）</p></li><li><p>默认情况下，值捕获变量，lambda不会改变它的值。如果要改变，就要在参数表后加关键字 <code>mutable</code>：<code>auto f = [v] () mutable &#123;v++;&#125; ;</code></p></li><li><p>lambda 表达式如果不只包含单一的 <code>return</code> 语句，它的返回类型默认是 <code>void</code>，如果想指定返回类型需要用到 lambda 的返回类型（带<code>-&gt;</code>的版本）</p></li><li><p>有些算法仅支持一元谓词，但是我们希望传多个参数给函数，这时候除了用 lambda 表达式通过捕获，还可以用到<strong>绑定</strong>，形式为 <code>auto newCallable = bind(callabled, arglist)</code>，<code>newCallable</code>就是满足要求的</p></li><li><p>对<code>auto g = bing(f, A, B, _2, C, _1)</code>，有<code>g1(_1, _2)</code> 映射为 <code>f(A, B, _2, C, _1)</code></p></li><li><p>绑定不能直接绑引用参数，必须借助<code>ref()</code>：<code>bind(print, ref(os), _1, &quot; &quot;)</code></p></li></ul><h1 id="类设计者的工具"><a href="#类设计者的工具" class="headerlink" title="类设计者的工具"></a>类设计者的工具</h1><h2 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h2><ul><li><p>在C++中，基类函数有两类：一类是基类希望派生类根据自身改变的，声明时需要讲起声明为 <strong>虚函数</strong> ，派生类经常（但不总是）覆盖基类的虚函数；另一类则是派生类不需要改变的，不做特殊的声明。</p></li><li><p>一旦某个函数被声明为虚函数，在所有派生类中，都会是虚函数（不过派生类中函数参数类型必须相同）；有一种情况是例外：返回类型是本类型的指针或引用</p></li><li><p>派生类的对象可以绑定到基类的<strong>引用或者指针</strong>上（<strong>派生类到基类的类型转换</strong>）<code>Base *p = new Derived()</code> （<code>p</code> 指向 <code>Derived</code> 继承自 <code>Base</code> 的那一部分），不存在从基类到派生类的转换</p><blockquote><p>派生类到基类的转换可能由于访问限制而变的不可行</p></blockquote></li><li><p>对象没法进行类型转换，但是很多函数接受引用作为传递的参数。（当用派生类给基类赋值时，只有其基类部分会被拷贝与赋值）<code>Deriver a; Base b = a; Base *c = &amp;a;</code> （ <code>b</code> 会调用 <code>Base</code>的虚函数，<code>c</code> 会调用 <code>Deriver</code> 的虚函数）</p></li><li><p><strong>静态类型</strong>：编译时已知，就是声明时候的类型，或者表达式生成的类型；<strong>动态类型</strong>：运行时才知道的类型，变量或表达式表示的内存中的类型（虚函数通过指针或引用调用时）</p><blockquote><p>当有派生类到基类的类型转换时，静态类型和动态类型不一样，其他情况都一样</p></blockquote></li><li><p>派生类中继承自基类的对象和自己定义的对象不一定是连续存储的</p></li><li><p>派生类的构造函数先初始化基类的部分，再按照声明的顺序依次初始化派生类的成员。每个类负责自己的接口，因此尽量不要在派生类直接给公有或受保护的基类的成员复制</p></li><li><p>作为基类的类必须已经定义，而非声明</p></li><li><p>防止继承：在类名或函数参数表后面跟关键字 <code>final</code></p></li><li><p>覆盖原来的虚函数很容易写成函数的重载，可以通过参数表后跟关键字 <code>overwrride</code> 进行检查</p></li><li><p>虚函数支持默认实参，但是这个实参值是由本次调用的静态类型决定</p></li><li><p>通过作用域可以回避虚函数机制 <code>Deriver a; a.Base::print();</code></p></li><li><p>派生类的成员或友元只能通过派生类对象访问基类的保护成员，不能直接通过基类对象访问基类的保护成员</p></li><li><p>派生访问修饰符<strong>不对</strong>派生类的成员及友元起限制作用，<strong>对</strong>派生类的用户（包括派生类的派生类）起限制作用</p></li><li><p>如果基类的公有成员可以访问，那么就可以进行派生类向基类的类型转换（只有公有继承的派生类 <code>Pub_D</code> 用户才能进行派生类 <code>Pub_D</code> 向基类 <code>B</code> 的转换；派生类的派生类 <code>D_Pub_D/D_Pro_D</code> 成员和友元对公有和保护继承的派生类 <code>Pub_D/Pro_D</code> 才能进行派生类向基类 <code>B</code> 的转换；派生类 <code>Pub_D/Pro_D/Pri_D</code> 的成员和友元不受访问修饰符的限制）</p></li><li><p>友元没有传递性（<code>class A&#123; friend class B; &#125;; class B&#123; friend void test() &#125;</code>，<code>B</code> 可以访问 <code>A</code> 的私有，<code>test()</code> 不能），也没有继承性（<code>class Base&#123; friend void test(); &#125;; class D: public Base&#123; &#125;;</code> ，<code>test()</code> 不能访问 <code>D</code> 的私有和保护）</p></li><li><p><code>using</code> 关键字可以改变个别成员的可访问性，如 <code>class Base&#123;protect: int a;&#125; class D:privite Base&#123; public &#125;</code></p></li><li><p>名字查找限于类型识别，因此即使形参列表不同，基类成员的函数依旧会被同名的派生类成员函数隐藏</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数值分析笔记</title>
    <link href="/2020/10/03/HUST/NumbericalAnalysis/"/>
    <url>/2020/10/03/HUST/NumbericalAnalysis/</url>
    
    <content type="html"><![CDATA[<p>蛮有用的一门（尤其是做数学动画的时候），应该边写程序边上这门课。</p><span id="more"></span><h1 id="误差部分"><a href="#误差部分" class="headerlink" title="误差部分"></a>误差部分</h1><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/2020%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90%E8%AF%AF%E5%B7%AE%E5%88%86%E6%9E%90.png" alt=""></p><p>在对实际问题建模、计算时会有很多误差，这些方法有时候会变的很大，导致数据不可用。因此研究误差时数值计算的基本。</p><h2 id="误差的来源"><a href="#误差的来源" class="headerlink" title="误差的来源"></a>误差的来源</h2><p>误差总共分为4类：系统误差、观测误差、截断误差、舍入误差</p><blockquote><p> 数值计算环节误差主要来源于 <strong>截断误差、舍入误差</strong> </p></blockquote><h2 id="误差的衡量"><a href="#误差的衡量" class="headerlink" title="误差的衡量"></a>误差的衡量</h2><p>$x$为准确值，$x^❀$为近似值 </p><ul><li>绝对误差 $e(x) = x^❀-x$， </li><li>相对误差 $e_r(x) = {({x^❀}-x)/x}$，不过由于$x$无法算出，一般取$e_r(x)=({x^❀}-x)/{x^❀}$</li><li>有效数字$n:x^❀ = \pm10^m\times0.a_1a_2…a_n,|x-x^❀|\leq0.5\times10^{m-n+1}$</li></ul><h2 id="数值计算中的误差"><a href="#数值计算中的误差" class="headerlink" title="数值计算中的误差"></a>数值计算中的误差</h2><p>$x=[x_1,x_2,…,x_n]^T$为准确解，$x^❀=[x^❀_1,x^❀_2,…,x^❀_n]^T$为近似值，$A^❀ = f(x^❀)$为误差</p><ul><li><p>绝对误差$e(A) = A^❀-A=\sum\limits_{j=1}^n\frac{\partial f(x)}{\partial x_j}e(x_j)$</p><blockquote><p>这里用到了Taylor展开取到一阶导</p></blockquote></li><li><p>相对误差$e_r(A)=\frac{A^❀-A}{A}=\sum\limits_{j=1}^n\frac{x_j}{f(x)}\frac{\partial f(x)}{\partial x_j}e_r(x_j)$</p></li></ul><blockquote><p>注意$\partial f(x)/\partial x,\frac{x_j}{f(x)}\frac{\partial f(x)}{\partial x_j}$ 对误差的影响很大，后者成为条件数，当其值&gt;10时，称该算法不稳定</p></blockquote><h2 id="防止误差过大方法"><a href="#防止误差过大方法" class="headerlink" title="防止误差过大方法"></a>防止误差过大方法</h2><ul><li>避免大数除小数</li><li>避免大数加小数</li><li>避免相近数相减</li></ul><blockquote><p>改变计算公式，可以去除这些。</p></blockquote><h1 id="插值与拟合部分"><a href="#插值与拟合部分" class="headerlink" title="插值与拟合部分"></a>插值与拟合部分</h1><p>插值和拟合主要将一些离散的数值点用函数来表示。</p><h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/2020%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90%E6%8F%92%E5%80%BC%E6%B3%95.png" alt=""></p><p>插值是在一些基函数的线性组合中找到一个函数$y=f(x)$，这个函数要经过每个数值点$y$。下面就只讨论多项式插值了:$f(x)=a_0x^0+a_1x^1+…+a_nx^n$</p><blockquote><p>常见的基函数有多项式，三角函数。</p></blockquote><h3 id="插值函数的个数"><a href="#插值函数的个数" class="headerlink" title="插值函数的个数"></a>插值函数的个数</h3><ul><li><p>对于（n+1）个节点，n 次插值多项式存在且唯一</p><blockquote><p>证明：各个节点处建立方程，系数行列式为 范德姆行列式，存在且唯一（n+1个方程，n+1个未知数，因此存在且唯一）</p><p>如果两个式子次数相同为 n，且对所有（n+1）个节点式子成立，那么这两个式子相等</p></blockquote></li></ul><h3 id="拉格朗日插值"><a href="#拉格朗日插值" class="headerlink" title="拉格朗日插值"></a>拉格朗日插值</h3><p>插值函数的求解方法有很多。先说拉格朗日的方法：</p><p>为了满足那些数值点在函数上，就改写一下函数，同时改个名字为$L(x)$</p><script type="math/tex; mode=display">L_n(x)=l_0(x)y_0+l_1(x)y_1+...+l_n(x)y_n=\sum\limits_{i=0}^ny_il_i(x)</script><p>这些$l(x)$就是需要构造的函数，目前还不知道。为了让点在$f(x)$上这个函数上，它满足下面的规律：</p><script type="math/tex; mode=display">l_i(x)= \left\{\begin{array}{rl}0 & \text{if } x \neq x_i,\\1 & \text{if } x = x_i.\end{array} \right.</script><p>因此可以构造为：</p><script type="math/tex; mode=display">l_k(x)=\prod\limits_{i=0,i\neq k}^n {(x-x_i)\over(x_k-x_i)}</script><p>这个就是拉格朗日插值基函数，其插值余项（截断误差）为                                 </p><script type="math/tex; mode=display">R_n(x)=f(x)-L_n(x)=\frac{f^{(n+1)}(\xi)}{(n+1)!}\prod\limits_{i=0}^n(x-x_i)</script><blockquote><p>这个里面的$f(x)$为原始的要去插值贴近的函数。</p></blockquote><p>在实际问题中，往往不知道$f(x)$的具体解析表达式，因此要估计$f^{(n+1)}(x)$的上界是不现实的。在这种情形下，可以采用误差的事后估计法：</p><script type="math/tex; mode=display">i=0,1,...,n-1\Rightarrow L_{n-1}(x)\\i=1,2,...,n\Rightarrow \hat{L}_{n-1}(x)\\R_{n-1}(x)=f(x)-L_{n-1}(x)\approx\frac{x-x_0}{x_0-x_n}[L_{n-1}(x)-\hat{L}_{n-1}(x)]</script><p>其误差有以下特点：</p><ul><li>对多项式插值，增加阶数不一定能提高精度</li><li>插值多项式仅与已知数据有关，与$f(x)$原来形式无关，但余项与$f(x)$密切相关</li><li>增加一个插值结点，所有的基函数都要重新计算。（没有沿承性）</li></ul><h3 id="牛顿插值"><a href="#牛顿插值" class="headerlink" title="牛顿插值"></a>牛顿插值</h3><p>拉格朗日插值法没有沿承性，牛顿插值就是用来解决这个问题的。因此要构造</p><script type="math/tex; mode=display">N_{n+1}(x)=N_{n}(x)+q_{n+1}(x)\\N_0(x) = a</script><p>其中$a$为设的一常数，$q_{n+1}$是设的一函数，下面就需要构造$q_{n+1}(x)$，然后求解$a$</p><p>由于$N_{n+1},N_n$是插值多项式，因此在$x_0.x_1,…,x_n$上是相等的，根据上面那个式子，可以得到：$q_{n+1}(x_i)=0,i=0,1,…n$。根据这个性质，可以构造$q_{n+1}(x)=a_{n+1}\prod\limits_{i=0}^n(x-x_i)$</p><p>根据$q_{n+1}(x)$ 可以反推出$N_{n}(x)=a_0+a_1(x-x_0) + …+a_n(x-x_0)…(x-x_{n-1})$</p><p>将我们的节点带入，可以得到一堆方程：</p><script type="math/tex; mode=display">N_n(x_0)=a_0=f(x_0)\\N_n(x_1)=a_0+a_1(x-x_0)=f(x_1)\\N_n(x_2)=a_0+a_1(x-x_0)+a_2(x-x_0)(x-x_1)=f(x_2)\\...</script><p>(n+1)个方程，(n+1)个未知数，可以解出$a_i,i=0,1,…,n$的值。由于这个数字比较重要，我们把这些数字叫做差商，其表达式如下：</p><script type="math/tex; mode=display">f[x_0]=f[x_0]\\f[x_0,x_1,...,x_k]=\frac{f[x_0,x_1,...,x_{k-1}]-f[x_1,x_2,...,x_{k}]}{x_0-x_{k}}</script><p>差商有很多重要的性质，比如说下面的：</p><ul><li>0阶差商：$f[x_0]=f[x_0]$</li></ul><ul><li><p>k阶差商：$f[x_0,x_1,…,x_k]=\frac{f[x_0,x_1,…,x_{k-1}]-f[x_1,x_2,…,x_{k}]}{x_0-x_{k}}$ </p><blockquote><p>例如：1阶次差商：$f[x_0,x_1]=\frac{f(x_1)-f(x_0)}{x_1-x_0}$</p></blockquote></li><li><p>交换差商节点的位置，差商的值没有变化（差商的对称性）</p><blockquote><p>例如：$f[x_0,x_1,x_2]=f[x_1,x_0,x_2]$</p></blockquote></li><li><p>差商除了用递归式写，还可以用迭代式表示：</p></li></ul><script type="math/tex; mode=display">f[x_0,x_1,...,x_k]=\sum_{i=0}^{k}\frac{f(x_i)}{\prod\limits_{j=0\\j\neq i}^k(x_i-x_j)}</script><ul><li><p>差商和导数的关系可以由拉格朗日中值定理套娃给出：$f[x_0,x_1,…,x_k]=f^{(k)}(\xi)/(n!)$</p><blockquote><p>其实差商可以想象成导数，只不过离散化了。</p></blockquote></li></ul><p>有了差商，牛顿插值多项式就构造出来了</p><script type="math/tex; mode=display">N_n(x)=f(x_0)+f[x_0,x_1]\times(x-x_0)+...+f[x_0,x_1,...,x_n]\prod\limits_{i=0}^{n-1}(x-x_i)</script><p>余项（截断误差）：$R_n(x)=f[x_0,x_1,…,x_n,x]\prod\limits_{i=0}^n(x-x_i)$ </p><blockquote><p>这个与拉格朗日插值的误差是一样的</p></blockquote><h2 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h2><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/2020%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0%E9%80%BC%E8%BF%91.png" alt=""></p><ul><li><p>正则方程组</p><p>设有 n 个节点的拟合函数为 $y=a_0+a_1x+…+a_mx^m$ ：</p><ul><li>$a_on+a_1\sum\limits_{i=0}^nx_i^{1+0}+a_2\sum\limits_{i=0}^nx_i^{2+0}+…+a_m\sum\limits_{i=0}^nx_i^{m+0}=\sum\limits_{i=0}^ny_ix_i^{0}$</li><li>$a_o\sum\limits_{i=0}^nx_i^{0+1}+a_1\sum\limits_{i=0}^nx_i^{1+1}+a_2\sum\limits_{i=0}^nx_i^{2+1}+…+a_m\sum\limits_{i=0}^nx_i^{m+1}=\sum\limits_{i=0}^ny_ix_i^{1}$</li><li>$a_o\sum\limits_{i=0}^nx_i^{0+2}+a_1\sum\limits_{i=0}^nx_i^{1+2}+a_2\sum\limits_{i=0}^nx_i^{2+2}+…+a_m\sum\limits_{i=0}^nx_i^{m+2}=\sum\limits_{i=0}^ny_ix_i^{2}$</li><li>…</li><li>$a_o\sum\limits_{i=0}^nx_i^{0+m}+a_1\sum\limits_{i=0}^nx_i^{1+2}+a_2\sum\limits_{i=0}^nx_i^{2+m}+…+a_m\sum\limits_{i=0}^nx_i^{m+m}=\sum\limits_{i=0}^ny_ix_i^{m}$ </li></ul></li></ul><h1 id="数值积分与微分"><a href="#数值积分与微分" class="headerlink" title="数值积分与微分"></a>数值积分与微分</h1><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/2020%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86.png" alt=""></p><ul><li><p>机械求积公式 $\int_a^bf(x)dx=\sum\limits_{i=1}^nA_if(x_i)$ </p></li><li><p>机械求积公式余项 $R_n[f]=Kf^{(m+1)}(\xi)$ （<em>m</em>为代数精度）</p><blockquote><p>其中 $K=\frac{1}{(m+1)!}[\int_a^bf(x)dx-\sum\limits_{i=1}^nA_if(x_i)]$ ，通常化简得 $K=\frac{1}{(m+1)!}[\frac{1}{m+2}(b^{m+2}-a^{m+2})-\sum\limits_{i=1}^nA_if(x_i)]$  </p></blockquote></li><li><p>中矩形公式 $\int_a^bf(x)dx=f(\frac{a+b}2)(b-a),R_n[f]=\frac{f^{(2)}(\xi)}{24}(b-a)^3$ </p></li><li><p>梯形公式 $\int_a^bf(x)dx=\frac{f(a)+f(b)}2(b-a),R_n[f]=-\frac{f^{(2)}}{12}(b-a)^3$ </p></li><li><p>辛普森公式 $\int_a^bf(x)=\frac{f(a)+4f[(a+b)/2]+f(b)}6(b-a),R_n[f]=-\frac{f^{(4)}}{2880}(b-a)^5$ </p></li><li><p>插值型机械求积公式 $\int_a^bf(x)dx=\sum\limits_{i=1}^n\int_a^bl_i(x)dxf(x_i),R_n[f]=\int_a^b\frac{f^{(n+1)}(\xi)}{(n+1)!}\prod\limits_{i=0}^n(x-x_i)$ </p></li><li><p>梯形法递推公式 $T_{2n}(h)=\frac12T_n(h)+\frac {h_n}2[\sum\limits f(x_{k+\frac12})]$ </p></li><li><p>$S_n=\frac{4T_{2n}-T_n}3,C_n=\frac{16S_{2n}-S_n}{15},R_n=\frac{64C_{2n}-C_n}{63}$ </p></li><li><p>高斯求积公式：在高斯求积公式中， 如果选择 n 个节点和求积公式，使其代数精度为 2m-1 ，这样的求积公式叫做高斯求积公式</p><blockquote><p>通常令 $f(x)=1,x,x^2,…,x^k$ ，带入 $\int_a^bf(x)dx=\sum\limits_{i=1}^nA_if(x_i)$ 得到方程组，求解得到 $A_i,x_i$</p><p>两点高斯求积公式：$\int_{-1}^1f(x)dx=1\cdot f(\frac{-1}{\sqrt3})+1\cdot f(\frac{1}{\sqrt3})$</p></blockquote></li><li><p>勒让德多项式 $P_n(x)=\frac{n!}{(2n!)}\frac{d^{n}}{dx^n}[(x^2-1)^n]$ </p><ul><li>正交性：$\int_{-1}^1P_n^2(x)dx=\frac{2}{2n+1}$，勒让德多项式对一切次数低于 n 次的多项式正交</li><li>奇偶性：n 为奇数，Pn(x) 为奇函数；n 为偶数，Pn(x) 为偶函数</li><li>$P_n(\pm1)=\frac{(\pm 2)^nn!}{(2n)!}$ </li><li>递推公式：$P_{n+1}(x)=xP_n(x)-\frac{n^2}{4n^2-1}P_{n-1}(x)$ </li><li>Pn(x) 的 n 个零点在（-1,1）上而且都是单根</li></ul></li><li><p>向前差商：$f’(a)=\frac{f(a+h)-f(a)}{h}$ ；中间差商：$f’(a)=\frac{f(a+h)-f(a-h)}{2h}$  </p></li><li><p>利用外推公式求导数$f’(a)$：</p><ul><li>先用中间差商法求，得到一个关于 <em>h</em> 的函数：$f’(a)=\frac{f(a+h)-f(a)}{h}$ ，记为 G_0(h)</li><li>将步长二分，得到 G_0(h/2)，等等 </li><li>对 G_0(h) 进行修正，得到 G_1(h) = [4G(h/2) - G(h)] / 3</li><li>同理，得到 G_n</li></ul></li></ul><h1 id="常微分方程数值解"><a href="#常微分方程数值解" class="headerlink" title="常微分方程数值解"></a>常微分方程数值解</h1><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/2020%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%95%B0%E5%80%BC%E8%A7%A3.png" alt=""></p><h1 id="线性代数方程组求解"><a href="#线性代数方程组求解" class="headerlink" title="线性代数方程组求解"></a>线性代数方程组求解</h1><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/2020%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E8%A7%A3%E6%B3%95.png" alt=""></p><h1 id="非线性方程求解"><a href="#非线性方程求解" class="headerlink" title="非线性方程求解"></a>非线性方程求解</h1><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/2020%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90%E6%96%B9%E7%A8%8B%E6%B1%82%E6%A0%B9.png" alt=""></p><hr><p>Learning By Sharing，2018-2020©Fu_Qingchen，Markdown，LaTeX</p>]]></content>
    
    
    <categories>
      
      <category>数学相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MATLAB</tag>
      
      <tag>数值分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>毕业纪念：武汉理工大学</title>
    <link href="/2020/09/01/CommemorationWHUT/"/>
    <url>/2020/09/01/CommemorationWHUT/</url>
    
    <content type="html"><![CDATA[<p>武汉理工大学一些资源的汇总</p><span id="more"></span><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/whut_names.png" alt="全年级姓名合影"></p><blockquote><p>武汉理工大学物流工程学院2020届毕业生姓名合影</p></blockquote><h1 id="毕业相关"><a href="#毕业相关" class="headerlink" title="毕业相关"></a>毕业相关</h1><h2 id="毕业晚会"><a href="#毕业晚会" class="headerlink" title="毕业晚会"></a>毕业晚会</h2><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200830145748.png" alt=""></p><p><a class="btn" href="https://www.bilibili.com/video/BV1ii4y1G7bk" title="https://www.bilibili.com/video/BV1ii4y1G7bk">毕业晚会开场视频</a>  <a class="btn" href="https://www.bilibili.com/video/BV1Xz4y1Q7BP" title="https://www.bilibili.com/video/BV1Xz4y1Q7BP">毕业晚会（部分）</a></p><h2 id="毕业礼盒"><a href="#毕业礼盒" class="headerlink" title="毕业礼盒"></a>毕业礼盒</h2><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/毕业礼盒_1.jpg" alt=""></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/毕业礼盒_2.jpg" alt=""></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/毕业礼盒_3.jpg" alt=""></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/毕业礼盒_4.jpg" alt=""></p><h1 id="班级相关"><a href="#班级相关" class="headerlink" title="班级相关"></a>班级相关</h1><h2 id="毕业合影"><a href="#毕业合影" class="headerlink" title="毕业合影"></a>毕业合影</h2><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/武汉理工大学物流工程学院机设1606合照2M.jpg" alt=""></p><p><a class="btn" href="https://pic.wuter.cn/2020/08/30/88b27b5d0db0f.png" title="https://pic.wuter.cn/2020/08/30/88b27b5d0db0f.png">亓鹏木木图床原图下载</a>  <a class="btn" href="https://pan.baidu.com/s/1HoGMRIwd0lw9slczRBvDEA" title="https://pan.baidu.com/s/1HoGMRIwd0lw9slczRBvDEA">百度网盘原图下载（提取码：yct0）</a></p><h2 id="情景短片"><a href="#情景短片" class="headerlink" title="情景短片"></a>情景短片</h2><ul><li><p><a class="btn" href="https://www.bilibili.com/video/BV1Vx411772k?p=1" title="https://www.bilibili.com/video/BV1Vx411772k?p=1">〔团支部〕没事请挂机</a></p></li><li><p><a class="btn" href="https://www.bilibili.com/video/BV1Vx411772k?p=2" title="https://www.bilibili.com/video/BV1Vx411772k?p=2">〔政治课〕晓琳的故事</a></p></li><li><p><a class="btn" href="https://www.bilibili.com/video/BV1Vx411772k?p=3" title="https://www.bilibili.com/video/BV1Vx411772k?p=3">〔心理课〕拖延症</a></p></li></ul><h1 id="ICADCS相关"><a href="#ICADCS相关" class="headerlink" title="ICADCS相关"></a>ICADCS相关</h1><p>2019年11月在北京参加比赛时的合影：</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/7a2eb739471500ee.jpg" alt=""></p><p>2019年5月底在武汉参加比赛时的合影：</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/DSC_94692.JPG" alt=""></p><h1 id="全景校园"><a href="#全景校园" class="headerlink" title="全景校园"></a>全景校园</h1><ul><li><p><a class="btn" href="https://720yun.com/t/ebvkOw29Op7" title="https://720yun.com/t/ebvkOw29Op7">余家头校区航海楼</a></p></li><li><p><a class="btn" href="https://720yun.com/t/3avkOw29g1q" title="https://720yun.com/t/3avkOw29g1q">余家头校区航海楼夜景</a></p></li><li><p><a class="btn" href="https://720yun.com/t/bcvkOw29gqw" title="https://720yun.com/t/bcvkOw29gqw">余家头校区航海楼2楼大厅</a></p></li><li><p><a class="btn" href="https://720yun.com/t/d4vkOw29Oqw" title="https://720yun.com/t/d4vkOw29Oqw">余家头校区水运湖</a></p></li><li><p><a class="btn" href="https://720yun.com/t/06vkO9p7d89" title="https://720yun.com/t/06vkO9p7d89">余家头校区主楼</a></p></li><li><p><a class="btn" href="https://720yun.com/t/advkOw29Ofw" title="https://720yun.com/t/advkOw29Ofw">余家头校区图书馆</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>武汉理工大学</tag>
      
      <tag>毕业纪念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理论力学回顾</title>
    <link href="/2020/04/09/WHUT/ReviewTheoreticalMechanics/"/>
    <url>/2020/04/09/WHUT/ReviewTheoreticalMechanics/</url>
    
    <content type="html"><![CDATA[<p>最近搞毕业设计遇到了一些理论力学的问题，发现自己忘记的好快，所以来回顾一下。理论力学是各种力学的基础，讨论物体不失效，不变形情况下运动和力的关系</p><span id="more"></span><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>理论力学主要分为三大部分：</p><ul><li>静力学：讨论静止状态下物体的受力，主要包括力的平衡，力系的简化。</li><li>运动学：讨论物体的运动状态，主要包括运动的描述，复合运动速度和加速度的求解。</li><li>动力学：讨论力和物体的关系。主要解决给定力求运动轨迹、速度。动力学求解方法有很多种，任意一种即可。</li></ul><h2 id="静力学"><a href="#静力学" class="headerlink" title="静力学"></a>静力学</h2><p>静力学内容比较少，也比较简单，其主要思想是分而治之。这一块的核心就是画受力分析图，然后根据受力分析图求解约束力。其中要注意的地方就是力和力偶的概念，还有他们的相互转化。其主要内容包括：</p><ul><li>约束类型和约束力的数量和方向</li><li>受力分析图</li><li>力对点的力矩：$M_O(\vec{F})=\vec r\times \vec F$；力对轴的矩：$M_z(\vec{F})=[M_O(\vec F)]_z$</li><li>力的平移$F’\rightarrow F+M$；力偶的平移 $M\rightarrow M$</li><li>平面任意力系的平衡条件 $\vec F=0,M=0$</li><li>超静定问题的求解</li><li>摩擦角和自锁</li></ul><h2 id="运动学"><a href="#运动学" class="headerlink" title="运动学"></a>运动学</h2><p>运动学稍微多一点，但是同样比较简单，就是公式变多了。这一块的核心是选择动点动系画运动图，然后根据对应的公式进行求解。要注意点的绝对运动、相对运动、牵连运动的概念，然后有个科氏加速度。这一块的知识在机械原理中会在此用到。其主要内容是：</p><ul><li><p>点的运动的表示</p></li><li><p>点的绝对运动（动点对定系）、相对运动（动点对动系）、牵连运动（动系对静系），并且有以下关系：</p><ul><li><p>速度：$\vec{v_a} = \vec{v_e} + \vec{v_r}$</p></li><li><p>加速度（牵连运动是平动）：$\vec{a_a} = \vec{a_e} + \vec{a_r},a_r^n=v_r^2/R=\omega^2R$</p></li><li>加速度（牵连运动是转动）：$\vec{a_a} = \vec{a_e} + \vec{a_r} + \vec{a_C},a_r^n=v_r^2/R=\omega^2R,\vec{a_C}=2\vec{\omega}\times\vec{v_r}$</li></ul></li><li><p>刚体平面运动：</p><ul><li>速度：合成法（ $\vec{v_B} = \vec{v_A} + \vec{v_{BA}}$ ）、速度投影法（ $(\vec{v_A})_{AB}=(\vec{v_B})_{AB}$ ）、瞬心法</li><li>加速度：合成法（ $\vec{a_B} = \vec{a_A} + \vec{a_{BA}},\vec{a_{BA}}=\vec{a_{BA}^n}+\vec{a_{BA}^t}$ ）</li></ul></li></ul><h2 id="动力学"><a href="#动力学" class="headerlink" title="动力学"></a>动力学</h2><p>这一块内容很多很杂，求解方法也有很多。主要有两派，一派是以牛顿为主导的经典力学解法，在笛卡尔坐标系下用动量动量矩动能定理求解，另一派是以拉格朗日为主导的分析力学的解法，在广义坐标系下用拉格朗日方程求解。其中，分析力学以经典力学中的达朗贝尔原理和虚位移原理作为基础，主要研究功能关系，不需要复杂的运动学求解。</p><p>在这个里面最重要的思想是守恒，还有达朗贝尔原理、虚功原理和广义坐标系。这一块也是理论力学的核心，同时，这一块的知识在材料力学中会使用到。</p><p>经典力学主要内容如下：</p><ul><li>质心运动定理（牛二） $m\vec {a_C}=\sum \vec{F_i^{(e)}}, J_C\alpha=\sum M_C(\vec{F_i^{(e)}})$</li><li>质点系动量定理 $d(\sum m\vec v)/dt=\sum \vec {F^{(e)}_i}$</li><li>质点系动量矩定理 $d[M_O(m\vec{v_C})+J_C\omega]/dt=\sum M_O(\vec{F_i^{(e)}})$</li><li>质点系动能定理 $T_2-T_1 = \sum W$</li><li>达朗贝尔原理（动静法）：惯性力代替加速度 $\sum\vec{F_i^{(e)}} + \sum\vec{F_I}=0,\sum M_O{(\vec{F_i^{(e)}})}+\sum M_O(\vec{F_I})=0,\vec{F_{IR}}=-m\vec {a_C},M_{IC}=-J_C\alpha$</li><li>虚位移原理：设定虚位移，研究虚位移之间的关系，所有主动力虚功为零$\sum \vec{F_i}·\delta\vec{r_i}=0$</li></ul><p>分析力学主要内容如下：</p><ul><li><p>N维广义坐标下的坐标矢量 $\delta \vec{r_i}=\sum\limits_{k=1}^N(\partial\vec{r_i}/\partial q_k)\delta{q_k}$</p></li><li><p>广义坐标下的平衡条件：广义力为零 $Q_k=\sum\limits_{i=1}^n(F_{ix}\frac{\partial x_i}{\partial q_k}+F_{iy}\frac{\partial y_i}{\partial q_k}+F_{iz}\frac{\partial z_i}{\partial q_k})=0$ </p><blockquote><p>确定广义坐标-&gt;写出质点在广义坐标下的表达式-&gt;表达式对广义坐标求导-&gt;求解广义力-&gt;广义力为0求解未知量</p></blockquote></li><li><p>对保守系统（无外力的系统），质点系的势能对于每一个广 义坐标的偏导数分别等于零 $Q_k=-(\partial V/\partial q_k)=0$</p></li><li><p>动力学普遍方程：广义力与广义惯性力所作的虚功和为零 $\sum\limits_{i=1}^N(Q_k-\sum\limits_{k=1}^nm\ddot r·\frac{\partial r_i}{\partial q_k})\delta q_k=0$</p></li><li><p>拉格朗日方程</p></li></ul><script type="math/tex; mode=display">\frac{d}{dt}(\frac{\partial T}{\partial \dot {q_k}})-\frac{\partial T}{\partial {q_k}}-Q_k=0</script><h1 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sympy <span class="hljs-keyword">as</span> sym<br>sym.init_printing(use_latex=<span class="hljs-string">&quot;mathjax&quot;</span>)<br></code></pre></td></tr></table></figure><p>这个题目的来源是模拟 <a href="https://www.bilibili.com/video/BV17A411h7wJ">https://www.bilibili.com/video/BV17A411h7wJ</a> 这个视频 10:33 的内容，通过这个巩固一下自己的理论力学和编程能力。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200822205511.png" alt=""></p><p>已知两个物体通过一根绳子挂在一根柱子上，其中有一个物体有动能，该物体运动至最高处的状态如图所示，忽略摩擦以及柱子的直径，求其运动方程</p><p>取如图所示$m,M$为物体质量，$l,\theta$为有动能的物体到柱子的长度和绳子的角度，绳子总长S，易得两个物体的坐标可以表示为</p><script type="math/tex; mode=display">p_m=\left[ \begin{array}{c}-l\cos \theta\\-l\sin \theta\\\end{array} \right] ,p_M=\left[ \begin{array}{c}0\\l-L\\\end{array} \right]</script><p>对时间求导，可以得到他们的速度为</p><script type="math/tex; mode=display">\dot{p}_m=\left[ \begin{array}{c}    -\dot{l}\cos \theta +l\dot{\theta}\sin \theta\\    -\dot{l}\sin \theta -l\dot{\theta}\cos \theta\\\end{array} \right] ,\dot{p}_M=\left[ \begin{array}{c}    0\\    \dot{l}\\\end{array} \right]</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">l, theta, dl, dtheta, S = sym.symbols(<span class="hljs-string">r&#x27;l, theta, \dot&#123;l&#125;, \dot&#123;\theta&#125;, S&#x27;</span>)<br>pm, pM = sym.Matrix([-l*sym.cos(theta), -l*sym.sin(theta)]), sym.Matrix([<span class="hljs-number">0</span>, l-S])<br>dpm, dpM = sym.Matrix([-dl*sym.cos(theta) + l*dtheta*sym.sin(theta), -dl*sym.sin(theta)-l*dtheta*sym.cos(theta)]), sym.Matrix([<span class="hljs-number">0</span>, dl])<br>pm, pM, dpm, dpM<br></code></pre></td></tr></table></figure><script type="math/tex; mode=display">\left ( \left[\begin{matrix}- l \cos{\left (\theta \right )}\\- l \sin{\left (\theta \right )}\end{matrix}\right], \quad \left[\begin{matrix}0\\- S + l\end{matrix}\right], \quad \left[\begin{matrix}\dot{\theta} l \sin{\left (\theta \right )} - \dot{l} \cos{\left (\theta \right )}\\- \dot{\theta} l \cos{\left (\theta \right )} - \dot{l} \sin{\left (\theta \right )}\end{matrix}\right], \quad \left[\begin{matrix}0\\\dot{l}\end{matrix}\right]\right )</script><p>求解其动能和势能为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">m, M , g= sym.symbols(<span class="hljs-string">r&quot;m, M, g&quot;</span>)<br>T = (<span class="hljs-number">1</span>/<span class="hljs-number">2</span>*m*dpm.T*dpm + <span class="hljs-number">1</span>/<span class="hljs-number">2</span>*M*dpM.T*dpM)[<span class="hljs-number">0</span>]<br>V = m*g*pm[<span class="hljs-number">1</span>] + M*g*pM[<span class="hljs-number">1</span>]<br>T, V<br></code></pre></td></tr></table></figure><script type="math/tex; mode=display">\left ( 0.5 M \dot{l}^{2} + 0.5 m \left(\dot{\theta} l \sin{\left (\theta \right )} - \dot{l} \cos{\left (\theta \right )}\right)^{2} + 0.5 m \left(- \dot{\theta} l \cos{\left (\theta \right )} - \dot{l} \sin{\left (\theta \right )}\right)^{2}, \quad M g \left(- S + l\right) - g l m \sin{\left (\theta \right )}\right )</script><p>L = T - V为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">L = T - V<br>L<br></code></pre></td></tr></table></figure><script type="math/tex; mode=display">0.5 M \dot{l}^{2} - M g \left(- S + l\right) + g l m \sin{\left (\theta \right )} + 0.5 m \left(\dot{\theta} l \sin{\left (\theta \right )} - \dot{l} \cos{\left (\theta \right )}\right)^{2} + 0.5 m \left(- \dot{\theta} l \cos{\left (\theta \right )} - \dot{l} \sin{\left (\theta \right )}\right)^{2}</script><p>由拉格朗日方程得</p><script type="math/tex; mode=display">\frac{d}{dt}\left( \frac{\partial L}{\partial \dot{l}} \right) -\frac{\partial L}{\partial l}=0\\\frac{d}{dt}\left( \frac{\partial L}{\partial \dot{\theta}} \right) -\frac{\partial L}{\partial \theta}=0</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">func_temp = sym.Matrix([[sym.diff(L, dl), sym.diff(L, l)], <br>            [sym.diff(L, dtheta), sym.diff(L,  theta)]])<br>sym.simplify(func_temp)<br></code></pre></td></tr></table></figure><script type="math/tex; mode=display">\left[\begin{matrix}1.0 \dot{l} \left(M + m\right) & - 1.0 M g + 1.0 \dot{\theta}^{2} l m + 1.0 g m \sin{\left (\theta \right )}\\1.0 \dot{\theta} l^{2} m & g l m \cos{\left (\theta \right )}\end{matrix}\right]</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">ddl, ddtheta = sym.symbols(<span class="hljs-string">r&quot;\ddot&#123;l&#125;, \ddot&#123;\theta&#125;&quot;</span>)<br>dLddl = ddl*(M + m)<br>dLddtheta = ddtheta*l**<span class="hljs-number">2</span>*m + <span class="hljs-number">2</span>*dtheta*l*m*dl<br>sym.simplify(sym.Matrix([dLddl-sym.diff(L, l), dLddtheta-sym.diff(L,  theta)]))<br></code></pre></td></tr></table></figure><script type="math/tex; mode=display">\left[\begin{matrix}1.0 M \ddot{l} + 1.0 M g + 1.0 \ddot{l} m - 1.0 \dot{\theta}^{2} l m - 1.0 g m \sin{\left (\theta \right )}\\l m \left(\ddot{\theta} l + 2 \dot{\theta} \dot{l} - g \cos{\left (\theta \right )}\right)\end{matrix}\right]</script><p>整理得到微分方程</p><script type="math/tex; mode=display">\left( m+M \right) \ddot{l}=ml\dot{\theta}^2+mg\sin \theta -Mg\\l\ddot{\theta}=g\cos \theta -2\dot{l}\dot{\theta}</script><p>取初始条件</p><script type="math/tex; mode=display">\left[ \begin{array}{c}    l_0\\    \theta_0\\\end{array} \right] =\left[ \begin{array}{c}    3\\    0\\\end{array} \right] ,\left[ \begin{array}{c}    \dot{l}_0\\    \dot{\theta}_0\\\end{array} \right] =\left[ \begin{array}{c}    0\\    0\\\end{array} \right] ,\left[ \begin{array}{c}    \ddot{l}_0\\    \ddot{\theta}_0\\\end{array} \right] =\left[ \begin{array}{c}    0\\    0\\\end{array} \right]</script><p>用数值（暴力）解法可以写出迭代式</p><script type="math/tex; mode=display">\ddot{l}_i=\frac{ml_{i-1}\dot{\theta}_{i-1}^{2}+mg\sin \theta _{i-1}-Mg}{m+M}\\\ddot{\theta}_i=\frac{g\cos \theta _{i-1}-2\dot{l}_{i-1}\dot{\theta}_{i-1}}{l_{i-1}}\\\dot{l}_i=\dot{l}_{i-1}+\ddot{l}_i\Delta t\\\dot{\theta}_i=\dot{\theta}_{i-1}+\ddot{\theta}_i\Delta t\\l_i=l_{i-1}+\dot{l}_i\Delta t\\\theta _i=\theta _{i-1}+\dot{\theta}_{i-1}\Delta t</script><p>这样就可以求解出位置关于时间的函数，绘制成动画如下</p><iframe id=sbrxp src="//player.bilibili.com/player.html?aid=8970989&bvid=BV1Xx411k7FE&cid=204595985&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width: 720px; height: 430px; max-width: 100%"> </iframe>]]></content>
    
    
    <categories>
      
      <category>机械相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>课程设计：65t-55m岸桥挂舱保护液压缸设计</title>
    <link href="/2020/01/18/WHUT/CourseDesignOnHydraulicElementsAndTransitionSystems/"/>
    <url>/2020/01/18/WHUT/CourseDesignOnHydraulicElementsAndTransitionSystems/</url>
    
    <content type="html"><![CDATA[<p>放在这留作纪念，首次电子化了的课程设计，然后为了放抄袭故意设置了一些<strong>明显错误</strong>。</p><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> math<br></code></pre></td></tr></table></figure><h1 id="要求完成的主要任务"><a href="#要求完成的主要任务" class="headerlink" title="要求完成的主要任务"></a>要求完成的主要任务</h1><ol><li>所设计的挂舱保护液压缸为双作用单杆活塞缸，采用中间耳轴联接；能在海洋环境条件下可靠工作；具有回程速度快、内泄漏量极小、无外泄漏以及使用寿命长等特点；</li><li>完成所设计挂舱保护液压缸的设计计算；</li><li>完成所设计挂舱保护液压缸的结构设计，并绘制该挂舱保护液压缸的装配图；</li><li>撰写挂舱保护液压缸设计计算说明书。</li></ol><h1 id="液压缸设计方案的分析与拟定"><a href="#液压缸设计方案的分析与拟定" class="headerlink" title="液压缸设计方案的分析与拟定"></a>液压缸设计方案的分析与拟定</h1><h2 id="挂舱保护原理"><a href="#挂舱保护原理" class="headerlink" title="挂舱保护原理"></a>挂舱保护原理</h2><p>​        岸桥（岸边集装箱起重机）是现代港口集装箱装卸的关键设备，其作业效率反映了码头的装卸能力，其安全性能则是整条作业线连续运行指标及过程控制管理水准的体现。岸桥在工作过程中发生的事故主要有吊具与滑道或集装箱与滑道间出现钩挂，以及集装箱与下层集装箱之间的锁销未打开，从而出现所谓的挂舱现象。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/图 1 挂舱保护系统.png" alt="图 1 挂舱保护系统"></p><p>​        液压挂舱保护系统是目前主流的挂舱保护系统。它利用岸桥尾部的 4 个液压油缸来实现挂舱保护功能，其位置可以参考图 1 中液压油缸 1~4。岸桥正常工作时，液压缸活塞杆伸出一定距离，并锁定保持在该位置上，此阶段液压缸起支撑作用。此系统通过压力继电器来检测液压系统压力。当压力继电器检测到系统压力达到挂舱设定压力时，就会发出挂舱信号给 PLC，PLC 会令驱动断电或增加反力矩。反力矩是否施加取决于具体控制系统情况。同时，制动器闭合，使电机、卷筒快速停止。在压力继电器发信号的同时，液压系统溢流阀在钢丝绳力作用下溢流，液压油缸在钢丝绳力作用下快速回缩，抵消在此过程中吊具的起升位移，阻止钢丝绳力进一步增大，达到保护岸桥的目的。</p><h2 id="挂舱保护液压缸的特性分析"><a href="#挂舱保护液压缸的特性分析" class="headerlink" title="挂舱保护液压缸的特性分析"></a>挂舱保护液压缸的特性分析</h2><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/图 2 挂舱保护液压缸的布置.png" alt="图 2 挂舱保护液压缸的布置"></p><p>​        通过挂舱保护的工作原理和液压缸的布置方式可知，所设计的挂舱保护液压缸为双作用单杆活塞缸，采用中间耳轴联接，杆端采用带关节轴承的耳环连接；能够在海洋环境下可靠工作；具有回程快、内泄漏量极少、无外泄漏以及使用寿命长等特点。</p><h2 id="液压缸的设计要求"><a href="#液压缸的设计要求" class="headerlink" title="液压缸的设计要求"></a>液压缸的设计要求</h2><p>​        根据设计任务书，主要技术指标为：</p><ol><li>挂舱保护液压缸额定压力：$p_1 = 31.5$MPa； </li><li>挂舱保护液压缸最大推力：$F_1 = 275$kN, 挂舱时的回程力 $F_2 = 600$kN</li><li>工作行程 $l = 1000$mm；</li><li>挂舱时液压缸回程速度：$v_2 = 0.8$m/s 。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">p_1 =   <span class="hljs-number">20000000</span><span class="hljs-comment">#@param &#123;type: &quot;number&quot;&#125; 计算时按照20MPa计算</span><br>F_1 =   <span class="hljs-number">275000</span><span class="hljs-comment">#@param &#123;type: &quot;number&quot;&#125;</span><br>F_2 =   <span class="hljs-number">600000</span><span class="hljs-comment">#@param &#123;type: &quot;number&quot;&#125;</span><br>l =   <span class="hljs-number">1</span><span class="hljs-comment">#@param &#123;type: &quot;number&quot;&#125;</span><br>v_2 =   <span class="hljs-number">0.8</span><span class="hljs-comment">#@param &#123;type: &quot;number&quot;&#125;</span><br></code></pre></td></tr></table></figure><h2 id="液压缸材料的选取"><a href="#液压缸材料的选取" class="headerlink" title="液压缸材料的选取"></a>液压缸材料的选取</h2><p>​        根据《机械设计手册》和设计要求并参考同类型设计案例，缸体材料选择 20 号无缝钢管，缸盖、活塞选择 45 号钢，活塞杆选择 304 不锈钢。</p><h1 id="液压缸主要技术参数的计算及校核"><a href="#液压缸主要技术参数的计算及校核" class="headerlink" title="液压缸主要技术参数的计算及校核"></a>液压缸主要技术参数的计算及校核</h1><p>​        液压缸的性能参数主要有缸筒内径 $D$、活塞杆外径 $𝑑$、活塞行程 $S$、缸筒长度 $𝐿_1$和最小导向长度 $H$。</p><h2 id="缸筒的内径-D"><a href="#缸筒的内径-D" class="headerlink" title="缸筒的内径 $D$"></a>缸筒的内径 $D$</h2><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/图 3 双作用液压液压缸筒图.png" alt="图 3 双作用液压液压缸筒图"></p><p>​        缸筒内径即活塞外径，是液压缸的主要参数，根据液压缸推力要求计算缸筒内径。为得到所要求的推力 $F$ ，应使</p><script type="math/tex; mode=display">pA\eta_{\text{cm}} = F</script><p>式中</p><ul><li>p——作用在活塞上的有效压力（Pa），p 应比液压缸额定压力小，取 p = 20MPa；</li><li>A——液压缸的有效工作面积 （$\text{m}^2$），$A = \pi D^2/4$；</li><li>$\eta_{\text{cm}}$——液压缸的机械效率，取 $\eta_{\text{cm}} = 0.95$； </li><li>F——液压缸推力（N）, F = 300kN。</li></ul><p>​        计算得缸筒内径 D为</p><script type="math/tex; mode=display">D = \sqrt{\frac{4F_{1}}{\text{π}p\eta_{\text{cm}}}} = 141.8\text{mm}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">eta_cm = <span class="hljs-number">0.95</span><br>D = math.sqrt((<span class="hljs-number">4</span>*F_1)/(math.pi*p_1*eta_cm))<br><span class="hljs-built_in">print</span>(D)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0.13575149021226632</code></pre><p>​        根据 GB/T 2348-1993， 将缸筒内径圆整为标准值为</p><script type="math/tex; mode=display">D = 160\text{mm}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">D = <span class="hljs-number">0.160</span><br></code></pre></td></tr></table></figure><h2 id="活塞杆直径-d"><a href="#活塞杆直径-d" class="headerlink" title="活塞杆直径 $d$"></a>活塞杆直径 $d$</h2><p>​        设计要求不涉及到速度比，因此按照活塞杆受力状况来确定。由于活塞杆长度没有确定，为了安全起见，同时校核强度条件和弯曲稳定性条件。</p><p>​        (1) 活塞杆直径的确定</p><p>​        液压缸工作时受压力，工作压力大于7MPa，活塞杆直径 d = 0.7D = 112mm，圆整为标准值得</p><script type="math/tex; mode=display">d = 110\text{mm}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">d = <span class="hljs-number">0.110</span><br></code></pre></td></tr></table></figure><p>​        (2) 按强度条件校核</p><p>​        按照强度条件校核活塞杆的直径 d，即</p><script type="math/tex; mode=display">d \geq \sqrt{\frac{4Fn_{\text{s}}}{\pi\sigma_{\text{s}}}} = 86\text{mm}</script><p>式中</p><ul><li>F——活塞杆最大推力，F = 600kN；</li><li>$\sigma_\text{s}$——缸筒材料的屈服极限，取$\sigma_\text{s} = 355$MPa；</li><li>$n_\text{s}$——缸简屈服安全系数，取 $n_\text{s} = 2$。</li></ul><p>所选活塞杆直径符合强度要求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">sigma_s_45 = <span class="hljs-number">205</span>*<span class="hljs-number">10</span>**<span class="hljs-number">6</span><br><span class="hljs-built_in">print</span>(math.sqrt(<span class="hljs-number">4</span>*F_2*n_s/(math.pi*sigma_s_45)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">0.086331393653508521743414.4123473573</code></pre><p>​        (3) 按弯曲稳定性校核</p><p>​        根据经验，取活塞杆全部伸出后，活塞杆外端到液压缸支撑点之间的距离$($即活塞杆计算长度$)$ <em>l</em> = 2200mm。</p><p>​        按材料力学理论，当一受压直杆的轴向载荷<em>F</em>超过临界受压载荷$F_{K}$时，即可能失去原有直线状态的平衡，称为失稳。对液压缸，其稳定条件为</p><script type="math/tex; mode=display">F \leq \frac{F_{K}}{n_{K}}</script><p>式中</p><ul><li><em>F</em>——活塞杆最大推力，<em>F</em> = 600kN；</li><li>$F_{K}$——液压缸的临界受压载荷；</li><li>$n_{K}$——稳定安全系数，取$n_{K} =$ 2。</li></ul><p>​        挂舱保护液压缸不受偏心载荷的情况，细长比$\ l/K &gt; m\sqrt{n}$，用戈登·兰金公式计算临界载荷$F_{K}$</p><script type="math/tex; mode=display">F_{K} = \frac{fA}{1 + \frac{a}{n}{(\frac{l}{K})}^{2}} = 1743\text{kN}</script><p>式中 </p><ul><li><em>K</em>——活塞杆横截面回转半径，$K = d/$4</li><li>$m$——柔性系数，活塞杆为304不锈钢，取$\ m =$ 90；</li><li>$n$——端点安装系数，安装方式为两端铰接，取$\ n =$ 1；</li><li>$f$——材料强度实验值，活塞杆为304不锈钢，取$\ f$ = 340MPa；</li><li>$A$——活塞杆横截面面积；</li><li>$a$——实验常量，取 $a =$ 1/7500。</li></ul><p>​        根据稳定条件，活塞杆直径符合稳定性要求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-number">340</span>*<span class="hljs-number">10</span>**<span class="hljs-number">6</span>*math.pi*d**<span class="hljs-number">2</span>/<span class="hljs-number">4</span>/(<span class="hljs-number">1</span>+<span class="hljs-number">80</span>**<span class="hljs-number">2</span>/<span class="hljs-number">7500</span>))<br></code></pre></td></tr></table></figure><h2 id="最小导向长度-H"><a href="#最小导向长度-H" class="headerlink" title="最小导向长度 $H$"></a>最小导向长度 $H$</h2><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/图 4 液压缸最小导向长度.png" alt="图 4 液压缸最小导向长度"></p><p>​        当活塞杆全部外伸时，从活塞支承面中点到导向套滑动面中点的距离称为最小导向长度。导向长度过小，将使液压缸的初始挠度（由间隙引起的挠度）增大，影响液压缸的稳定性。由《机械设计手册》，最小导向长度 $H$ 应满足</p><script type="math/tex; mode=display">H \geq \frac{L}{20} + \frac{D}{2} = 130\text{mm}</script><p>式中 </p><ul><li><em>L</em>——液压缸最大行程，<em>L</em> = 1000mm；</li><li><em>D</em>——缸筒内径, <em>D</em> = 160mm。</li></ul><p>取 $H = 130\text{mm}$ 。</p><p>​        活塞宽度 $B = (0.6 \sim 1.0)D$，取 $B = 100$mm。由于 $D &gt; 80$mm，导向套滑动面长度 $A = (0.6 \sim 1.0)d$，取 $d = 80$mm。轴套长度 $C = H - \frac{1}{2}(A + B) = 40$mm。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">H = l/<span class="hljs-number">20</span> + D/<span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(H)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0.13</code></pre><h2 id="缸筒长度-L"><a href="#缸筒长度-L" class="headerlink" title="缸筒长度 ${L}_$"></a>缸筒长度 ${L}_1$</h2><p>​        缸筒长度由最大行程长度加上各种结构需求来确定，即</p><script type="math/tex; mode=display">L_{1} = S + B + H + M + C = 1135\text{mm}</script><p>式中 </p><ul><li>$S$——活塞杆的最大工作行程；</li><li>$B$——活塞宽度；</li><li>$H$——活塞杆导向长度；</li><li>$M$——活塞杆密封长度；</li><li>$C$——其他长度。</li></ul><h1 id="液压缸主要结构技术参数的计算及校核"><a href="#液压缸主要结构技术参数的计算及校核" class="headerlink" title="液压缸主要结构技术参数的计算及校核"></a>液压缸主要结构技术参数的计算及校核</h1><h2 id="缸筒壁厚-delta"><a href="#缸筒壁厚-delta" class="headerlink" title="缸筒壁厚 $\delta$"></a>缸筒壁厚 $\delta$</h2><p>​        根据力士乐、洪格尔等公司液压缸壁厚数据，选择壁厚 $\delta = 25\text{mm}$。</p><p>​        $\delta/D = 0.16 \leq 0.25$, 按第一强度理论，按薄壁圆筒的中径公式校核</p><script type="math/tex; mode=display">\delta \leq \frac{p_{\max}D}{2\lbrack\sigma\rbrack} = 19.5\text{mm}</script><p>式中 </p><ul><li>$p_{\max}$——液压缸瞬间能承受的最高压力，$p_{\max} = 1.5p_{n} = 30\text{MPa}$；</li><li>$\delta$——缸筒壁厚；</li><li>$D$——缸筒内径；</li><li>$[\sigma]$——缸筒材料的许用应力，缸筒材料为20钢，$[\sigma] = \sigma_s/n_s = 122.5MPa$，$\sigma_s$ 为缸筒材料的屈服极限，取$\sigma_s = 245MPa$，$n_s$ 为缸简屈服安全系数，取 $n_s = 2$。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">delta = <span class="hljs-number">0.025</span><br><span class="hljs-built_in">print</span>(delta/D)<br>p_max = <span class="hljs-number">1.5</span>*p_1<br><span class="hljs-built_in">print</span>(p_max)<br>sigma_s_20 = <span class="hljs-number">245</span>*<span class="hljs-number">10</span>**<span class="hljs-number">6</span><br>n_s = <span class="hljs-number">2</span><br>sigma_20 = sigma_s_20/n_s<br><span class="hljs-built_in">print</span>(sigma_20)<br><span class="hljs-built_in">print</span>(p_max*D/<span class="hljs-number">2</span>/sigma_20)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0.1562530000000.0122500000.00.019591836734693877</code></pre><p>​        强度符合要求。</p><h2 id="油口尺寸"><a href="#油口尺寸" class="headerlink" title="油口尺寸"></a>油口尺寸</h2><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/图 5 油口直径.png" alt="图 5 油口直径"></p><p>​        油管的有效通油直径，应保证油液流速在4.5m/s以下，这样可以减少压力损失，提高效率，减轻振动和噪声。</p><h3 id="回程流量的计算"><a href="#回程流量的计算" class="headerlink" title="回程流量的计算"></a>回程流量的计算</h3><p>​        液压缸无杆腔的回程流量 $q_1$ 为</p><script type="math/tex; mode=display">q_{1} = \frac{\pi D^{2}v_{2}}{4\eta_{\text{cV}}} = 0.016\text{m}^{3}/\text{s}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">eta_cV = <span class="hljs-number">1</span><br>q_1 = (math.pi*D**<span class="hljs-number">2</span>*v_2)/(<span class="hljs-number">4</span>*eta_cV)<br><span class="hljs-built_in">print</span>(q_1)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0.016084954386379743</code></pre><p>​        有杆腔回程流量 $q_2$ 为</p><script type="math/tex; mode=display">q_{2} = \frac{\pi(D^{2} - d^{2})v_{2}}{4\eta_{\text{cV}}} = 0.008\text{m}^{3}/\text{s}</script><p>式中：</p><ul><li>D——活塞直径，D = 160mm；</li><li>d——活塞杆直径，d = 110mm</li><li>$v_2$——回程速度, $v_2 = 0.8$m/s；</li><li>$\eta_{\text{cV}}$——液压缸容积效率，泄漏量小，取 $\eta_{\text{cV}} = 1$。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">q_2 = (math.pi*(D**<span class="hljs-number">2</span>-d**<span class="hljs-number">2</span>)*v_2)/(<span class="hljs-number">4</span>*eta_cV)<br><span class="hljs-built_in">print</span>(q_2)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0.008482300164692444</code></pre><h3 id="油口直径的计算"><a href="#油口直径的计算" class="headerlink" title="油口直径的计算"></a>油口直径的计算</h3><p>​        油口的通流面积，应保证油液流速 $v’$ 在4.5m/s以下，</p><p>​        对无杆腔，油口直径为</p><script type="math/tex; mode=display">d' \geq \sqrt{\frac{v_2}{v'}}D = 67\text{mm}</script><p>​        圆整为 </p><script type="math/tex; mode=display">d' = 70\text{mm}</script><p>​        对有杆腔，油口直径为</p><script type="math/tex; mode=display">d'' \geq \sqrt{\frac{v_2}{v'}(D^2 - d^2)} = 49\text{mm}</script><p>式中:</p><ul><li>$d’$——无杆腔油口直径；</li><li>$d’’$——有杆腔油口直径；</li><li>$v’$——油液速度，$v’ = 4.5$m/s；</li><li>$v_2$——回程速度, $v_2 = 0.8$m/s；</li><li>D——活塞直径，D = 160mm；</li><li>d——活塞杆直径，d = 110mm。</li></ul><p>​        圆整为 </p><script type="math/tex; mode=display">d'' = 50\text{mm}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">v_pie = <span class="hljs-number">4.5</span><br>d_pie = math.sqrt(v_2/v_pie)*D<br><span class="hljs-built_in">print</span>(d_pie)<br>d_piepie = math.sqrt(v_2/v_pie*(D**<span class="hljs-number">2</span> - d**<span class="hljs-number">2</span>))<br><span class="hljs-built_in">print</span>(d_piepie)<br>d_pie = <span class="hljs-number">0.070</span><br>d_piepie = <span class="hljs-number">0.050</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">0.067461923416925430.048989794855663564</code></pre><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/图 6 油口安装尺寸.png" alt="图 6 油口安装尺寸"></p><h1 id="液压缸的结构设计"><a href="#液压缸的结构设计" class="headerlink" title="液压缸的结构设计"></a>液压缸的结构设计</h1><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/图 7 液压缸结构.png" alt="图 7 液压缸结构"></p><p>​        如图7所示，本设计采用中间耳轴的安装方式，耳轴与缸筒焊接。活塞杆端部用螺纹与连接耳轴，耳轴通过关节轴承连接其他机械部件。活塞杆与活塞处采用螺纹连接。缸筒与缸盖、缸筒与缸底采用整体螺钉连接方式。</p><h1 id="液压缸主要零部件的计算与选择"><a href="#液压缸主要零部件的计算与选择" class="headerlink" title="液压缸主要零部件的计算与选择"></a>液压缸主要零部件的计算与选择</h1><h2 id="液压缸的连接计算"><a href="#液压缸的连接计算" class="headerlink" title="液压缸的连接计算"></a>液压缸的连接计算</h2><h3 id="活塞杆连接螺纹的计算"><a href="#活塞杆连接螺纹的计算" class="headerlink" title="活塞杆连接螺纹的计算"></a>活塞杆连接螺纹的计算</h3><p>​        (1) 螺纹外径的计算</p><p>​        假设可忽略螺顶与螺底的尺寸差别，则可用下式概略计算</p><script type="math/tex; mode=display">d_0 = 1.38\sqrt{\frac P{[\sigma]}} = 54\text{mm}</script><p>式中：</p><ul><li>P——活塞拉力，P = 300kN；</li><li>$[\sigma]$——缸筒材料的许用应力</li></ul><p>​        根据液压缸活塞杆螺纹尺寸系列，并为了安全适当扩大螺纹直径，选用 $\text{M}90 \times 3$ 螺纹。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">d_0_huosaigan = <span class="hljs-number">1.38</span>*math.sqrt(F_1/(sigma_s_45/n_s))<br><span class="hljs-built_in">print</span>(d_0_huosaigan)<br>d_0_huosaigan = <span class="hljs-number">0.090</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">0.07147982829902809</code></pre><p>​        (2) 螺纹强度计算</p><p>​        活塞杆与活塞连接螺纹的强度按第四强度理论校核</p><script type="math/tex; mode=display">\sigma_L = \frac{1.25P}{\frac\pi4d_1^2} = 58\text{MPa}\\\tau = \frac{20Pd_0K}{\pi d_1^3} = 17\text{MPa}\\\sigma_A = \sqrt{\sigma_L^2+3\tau^2} = 65\text{MPa} < [\sigma] = 177.5\text{MPa}</script><p>式中：</p><ul><li>$\sigma_L$——拉应力；</li><li>$\tau$——剪切应力；</li><li>$\sigma_A$——合成应力；</li><li>$d_0$——螺纹外径，取$d_0 = 56mm$；</li><li>$d_1$——螺纹底径，查标准得$d_1 = 53.9mm$；</li><li>$K$——螺纹连接摩擦因数，取$K = 0.07$。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">d_1_huosaigan = <span class="hljs-number">0.0867</span><br>K_huosaigan = <span class="hljs-number">0.07</span><br>sigma_l_huosaigan = <span class="hljs-number">1.25</span>*F_1/(math.pi/<span class="hljs-number">4</span>*d_1_huosaigan**<span class="hljs-number">2</span>)<br>tau_huosaigan = <span class="hljs-number">20</span>*F_1*d_0_huosaigan*K_huosaigan/(math.pi*d_1_huosaigan**<span class="hljs-number">3</span>)<br>sigma_a_huosaigan = math.sqrt(sigma_l_huosaigan**<span class="hljs-number">2</span> + <span class="hljs-number">3</span>*tau_huosaigan**<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(sigma_l_huosaigan, tau_huosaigan, sigma_a_huosaigan)<br></code></pre></td></tr></table></figure><pre><code class="hljs">58225688.217163235 16923729.447203156 65187948.45344264</code></pre><p>​        螺纹强度符合要求。</p><h3 id="中间耳轴焊接强度计算"><a href="#中间耳轴焊接强度计算" class="headerlink" title="中间耳轴焊接强度计算"></a>中间耳轴焊接强度计算</h3><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/图 8 耳轴焊缝.png" alt="图 8 耳轴焊缝"></p><p>​        采用角焊接，强度计算公式为</p><script type="math/tex; mode=display">\sigma = \frac{0.707P}{\pi D_{1}h\varphi} = 32.7\text{MPa} < \lbrack\sigma\rbrack</script><p>式中 </p><ul><li><em>P</em>——液压杆推力</li><li>$D_1$——缸筒外径，$D_1 = D + 2\delta = 210$mm；</li><li>$h$——焊缝有效宽度，取 $h = 15\text{mm}$，$D_{2} = D_{1} - 2h = 180\text{mm}$</li><li>$\varphi$——焊缝强度系数，取$\varphi = 0.8$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">varphi_gangdihan = <span class="hljs-number">0.8</span><br>D_1_gangdihan = D + delta*<span class="hljs-number">2</span><br>D_2_gangdihan = D_1_gangdihan - <span class="hljs-number">0.015</span>*<span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(<span class="hljs-number">4</span>*F_1/(math.pi*(D_1_gangdihan**<span class="hljs-number">2</span> - D_2_gangdihan**<span class="hljs-number">2</span>)*varphi_gangdihan))<br></code></pre></td></tr></table></figure><pre><code class="hljs">37408213.11988992</code></pre><h3 id="法兰连接螺栓强度计算"><a href="#法兰连接螺栓强度计算" class="headerlink" title="法兰连接螺栓强度计算"></a>法兰连接螺栓强度计算</h3><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/图 9 法兰连接.png" alt="图9 法兰连接"></p><p>​        初选法兰选用 $\text{M}30 \times 2$ 螺栓，螺孔数为12。</p><p>​        螺纹的拉应力</p><script type="math/tex; mode=display">\sigma = \frac{\frac{\pi}{4}d_{1}^{2}Z} = 58\text{MPa}</script><p>​        螺纹的剪应力</p><script type="math/tex; mode=display">\tau = \frac{K_{1}{KP}d_{1}}{0.2d_{1}^{3}Z} = 30\text{MPa}</script><p>​        合成应力</p><script type="math/tex; mode=display">\sigma_{A} = \sqrt{\sigma^{2} + 3\tau^{2}} = 77\text{MPa} < \lbrack\sigma_{s}\rbrack</script><p>式中 </p><ul><li>$K$——拧紧螺纹系数，挂舱保护液压缸工作时收到静载荷，$K = 1.5$；</li><li>$K_{1}$——螺纹内摩擦因数，取$K_{1} = 1.5$；</li><li>$P$——液压缸最大推力；</li><li>$d_{1}$——螺纹底径，普通螺纹$d_{1} = d_{0} - 1.224S$；</li><li>$Z$——螺栓数目。</li></ul><p>​        所选螺栓符合强度要求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">K_falan = <span class="hljs-number">1.5</span><br>K_1_falan = <span class="hljs-number">0.12</span><br>d_0_falan = <span class="hljs-number">0.030</span><br>S_falan = <span class="hljs-number">0.002</span><br>Z_falan = <span class="hljs-number">12</span><br>d_1_falan = d_0_falan - <span class="hljs-number">1.224</span>*S_falan<br>sigma_falan = K_falan*F_1/(math.pi/<span class="hljs-number">4</span>*(d_1_falan**<span class="hljs-number">2</span>-D**<span class="hljs-number">2</span>)<br>tau_falan = K_1_falan*K_falan*F_1*d_0_falan/(<span class="hljs-number">0.2</span>*(d_1_falan**<span class="hljs-number">3</span>-D**<span class="hljs-number">3</span>))<br>sigma_H_falan = math.sqrt(sigma_falan**<span class="hljs-number">2</span> + <span class="hljs-number">3</span>*tau_falan**<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(sigma_falan, tau_falan, sigma_H_falan)<br></code></pre></td></tr></table></figure><pre><code class="hljs">57656273.06676087 29583927.030689728 77135413.6543029</code></pre><h3 id="缸筒螺纹连接强度计算"><a href="#缸筒螺纹连接强度计算" class="headerlink" title="缸筒螺纹连接强度计算"></a>缸筒螺纹连接强度计算</h3><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/图 10 缸筒螺纹连接计算简图.png" alt="图 10 缸筒螺纹连接计算简图"></p><p>​        螺纹的拉应力</p><script type="math/tex; mode=display">\sigma = \frac{\text{KP}}{\frac{\pi}{4}(d_{1}^{2} - D^{2})} = 58\text{MPa}</script><p>​        螺纹的剪应力</p><script type="math/tex; mode=display">\tau = \frac{K_{1}\text{KP}d_{1}}{0.2(d_{1}^{3} - D^{3})} = 30\text{MPa}</script><p>​        合成应力</p><script type="math/tex; mode=display">\sigma_{A} = \sqrt{\sigma^{2} + 3\tau^{2}} = 77\text{MPa} < \lbrack\sigma_{s}\rbrack</script><p>式中 </p><ul><li>$K$——拧紧螺纹系数，挂舱保护液压缸工作时收到静载荷，$K = 1.5$；</li><li>$K_{1}$——螺纹内摩擦因数，取$K_{1} = 1.5$；</li><li>$P$——液压缸最大推力；</li><li>$d_{1}$——螺纹底径，普通螺纹$d_{1} = d_{0} - 1.224S$；</li><li>$Z$——螺栓数目；</li><li>$D$——缸筒内径。</li></ul><p>​        缸筒螺纹连接符合强度要求。</p><h3 id="耳轴强度计算"><a href="#耳轴强度计算" class="headerlink" title="耳轴强度计算"></a>耳轴强度计算</h3><p>​        剪切应力</p><script type="math/tex; mode=display">\tau = \frac{pD^2}{2d_0^2} = 40\text{MPa}\leq[\tau]</script><ul><li>p——液压力，p = 20MPa；</li><li>D——液压缸直径，D = 160mm；</li><li>$d_0$——铰轴直径，由《机械设计手册》，查表得铰轴直径 $d_0 = 80$mm；</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">d_0_erzhou = <span class="hljs-number">0.080</span><br>tau_erzhou = p_1*D**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*d_0_erzhou**<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(tau_erzhou)<br></code></pre></td></tr></table></figure><pre><code class="hljs">40000000.0</code></pre><h2 id="活塞杆的导向、密封和防尘"><a href="#活塞杆的导向、密封和防尘" class="headerlink" title="活塞杆的导向、密封和防尘"></a>活塞杆的导向、密封和防尘</h2><p>​        活塞杆导向套装在液压缸的有杆侧端盖内，用以对活塞杆进行导向，内装有密封装置以保证缸筒有杆腔的密封。外侧装有防尘圈，以防止活塞杆在后退时把杂质、灰尘和水分带到密封装置处，损坏密封装置。导向套采用耐磨材料，其内圈装设导向环，用作活塞杆的导向。同时，活塞与活塞杆之间也需要加装密封装置，用于保证液压缸工作的可靠性。</p><p>​        活塞、活塞杆处如图11所示：</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/图 11 活塞、活塞杆处的导向和密封.png" alt="图11 活塞、活塞杆处的导向和密封"></p><p>​        1——活塞 2——活塞支撑 3——导向带 4——格来圈 5、7——“O”型圈 6——孔用圈</p><p>​        缸盖处如图12所示：</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/图 12 缸盖处的导向、密封和防尘.png" alt="图 12 缸盖处的导向、密封和防尘"></p><p>​        1—防尘圈 2—导向带 3—轴用圈 4—斯特封</p><h3 id="活塞杆导向的选择"><a href="#活塞杆导向的选择" class="headerlink" title="活塞杆导向的选择"></a>活塞杆导向的选择</h3><p>​        导向套对活塞起导向和支撑作用，挂舱保护液压缸要求有较快的回程速度，因此需要设置导向套。由于活塞杆要在导向套中滑动，因此采用H8/h7配合。根据设计案例，选择德国进口SFK导向带。</p><h3 id="活塞杆密封的选择"><a href="#活塞杆密封的选择" class="headerlink" title="活塞杆密封的选择"></a>活塞杆密封的选择</h3><p>​        活塞装置主要用来防止液压油的泄漏，挂舱保护液压缸要求内泄漏量极少并且无外泄漏。密封装置除了具有良好的密封性能外，还需要随压力的增加能自动提高密封性，摩擦阻力小，耐油，抗腐蚀，耐磨，寿命长，制造简单，拆装方便。油缸主要采用密封圈密封，此处选用格来圈、”O”型圈和特斯封进行密封。</p><h3 id="活塞杆防尘装置的选择"><a href="#活塞杆防尘装置的选择" class="headerlink" title="活塞杆防尘装置的选择"></a>活塞杆防尘装置的选择</h3><p>​        挂舱保护液压缸放置在港口环境，需要在海洋环境下可靠工作，因此需要设置防尘防水装置。耳环与缸盖间的活塞杆使用防尘罩，并且在缸盖处设置防尘圈。</p><h2 id="耳环的选择"><a href="#耳环的选择" class="headerlink" title="耳环的选择"></a>耳环的选择</h2><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/图 13 耳环.png" alt="图 13 耳环"></p><p>​        挂舱保护液压缸耳环用于连接活塞杆与其他机械结构。</p><p>​        根据电商平台提供的技术资料，选择GIHR—-110DO型号的耳环，结构如图13所示。</p><h2 id="缓冲装置的选择"><a href="#缓冲装置的选择" class="headerlink" title="缓冲装置的选择"></a>缓冲装置的选择</h2><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/图 14 缓冲装置.png" alt="图14 缓冲装置"></p><p>​        挂舱保护液压缸质量较大，回程速度较快时，由于惯性力较大，因此具有很大的动量。 在这种情况下，当活塞运动到缸筒的终端时，会与端盖发生机械碰撞，产生很大的冲击和噪声，严重影响控制精度，甚至会引起事故。所以，挂舱保护液压缸应配有缓冲装置。缓冲装置的工作原理是：利用活塞或缸简在其运动至行程终端时，在活塞和缸盖之间封住一部分油液，强迫它从小孔或缝隙中挤出，以产生很大的阻力，使工作部件受到制动而逐渐减慢运动速度，达到避免活塞和缸盖相互撞击的目的。</p><p>​        本设计选用固定间隙缓冲装置。如图14所示，当活塞移近缸盖时，活塞上的凸台进入缸盖的凹腔，迫使封闭在回油腔中的油液从凸台和凹腔之间的环状间隙中挤压出去，使回油腔中压力升高而形成缓冲压力，从而使活塞减慢移动速度。</p><h1 id="设计图纸"><a href="#设计图纸" class="headerlink" title="设计图纸"></a>设计图纸</h1><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/图 0 工程图纸.png" alt="设计图纸"></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1]李壮云. 液压元件与系统[M]. 第3版. 北京: 机械工业出版社, 2011.6</p><p>[2]秦大同, 谢里阳. 现代机械设计手册[M]. 第4卷. 化学工业出版社 ,2011</p><p>[3]张利平. 液压气动设计手册[M]. 北京: 机械工业出版社, 1997.6</p><p>[4]王宝海, 富茂华. 岸桥挂舱保护系统[J]. 港口装卸, 2018(2): 28-30.</p><p>[5]张燕敏, 王健. 岸边集装箱起重机挂舱保护装置的设计[J]. 起重运输机械, 2012(7).</p><p>[6]丁立基. 岸边桥式起重机防挂舱系统[J]. 起重运输机械, 2017(7):31-32.</p>]]></content>
    
    
    <categories>
      
      <category>液压相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>课程设计：MQ4035门座起重机变幅机构变频调速电气控制线路设计</title>
    <link href="/2020/01/18/WHUT/CourseDesignOnMechanicalAndElectronicTransmissionAndControl/"/>
    <url>/2020/01/18/WHUT/CourseDesignOnMechanicalAndElectronicTransmissionAndControl/</url>
    
    <content type="html"><![CDATA[<p>放在这留作纪念，不过为了放抄袭故意设置了一些<strong>明显错误</strong>。</p><span id="more"></span><h1 id="准备内容"><a href="#准备内容" class="headerlink" title="准备内容"></a>准备内容</h1><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="课程设计报告书装订顺序"><a href="#课程设计报告书装订顺序" class="headerlink" title="课程设计报告书装订顺序"></a>课程设计报告书装订顺序</h3><ul><li><p>课程设计封面（采用学校规定的标准格式，如附件）</p></li><li><p>评分记录（采用学校规定的标准格式，如附件）</p></li><li><p>课程设计任务书</p></li><li><p>目录</p></li><li><p>课程设计说明书（A4纸张，至少10页，可参考以下提纲写）</p></li></ul><h3 id="特别提醒"><a href="#特别提醒" class="headerlink" title="特别提醒"></a>特别提醒</h3><ul><li><p>严禁抄袭</p></li><li><p>设计说明书要求手写</p></li><li><p>主电路图手工绘制在3号图纸上</p></li><li><p>PLC外部接线图及梯型图程序要求打印。</p></li></ul><h2 id="设计要求"><a href="#设计要求" class="headerlink" title="设计要求"></a>设计要求</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>MQ4035门座起重机变幅机构变频调速电气控制线路设计</p><h3 id="初始条件"><a href="#初始条件" class="headerlink" title="初始条件"></a>初始条件</h3><ul><li>变幅机构由一台鼠笼式异步电动机拖动,有增减幅要求</li><li>有调速要求；采用变频调速方式</li><li>为保证制动过程平稳，采用双制动器实现软制动</li><li>配置以下保护环节：过电流保护，长期过载保护，双限位保护，零位联锁保护，超负荷限制器幅度保护。</li></ul><h1 id="机电传动方案的分析与拟定"><a href="#机电传动方案的分析与拟定" class="headerlink" title="机电传动方案的分析与拟定"></a>机电传动方案的分析与拟定</h1><h2 id="变幅机构特性分析"><a href="#变幅机构特性分析" class="headerlink" title="变幅机构特性分析"></a>变幅机构特性分析</h2><p>​        变幅机构由一台电动机驱动，电动机功率为22KW，额定电流为46A，电动机过载倍数为2.86；有增减幅要求，故要求电动机能正反方向运行；分四级起动；且有调速要求。变幅机构带有部分位能负载特征，并且属于变负载机构，在全伸出时负载转矩可能超载，控制要求相对高一些；另外变幅机构运行过程中的冲击与振动较大，特别是在大小行程终点更是如此，因此其调速要求较高。为保证制动过程平稳，采用双制动器实现软制动。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@title 原始数据</span><br><span class="hljs-comment">#@markdown 以下数据均为国际单位</span><br><br>P_N = <span class="hljs-number">22000</span>  <span class="hljs-comment">#@param</span><br>I_N = <span class="hljs-number">46</span>  <span class="hljs-comment">#@param</span><br>K_Motor_overload = <span class="hljs-number">2.86</span>  <span class="hljs-comment">#@param</span><br><br></code></pre></td></tr></table></figure><h2 id="变频调速方案分析与设计"><a href="#变频调速方案分析与设计" class="headerlink" title="变频调速方案分析与设计"></a>变频调速方案分析与设计</h2><h3 id="变频调速原理"><a href="#变频调速原理" class="headerlink" title="变频调速原理"></a>变频调速原理</h3><p>​        交流电动机表达式为：</p><script type="math/tex; mode=display">n=\frac{60f_1}{p}(1-S)</script><p>​        由式子可知，异步电动机的转速 n 正比于定子电源的频率 f ，若连续调节定子电源频率 f 即可连续地改变电动机的转速n。因此，平滑地调节供电电源的频率，就能平滑，无级地调节异步电动机的转速。变频调速调速范围大，低速特性较硬，基频f=50Hz以下，属于恒转矩调速方式，在基频以上，属于恒功率调速方式，与直流电动机的降压和弱磁调速十分相似。且采用变频起动更能显著改善交流电动机的起动性能，大幅度降低电机的起动电流，增加起动转矩。所以变频调速是交流电动机的理想调速方案。</p><h3 id="变频调速控制方式分析"><a href="#变频调速控制方式分析" class="headerlink" title="变频调速控制方式分析"></a>变频调速控制方式分析</h3><p>​        变频器变频的控制方式有 U/f 控制模式和矢量控制模式两种</p><h4 id="U-f-控制模式"><a href="#U-f-控制模式" class="headerlink" title="U/f 控制模式"></a>U/f 控制模式</h4><p>​        U/f 控制即恒压频比控制方式，应用广泛。它通过调节电机供电电源电压和频率来进行调速，解决了只改变频率调速时的各种问题：频率上升时，主磁通下降，拖动力矩下降，电机拖动能力下降；频率降低时，主磁通上升，引起主磁通饱和，励磁电流急剧上升，电机发热严重。U/f 控制调速系统的机械特性可以平滑的上下移动，转差率不变，调解时有很高的运行效率。</p><h4 id="矢量控制模式"><a href="#矢量控制模式" class="headerlink" title="矢量控制模式"></a>矢量控制模式</h4><p>​        矢量控制模式基于电机多项静态和动态参数，经过复杂算法运算得到的高精度动态控制。其基本思想是在调速过程中始终维持定子电流的磁场电流分量不变，而控制转矩电流分量，它就相当于直流电机中维持励磁不变，而通过控制电枢电流来控制电机的转矩一样，能使系统具有较好的动态持性。即如果在调速过程中始终维持定子电流的磁场电流分量不变，而控制转矩电流分量，它就相当于直流电机中维持励磁不变，而通过控制电枢电流来控制电机的转矩一样，能使系统具有较好的动态持性。这就是矢量控制或称矢量变换控制的基本思想。</p><h4 id="选用模式"><a href="#选用模式" class="headerlink" title="选用模式"></a>选用模式</h4><p>​        本设计采用无速度传感器矢量控制模式。由于在变幅过程中，变幅阻力在不断变化，对电力拖动的动态性能有很高的要求，同时，变幅机构运行过程中的冲击与振动较大，其调速要求较高。矢量控制模式能很好的满足以上要求，因此选用。</p><h3 id="变频器选型计算"><a href="#变频器选型计算" class="headerlink" title="变频器选型计算"></a>变频器选型计算</h3><p>​        本设计选用安川H1000系列变频器。</p><h4 id="变频器容量"><a href="#变频器容量" class="headerlink" title="变频器容量"></a>变频器容量</h4><p>​        由经验公式，其容量按照以下公式近似计算：</p><script type="math/tex; mode=display">P_{CN}\geq\frac{kP_N}{\eta\cos\phi}=36.24kW\\I_{CN}\geq nKI_{N}=96.47A</script><p>其中：</p><ul><li>$P_N$：负载要求电动机轴输出额定功率，$P_N=22kW$</li><li>$\eta$：电动机额定负载，通常 $\eta=0.85$</li><li>$\cos\phi$：电动机额定负载时的功率因数，通常 $\cos\phi=0.75$</li><li>$I_N$：电动机额定电流，$I_N=46A$</li><li>$k$：电流波形修正系数，取 $k=1.1$</li><li>$n$：总额定电流的倍数，这里是考虑到经常出现过载负载的情况，由课本P311，$n=\frac{K_{MotorOverload}*100\%}{150\%}=1.90$</li><li>$K$：系数，一般取 $K=1.1$</li><li>$P_{CN}$：变频器额定容量</li><li>$I_{CN}$：变频器额定电流</li></ul><p>​        由安川H1000变频器设计资料得，应选用 <strong>CIMR-HB4A0112</strong> 型变频器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#计算P_&#123;CN&#125;</span><br>k = <span class="hljs-number">1.05</span><br>eta = <span class="hljs-number">0.85</span><br>cos_phi = <span class="hljs-number">0.75</span><br>p_CN = k*P_N/eta/cos_phi<br><span class="hljs-built_in">print</span>(p_CN/<span class="hljs-number">1000</span>)<br><br><span class="hljs-comment">#计算n</span><br>n = K_Motor_overload/<span class="hljs-number">1.5</span><br><span class="hljs-built_in">print</span>(n)<br><br><span class="hljs-comment">#计算I_&#123;CN&#125;</span><br>K = <span class="hljs-number">1.1</span><br>I_CN = n*K*I_N<br><span class="hljs-built_in">print</span>(I_CN)<br></code></pre></td></tr></table></figure><pre><code class="hljs">36.235294117647061.906666666666666596.47733333333333</code></pre><h3 id="制动电路设计"><a href="#制动电路设计" class="headerlink" title="制动电路设计"></a>制动电路设计</h3><p>​        通用变频器提供的制动方式主要有：能耗制动、再生制动、整流回馈等。本次设计对变幅机构的制动方式采用能耗制动，在变频刚刚减小的瞬间，电动机的同步转速随之下降，而由于机械惯性的作用，转子转速未变。当同步转速低于转子转速时，转子电流的相位几乎改变 180 度，电动机此时处于发电机状态；与此同时，电动机轴上的转矩变成了制动转矩，使电动机的转速迅速下降，此时的电动机处于再生制动状态。此时通过消耗能量而获得制动转矩的，属于能耗制动状态。</p><h4 id="制动电阻作用"><a href="#制动电阻作用" class="headerlink" title="制动电阻作用"></a>制动电阻作用</h4><p>​        电机在快速停车的过程中，由于惯性作用，会产生大量的动能，动能经过变频器回馈到直流侧，从而引起滤波电容电压的升高，当电容电压超过设定值后，就经制动电阻消耗回馈的能量。可防止电机减速过程中所形成的再生发电制动以及制动过程中的能量回馈。防止变频器和电机的损坏，同时，缩短电机减速时间。</p><h4 id="制动电阻的选用"><a href="#制动电阻的选用" class="headerlink" title="制动电阻的选用"></a>制动电阻的选用</h4><p>​        由安川H100设计资料得，应选用CIMR-HB4A0112型制动单元，下面进行验算</p><script type="math/tex; mode=display">R_B = (0.5~1)\frac{U_D}{I_E}=13.48\Omega</script><ul><li>$U_D$：最高母线电压，$U_D=1.21*1.35U_N=620V$</li><li>$I_E$：电动机额定电压，$I_E=46A$</li></ul><p>​        由设计资料，采用双制动单元并联连线，其最小可接电阻$R’=R/2=9.6\Omega&lt;13.48\Omega$，符合要求，由此可以选用</p><h3 id="变频器输入侧抗干扰措施"><a href="#变频器输入侧抗干扰措施" class="headerlink" title="变频器输入侧抗干扰措施"></a>变频器输入侧抗干扰措施</h3><h4 id="变频器输入侧装设交流电抗器的作用"><a href="#变频器输入侧装设交流电抗器的作用" class="headerlink" title="变频器输入侧装设交流电抗器的作用"></a>变频器输入侧装设交流电抗器的作用</h4><p>​        主要作用是抑制进线电源的网侧谐波，增大进线电源主回路的短路阻抗;用来限制电网电压突变和操作过电压引起的电流冲击，平滑电源电压中包含的尖峰脉冲，或平滑桥式整流电路换相时产生的电压缺陷;有效地保护变频器和改善功率因数，它既能阻止来自电网的干扰，又能减少整流单元产生的谐波电流对电网的污染。</p><h4 id="交流电抗器的规格"><a href="#交流电抗器的规格" class="headerlink" title="交流电抗器的规格"></a>交流电抗器的规格</h4><p>​        在选择交流电抗器的容量时，一般按下式进行</p><script type="math/tex; mode=display">L=\frac{(2\%-5\%)U}{2\pi fI}=0145mH</script><p>其中：</p><ul><li>U：额定电压， $U=380V/\sqrt3$</li><li>f：最大频率，$f=50Hz$</li><li>I：电流，此时考虑到超载的情况，且电抗电流值为电动机额定电流的1.1~1.2倍，$I = 1.1K_{MotorOverload}I_N$</li></ul><p>​        应选用 <strong>X002567</strong> 订货号的电阻</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">U = <span class="hljs-number">220</span><br>f = <span class="hljs-number">50</span><br>L = <span class="hljs-number">0.03</span>*U/(<span class="hljs-number">2</span>*<span class="hljs-number">3.1415</span>*f*<span class="hljs-number">1.1</span>*K_Motor_overload*I_N)<br><span class="hljs-built_in">print</span>(L*<span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0.14517449417697842</code></pre><h2 id="保护环节设计"><a href="#保护环节设计" class="headerlink" title="保护环节设计"></a>保护环节设计</h2><h3 id="变频器输入侧加自动空气断路器和接触器"><a href="#变频器输入侧加自动空气断路器和接触器" class="headerlink" title="变频器输入侧加自动空气断路器和接触器"></a>变频器输入侧加自动空气断路器和接触器</h3><p>​        自动空气断路器的作用是在安装、检查或维修变频器时，使变频器与电源隔离。同时，可避开变频器投入时直流回路电容器的完全充电电流峰值。选用原则：断路器容量为电机额定电流的1.3-1.4倍，整定值为断路器额定值的3-4倍</p><p>​        交流接触器在电路中的作用主要是便于操作，当变频器发生故障时，它能迅速切断变频器电源。选用原则：按电机额定电流选用接触器容量，无须按开端次数考核其寿命</p><h3 id="变频器与电动机之间加热继电器"><a href="#变频器与电动机之间加热继电器" class="headerlink" title="变频器与电动机之间加热继电器"></a>变频器与电动机之间加热继电器</h3><p>​        变幅机构一台变频机构只控制一台电动机。热继电器的作用是过载保护。而此时变频器已经有过载、短路相应的一系列功能，因此不需要加热继电器</p><h3 id="零位联锁保护和行程保护"><a href="#零位联锁保护和行程保护" class="headerlink" title="零位联锁保护和行程保护"></a>零位联锁保护和行程保护</h3><p>​        零位连锁保护：失压保护的一种形式，用来防止在供电中因电源电压的消失或降低引起机械设备停止运行，以及故障消失后，在没有人工操作的情况下设备自动启动运行而导致的机械或人身事故。</p><p>​        行程保护：用行程开关，根据生产机械要求运动的位置通过行程开关发出信号，再通过控制电路中的继电器和接触器改变电机工作状态。此外，还有超负荷限位器幅度保护，当超过设定重量时，他能自动的切断电源或报警，从而达到保护机械及人员的目的</p><h1 id="变幅机构PLC控制线路设计"><a href="#变幅机构PLC控制线路设计" class="headerlink" title="变幅机构PLC控制线路设计"></a>变幅机构PLC控制线路设计</h1><h2 id="PLC工作原理及特点"><a href="#PLC工作原理及特点" class="headerlink" title="PLC工作原理及特点"></a>PLC工作原理及特点</h2><p>​        PLC的输入电路是用来采集被控设备的检测信号或操作命令，输出电路是用来驱动被控设备的执行机构，而执行机构与检测信号，操作命令之间的逻辑则是靠微处理器执行用户程序来实现。PLC一般采用对用户程序循环扫描的工作方式，扫描工作方式分为自诊断、与编程器通信、读入现场信号，执行用户程序，输出结果五个阶段。一个循环结束后紧接着下一个循环开始，周而复始，直到停止运行为止</p><p>​        PLC具有抗干扰能力强，可靠性高，环境适应性好，编程方法简单易学；应用灵活，通用性好，有完善的监视和诊断功能等特点</p><h2 id="PLC输入-输出地址表"><a href="#PLC输入-输出地址表" class="headerlink" title="PLC输入/输出地址表"></a>PLC输入/输出地址表</h2><div class="table-container"><table><thead><tr><th>IO</th><th>序号</th><th>输入（输出）信号名称</th><th>PLC内部地址</th><th>器件符号</th></tr></thead><tbody><tr><td>输入</td><td>01</td><td>主令控制器零位挡</td><td>X000</td><td>SL</td></tr><tr><td>输入</td><td>02</td><td>主令控制器增幅</td><td>X001</td><td>SL</td></tr><tr><td>输入</td><td>03</td><td>主令控制器减幅</td><td>X002</td><td>SL</td></tr><tr><td>输入</td><td>04</td><td>主令控制器多速调节1</td><td>X003</td><td>SL</td></tr><tr><td>输入</td><td>05</td><td>主令控制器多速调节2</td><td>X004</td><td>SL</td></tr><tr><td>输入</td><td>06</td><td>增幅限位开关1</td><td>X005</td><td>ST1</td></tr><tr><td>输入</td><td>07</td><td>增幅限位开关2</td><td>X006</td><td>ST2</td></tr><tr><td>输入</td><td>08</td><td>减幅限位开关1</td><td>X007</td><td>ST3</td></tr><tr><td>输入</td><td>09</td><td>减幅限位开关2</td><td>X010</td><td>ST4</td></tr><tr><td>输入</td><td>10</td><td>空气断路器</td><td>X011</td><td>QF1-3</td></tr><tr><td>输入</td><td>11</td><td>超负荷限制器辅助触点</td><td>X012</td><td>TLX</td></tr><tr><td>输入</td><td>12</td><td>变频器运行信号</td><td>X013</td><td>BP1</td></tr><tr><td>输入</td><td>13</td><td>变频器故障输出</td><td>X014</td><td>BP1</td></tr><tr><td>输入</td><td>14</td><td>变频器制动单元热敏开关1</td><td>X015</td><td>ZD1</td></tr><tr><td>输入</td><td>15</td><td>变频器制动单元热敏开关2</td><td>X016</td><td>ZD2</td></tr><tr><td>输入</td><td>16</td><td>故障复位开关</td><td>X017</td><td>SB1</td></tr><tr><td>输出</td><td>17</td><td>变频器电源</td><td>Y000</td><td>KMP</td></tr><tr><td>输出</td><td>18</td><td>增幅运行</td><td>Y001</td><td>KM1</td></tr><tr><td>输出</td><td>19</td><td>减辐运行</td><td>Y002</td><td>KM2</td></tr><tr><td>输出</td><td>20</td><td>多速调节1</td><td>Y003</td><td>KM3</td></tr><tr><td>输出</td><td>21</td><td>多速调节2</td><td>Y004</td><td>KM4</td></tr><tr><td>输出</td><td>22</td><td>制动器1</td><td>Y005</td><td>KMY1</td></tr><tr><td>输出</td><td>23</td><td>制动器2</td><td>Y006</td><td>KMY2</td></tr><tr><td>输出</td><td>24</td><td>风机开关</td><td>Y007</td><td>KMF</td></tr><tr><td>输出</td><td>25</td><td>变频器故障输出</td><td>Y010</td><td>KMG</td></tr><tr><td>输出</td><td>26</td><td>故障复位</td><td>Y011</td><td>KMR</td></tr><tr><td>输出</td><td>27</td><td>变幅机构运行正常指示</td><td>Y012</td><td>HL1</td></tr><tr><td>输出</td><td>28</td><td>变频器运行正常指示</td><td>Y013</td><td>HL2</td></tr><tr><td>输出</td><td>29</td><td>变频器故障指示</td><td>Y014</td><td>HL3</td></tr></tbody></table></div><h2 id="PLC外部接线图"><a href="#PLC外部接线图" class="headerlink" title="PLC外部接线图"></a>PLC外部接线图</h2><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/QQ截图20200822184018.png" alt="PLC外部接线图"></p><h2 id="PLC梯形图程序"><a href="#PLC梯形图程序" class="headerlink" title="PLC梯形图程序"></a>PLC梯形图程序</h2><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/QQ截图20200822184226.png" alt="PLC梯形图"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">LD</span>X<span class="hljs-number">000</span>;主令控制器处于零位挡<br><span class="hljs-attribute">OR</span>M<span class="hljs-number">100</span><br><span class="hljs-attribute">AND</span>X<span class="hljs-number">011</span>;空气断路器触点闭合<br><span class="hljs-attribute">ANI</span>X<span class="hljs-number">014</span>;变频器无故障输出<br><span class="hljs-attribute">ANI</span>X<span class="hljs-number">012</span>;超负荷限制器工作正常<br><span class="hljs-attribute">MC</span>N<span class="hljs-number">0</span>M<span class="hljs-number">100</span>;主令控制开始<br><span class="hljs-attribute">OUT</span>Y<span class="hljs-number">000</span>;变频器电源接通<br><span class="hljs-attribute">OUT</span>Y<span class="hljs-number">012</span>;变幅机构运行正常指示灯开始亮<br><span class="hljs-attribute">LD</span>Y<span class="hljs-number">000</span>;变频器电源接通<br><span class="hljs-attribute">OUT</span>Y<span class="hljs-number">007</span>;风扇开始工作<br><span class="hljs-attribute">LD</span>X<span class="hljs-number">001</span>;收到增幅信号<br><span class="hljs-attribute">ANI</span>X<span class="hljs-number">002</span>;不在减幅状态<br><span class="hljs-attribute">ANI</span>X<span class="hljs-number">005</span>;没有运行到增幅限位开关<span class="hljs-number">1</span><br><span class="hljs-attribute">ANI</span>X<span class="hljs-number">006</span>;没有运行到增幅限位开关<span class="hljs-number">2</span><br><span class="hljs-attribute">OUT</span>Y<span class="hljs-number">001</span>;增幅运行<br><span class="hljs-attribute">LD</span>X<span class="hljs-number">002</span>;收到减幅信号<br><span class="hljs-attribute">ANI</span>X<span class="hljs-number">001</span>;不在增幅状态<br><span class="hljs-attribute">ANI</span>X<span class="hljs-number">007</span>;没有运行到减幅限位开关<span class="hljs-number">1</span><br><span class="hljs-attribute">ANI</span>X<span class="hljs-number">010</span>;没有运行到减幅限位开关<span class="hljs-number">2</span><br><span class="hljs-attribute">OUT</span>Y<span class="hljs-number">002</span>;减幅运行<br><span class="hljs-attribute">LD</span>X<span class="hljs-number">001</span><br><span class="hljs-attribute">OR</span>X<span class="hljs-number">002</span><br><span class="hljs-attribute">ANI</span>X<span class="hljs-number">003</span>;收到多数调节<span class="hljs-number">1</span>信号<br><span class="hljs-attribute">OUT</span>Y<span class="hljs-number">003</span>;输出给变频器<br><span class="hljs-attribute">LD</span>X<span class="hljs-number">001</span><br><span class="hljs-attribute">OR</span>X<span class="hljs-number">002</span><br><span class="hljs-attribute">ANI</span>X<span class="hljs-number">004</span>;收到多数调节<span class="hljs-number">2</span>信号<br><span class="hljs-attribute">OUT</span>Y<span class="hljs-number">004</span>;输出给变频器<br><span class="hljs-attribute">MCR</span>N<span class="hljs-number">0</span>;主令控制结束<br><span class="hljs-attribute">LD</span>X<span class="hljs-number">005</span>;增幅状态下运行到增幅限位开关<span class="hljs-number">1</span><br><span class="hljs-attribute">ANI</span>Y<span class="hljs-number">002</span><br><span class="hljs-attribute">LD</span>X<span class="hljs-number">007</span>;减幅状态下运行到减幅限位开关<span class="hljs-number">1</span><br><span class="hljs-attribute">ANI</span>Y<span class="hljs-number">001</span><br><span class="hljs-attribute">ORB</span><br><span class="hljs-attribute">OUT</span>Y<span class="hljs-number">005</span>;制动器<span class="hljs-number">1</span>启动<br><span class="hljs-attribute">LD</span>X<span class="hljs-number">006</span>;增幅状态下运行到增幅限位开关<span class="hljs-number">2</span><br><span class="hljs-attribute">ANI</span>Y<span class="hljs-number">002</span><br><span class="hljs-attribute">LD</span>X<span class="hljs-number">008</span>;增幅状态下运行到增幅限位开关<span class="hljs-number">2</span><br><span class="hljs-attribute">ANI</span>Y<span class="hljs-number">001</span><br><span class="hljs-attribute">ORB</span><br><span class="hljs-attribute">OUT</span>Y<span class="hljs-number">006</span>;制动器<span class="hljs-number">1</span>启动<br><span class="hljs-attribute">LD</span>X<span class="hljs-number">015</span>;制动单元热敏开关反应<br><span class="hljs-attribute">OR</span>X<span class="hljs-number">016</span><br><span class="hljs-attribute">OUT</span>Y<span class="hljs-number">010</span>;输出故障信号给变频器<br><span class="hljs-attribute">LD</span>X<span class="hljs-number">017</span>;复位按钮按下<br><span class="hljs-attribute">OUT</span>Y<span class="hljs-number">011</span>;输出复位信号给变频器<br><span class="hljs-attribute">LD</span>X<span class="hljs-number">013</span>;收到变频器工作信号<br><span class="hljs-attribute">OUT</span>Y<span class="hljs-number">013</span>;工作指示灯亮<br><span class="hljs-attribute">LD</span>X<span class="hljs-number">014</span>;收到变频器故障信号<br><span class="hljs-attribute">OUT</span>Y<span class="hljs-number">014</span>;故障指示灯亮<br></code></pre></td></tr></table></figure><h1 id="变幅机构电路工作原理"><a href="#变幅机构电路工作原理" class="headerlink" title="变幅机构电路工作原理"></a>变幅机构电路工作原理</h1><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200822184334.png" alt="变幅机构电路图"></p><p>​        变幅机构采用变频调速，四级启动，电机能正反转实现增减幅，有过电流保护，长期过载保护，双限位保护，零位连锁保护，超负荷限制器幅度保护，其主电路如A3图纸所示，电源经空气断路器、交流接触器触点、AC电抗器输入到变频器中，变频器经PLC控制改变电源频率，输出到电机，实现其控制</p><p>​        以正转为例（增幅），当主令控制器在零位档时，同时空气断路器全部接通时，中间继电器M100得点，变频器电源开始接通。机构运行指示点亮，风机开始运行。当主令控制器在右1档时，2路接通，控制电机正转，PLC输出调节指令11给变频器。档主令在2档时，2路和5路接通，电机正转，PLC输出调速指令10给变频器。同理，3档时，调速指令为01，4档为00</p><p>​        本设计采用双制动器实现软制动，当运行到增幅第一个行程开关时，若电机处于增幅状态，制动器1开始工作，当运行到增幅第二个行程开关时，若电机处于增幅状态，制动器2也加入制动过程，实现双制动</p><p>​        当变频器出现故障时，变频器将输出故障信号给PLC，使变频器电源切断，同时故障信号指示灯HL3点亮，当变频器正常运行时，变频器将输出运行指示给PLC，使变频器运行正常指示灯HL2点亮。当变频器复位按钮按下时，PLC将向变频器传递故障复位信号。当制动单元发热过大，使其热敏电阻开关闭合，PLC将发送外部故障信号给变频器。</p><p>​        当电路中电流过大时，空气断路器会直接切断主电路单元，实现过电流保护；当变幅机构负载过大，超过超负荷限位器设定值时，PLC将切断变频器电源，实现幅度保护。</p><h1 id="设计小结"><a href="#设计小结" class="headerlink" title="设计小结"></a>设计小结</h1><p>​        通过本次机电传动控制课程设计，我进一步巩固了之前所学的理论知识，感受到了在实际设计中，完成一个项目的做法。首先要广泛的查阅资料，弄清标准与相关的需要，然后根据需求选择对应的元器件。对于本专业，只需要关注元器件的接线，段子和配件，最后根据设计需求设计电路。在设计过程中，还培养了我团结合作，互帮互助，与人交流的能力</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1]邓星钟. 机电传动控制. 5版. 武汉: 华中科技大学出版社. 2011. 6</p><p>[2]刘银东. 张俊俊. 浅谈变频器U/f控制和矢量控制应用. 高新技术. 2015(1): 27</p>]]></content>
    
    
    <categories>
      
      <category>自动化相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ICADCS同学的上位机科普</title>
    <link href="/2019/08/04/WHUT/CodingLesson/"/>
    <url>/2019/08/04/WHUT/CodingLesson/</url>
    
    <content type="html"><![CDATA[<p>受到实验室指导老师的邀请，给学弟学妹们科普上位机。</p><p>由于上位机软件开发中会涉及到大量英语文档，因此在基本概念中，有些使用的英文介绍。</p><span id="more"></span><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="上位机-下位机"><a href="#上位机-下位机" class="headerlink" title="上位机/下位机"></a>上位机/下位机</h2><p>​        <strong>上位机</strong>是指可以直接发出操控命令的计算机，一般是PC，屏幕上显示各种信号变化（液压，水位，温度等）。下位机是直接控制设备获取设备状况的计算机，一般是PLC/单片机之类的。上位机发出的命令首先给下位机，下位机再根据此命令控制相应设备。下位机不时读取设备状态数据（一般为模拟量），转换成数字信号反馈给上位机。</p><h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><p>​        Input/output</p><h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><ul><li>Integrated development environment</li><li>An <strong>integrated development environment</strong> (<strong>IDE</strong>) is a software application that provides comprehensive facilities to computer programmers for software development. An IDE normally consists of at least a <strong>source code editor</strong>, <strong>build automation tools</strong>, and a <strong>debugger</strong>.</li><li><a href="https://developer.android.google.cn/studio?hl=zh_cn">Android Studio</a>、<a href="https://visualstudio.microsoft.com/vs/">Visual Studio</a></li></ul><h2 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h2><ul><li>Software development kit</li><li>A <strong>software development kit</strong> (<strong>SDK</strong> or <strong>devkit</strong>) is typically a set of software development tools that allows the creation of applications for a certain software package, software framework, hardware platform, computer system, video game console, operating system, or similar development platform.</li><li>Java Development Kit(JDK)、.NET Framework SDK、iOS SDK</li></ul><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><ul><li>Application programming interface</li><li>In computer programming, an <strong>application programming interface</strong> (<strong>API</strong>) is a set of subroutine definitions, communication protocols, and tools for building software.</li><li>百度地图API</li></ul><h2 id="NET-Framework"><a href="#NET-Framework" class="headerlink" title=".NET Framework"></a>.NET Framework</h2><ul><li>.NET is an open source developer platform, created by Microsoft, for building many different types of applications</li><li>You can write .NET apps in C#, F#, or Visual Basic.<ul><li>C# is a simple, modern, object-oriented, and type-safe programming language.</li></ul></li></ul><h2 id="Windows-Forms"><a href="#Windows-Forms" class="headerlink" title="Windows Forms"></a>Windows Forms</h2><ul><li><strong>Windows Forms</strong> (WinForms) is a graphical (GUI) class library included as a part of Microsoft .NET Framework  providing a platform to write rich client applications for desktop, laptop, and tablet PCs.</li></ul><h1 id="项目处理"><a href="#项目处理" class="headerlink" title="项目处理"></a>项目处理</h1><h2 id="完整应用程序的组成"><a href="#完整应用程序的组成" class="headerlink" title="完整应用程序的组成"></a>完整应用程序的组成</h2><ul><li>源程序文件</li><li>GUI界面文件</li><li>资源文件</li><li>配置文件</li></ul><h2 id="项目处理过程"><a href="#项目处理过程" class="headerlink" title="项目处理过程"></a>项目处理过程</h2><ol><li>学习对应的编程语言</li><li>分析功能</li><li>拆分功能</li><li>明确输入输出</li><li>建立初版GUI界面</li><li>查找功能对应的库或源代码</li><li>弄懂对应库或源代码的使用方法</li><li>完成功能模块</li><li>Debug</li><li>完善GUI界面</li></ol><h1 id="编程学习"><a href="#编程学习" class="headerlink" title="编程学习"></a>编程学习</h1><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>​        我们编写的的是 Windows Forms 程序，使用 C# 这种编程语言编程。C# 是一种面对对象编程语言，与面对过程的 C 有很大的区别，因此我们需要把这个当作一种全新的编程语言来学习，一定要把完整的视频过一遍。这里提供两个教程网址</p><ul><li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/">Microsoft: C# Guide</a></li><li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/">51自学网: C#入门教程</a></li></ul><h2 id="Android（选修）"><a href="#Android（选修）" class="headerlink" title="Android（选修）"></a>Android（选修）</h2><p>​        安卓情况比较复杂，这里推荐 Google 制作的一套官方教程，可以不用先学Java，零基础入门。</p><ul><li><a href="https://cn.udacity.com/course/android-basics-user-interface--ud834">Android 基础：用户界面</a></li><li><a href="https://cn.udacity.com/course/android-basics-user-input--ud836">Android 基础：用户输入</a></li><li><a href="https://cn.udacity.com/course/android-basics-multi-screen-apps--ud839">Android 基础：多屏应用</a></li><li><a href="https://cn.udacity.com/course/android-basics-networking--ud843">Android 基础：网络</a></li><li><a href="https://cn.udacity.com/course/android-basics-data-storage--ud845">Android 基础：数据存储</a></li></ul><h2 id="Bug-amp-Debug"><a href="#Bug-amp-Debug" class="headerlink" title="Bug&amp;Debug"></a>Bug&amp;Debug</h2><ul><li>检查配置是否匹配</li><li>边写边测试</li><li>单位测试</li><li>注意查看报错信息</li><li>Google一下/Bing一下/百度一下</li></ul><h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><h2 id="Github注册"><a href="#Github注册" class="headerlink" title="Github注册"></a>Github注册</h2><p>​        Github是一个基于git的代码托管平台，付费用户可以建无数个私人仓库，我们一般的免费用户只能使用最多5个私人仓库及无数个公共仓库，其中公共仓库代码公开。</p><p><strong>请自行搜索注册教程</strong></p><h2 id="Github使用"><a href="#Github使用" class="headerlink" title="Github使用"></a>Github使用</h2><p>​        现场演示</p><h1 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h1><ul><li><a href="https://dotnet.microsoft.com/">.Net官网</a> </li><li><a href="https://developer.android.google.cn/?hl=zh_cn">Android开发者网站</a> </li><li><a href="https://material.io/tools/icons/?icon=minimize&amp;style=round">Material Design 图标</a> （Google主推的图标）</li><li><a href="https://github.com/">Github官网</a> </li></ul><hr><p>Learning By Sharing，2019©Fu_Qingchen，Markdown，$\LaTeX$</p>]]></content>
    
    
    <categories>
      
      <category>计算机相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机电传动及控制笔记</title>
    <link href="/2019/06/24/WHUT/MechanicalAndElectronicTransmissionAndControl/"/>
    <url>/2019/06/24/WHUT/MechanicalAndElectronicTransmissionAndControl/</url>
    
    <content type="html"><![CDATA[<p>讲电机的一门课程，主要要会画几个图</p><span id="more"></span><h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><h2 id="网页版"><a href="#网页版" class="headerlink" title="网页版"></a>网页版</h2><p>链接：<a href="http://www.xmind.net/embed/hQ4F9j">http://www.xmind.net/embed/hQ4F9j</a></p><h2 id="图片版"><a href="#图片版" class="headerlink" title="图片版"></a>图片版</h2><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823214315.png" alt=""></p><hr><p>Learning By Sharing，2019©Fu_Qingchen，Markdown，$\LaTeX$</p>]]></content>
    
    
    <categories>
      
      <category>自动化相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电机</tag>
      
      <tag>机电传动</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>液压元件与系统笔记</title>
    <link href="/2019/06/13/WHUT/HydraulicElements&amp;Transition/"/>
    <url>/2019/06/13/WHUT/HydraulicElements&amp;Transition/</url>
    
    <content type="html"><![CDATA[<p>我这一届可能是物流学院最后一届液压班了，这课应该绝版了，不过当时在搞比赛没好好学很可惜。</p><span id="more"></span><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="液压传动的工作原理、基本特征"><a href="#液压传动的工作原理、基本特征" class="headerlink" title="液压传动的工作原理、基本特征"></a>液压传动的工作原理、基本特征</h2><ul><li><p>工作原理：基于帕斯卡原理，利用液体的压力能传递动力</p></li><li><p>基本特征：</p><ul><li>工作压力取决于负载</li><li>运动速度取决于输入的流量</li><li>液压泵的工作压力和流量之间没有相关性，而是呈现出刚性的压力流量特性</li><li>P = pq</li></ul></li></ul><h1 id="液压泵、液压马达和液压缸"><a href="#液压泵、液压马达和液压缸" class="headerlink" title="液压泵、液压马达和液压缸"></a>液压泵、液压马达和液压缸</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="液压泵、液压马达的分类"><a href="#液压泵、液压马达的分类" class="headerlink" title="液压泵、液压马达的分类"></a>液压泵、液压马达的分类</h3><ul><li>液压泵<ul><li>齿轮泵</li><li>叶片泵</li><li>柱塞泵</li><li>螺杆泵</li></ul></li><li>液压马达<ul><li>高速<ul><li>齿轮式</li><li>叶片式</li><li>轴向柱塞式</li></ul></li><li>低速<ul><li>径向柱塞式</li><li>摆线转子式</li></ul></li></ul></li></ul><h3 id="自吸现象"><a href="#自吸现象" class="headerlink" title="自吸现象"></a>自吸现象</h3><p>在额定转速下，液压泵从低于泵的油箱自行吸油的能力，用真空度来表示。</p><h3 id="液压泵和马达对偶摩擦副的润滑状态，对应摩擦学特性"><a href="#液压泵和马达对偶摩擦副的润滑状态，对应摩擦学特性" class="headerlink" title="液压泵和马达对偶摩擦副的润滑状态，对应摩擦学特性"></a>液压泵和马达对偶摩擦副的润滑状态，对应摩擦学特性</h3><ul><li>液膜润滑：对偶表面被液膜隔开，并不直接接触- ，是理想的液膜润滑状态。这时摩擦力主要与润滑剂粘性有关。</li><li>混合润滑：有些地方处于边界润滑，有些地方处于液膜润滑。</li><li>边界润滑：液膜薄，由润滑剂中的化学物吸附在金属表面形成吸附膜或产生反应生成固体反应物形成反应膜，起润滑作用。摩擦力主要与摩擦表面特性和润滑性相关</li></ul><h2 id="齿轮泵"><a href="#齿轮泵" class="headerlink" title="齿轮泵"></a>齿轮泵</h2><h3 id="齿轮泵流量脉动产生原因、危害、减小措施"><a href="#齿轮泵流量脉动产生原因、危害、减小措施" class="headerlink" title="齿轮泵流量脉动产生原因、危害、减小措施"></a>齿轮泵流量脉动产生原因、危害、减小措施</h3><ul><li>原因：泵在工作时，啮合点不断变化，排油腔减小的面积与增大的面积不同，流量不均匀，产生流量脉动</li><li><p>危害</p><ul><li>脉动振幅大，执行元件的平稳性差</li><li>产生压力脉动，对轴、轴承等有疲劳破环</li><li>若脉动频率与溢流阀固有频率相同，产生严重的共振</li></ul></li><li><p>减小措施</p><ul><li>增加齿数</li><li>实现无侧隙啮合</li></ul></li></ul><blockquote><p>流量不均匀系数：$\delta_q={(q_{sh\max}-q_{sh\min})}/{q_t}$</p></blockquote><h2 id="叶片泵"><a href="#叶片泵" class="headerlink" title="叶片泵"></a>叶片泵</h2><h3 id="瞬时流量不均匀性取决因素"><a href="#瞬时流量不均匀性取决因素" class="headerlink" title="瞬时流量不均匀性取决因素"></a>瞬时流量不均匀性取决因素</h3><ul><li>叶片数</li><li>叶片沿定子曲线移动的度速度</li></ul><h3 id="排量计算"><a href="#排量计算" class="headerlink" title="排量计算"></a>排量计算</h3><script type="math/tex; mode=display">V=2\pi B(R^2-r^2)</script><ul><li>B：叶片宽度</li><li>R，r：定子内曲线大、小圆弧半径</li></ul><h3 id="单作用叶片变量泵"><a href="#单作用叶片变量泵" class="headerlink" title="单作用叶片变量泵"></a>单作用叶片变量泵</h3><ul><li>内反馈<ul><li>原理：通过工作腔内的压力推动定子运动，达到变量目的</li><li>q-p 曲线：在截流压力前，泵全排量输出；到达截流压力后，输出流量随压力减小，斜率与调压弹簧刚度有关，刚度越大，斜率越小。</li><li>调节：通过改变调压弹簧的刚度实现曲线下降特性段斜率的改变</li></ul></li><li>外反馈<ul><li>原理：叶片泵正常运转时，压力低，定子被推向流量调节螺栓，处于最大排量处；到达调定压力后，压力补偿阀口与油箱相连，定子迅速移动，处于零偏心位置，排量为 0</li><li>q-p 曲线：与内反馈相似，不过下降段具有垂直特性</li><li>调节：通过流量调节螺栓可以调节定子的最大偏心量，从而实现 q-p 特性曲线的上下平移。通过调整压力补偿器中调压弹簧的压力，可以实现 q-p 特性曲线下降段的左右平移。</li></ul></li></ul><h2 id="柱塞泵"><a href="#柱塞泵" class="headerlink" title="柱塞泵"></a>柱塞泵</h2><h3 id="轴向柱塞泵采用奇数柱塞原因"><a href="#轴向柱塞泵采用奇数柱塞原因" class="headerlink" title="轴向柱塞泵采用奇数柱塞原因"></a>轴向柱塞泵采用奇数柱塞原因</h3><p>奇数柱塞泵的流量不均匀系数 $\delta_d$ 明显好于偶数柱塞泵</p><h3 id="手动伺服变量泵、恒功率变量泵、恒压变量泵、功率适应性变量泵"><a href="#手动伺服变量泵、恒功率变量泵、恒压变量泵、功率适应性变量泵" class="headerlink" title="手动伺服变量泵、恒功率变量泵、恒压变量泵、功率适应性变量泵"></a>手动伺服变量泵、恒功率变量泵、恒压变量泵、功率适应性变量泵</h3><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">工作原理</th><th style="text-align:center">适应范围</th></tr></thead><tbody><tr><td style="text-align:center">手动伺服变量泵</td><td style="text-align:center">阀杆带动控制阀动，使变量活塞上端出现液压，活塞上下面积不等，使活塞移动，实现变量</td><td style="text-align:center">广泛应用于频繁变速的液压系统中</td></tr><tr><td style="text-align:center">恒功率变量泵</td><td style="text-align:center">设置内外弹簧，用两个弹簧先后调节，刚度变化使 pq = C</td><td style="text-align:center">广泛应用于压力经常变化的液压系统</td></tr><tr><td style="text-align:center">恒压变量泵</td><td style="text-align:center">通过一先导控制滑阀与出油口相接，调节出口压力</td><td style="text-align:center">用于液压系统保压、电液伺服系统供压油源、节流调速系统，节省功率，减少发热</td></tr><tr><td style="text-align:center">功率适应性变量泵</td><td style="text-align:center">外置节流阀，通过节流口变化使压力差变化，调节先导控制阀，以调节流量；通过一先导控制滑阀与出油口相接，调节出口压力。同时调节两者以调节功率</td><td style="text-align:center">适应于各种形式的复合控制</td></tr></tbody></table></div><h3 id="柱塞泵滑靴辅助支承作用"><a href="#柱塞泵滑靴辅助支承作用" class="headerlink" title="柱塞泵滑靴辅助支承作用"></a>柱塞泵滑靴辅助支承作用</h3><ul><li>内辅助支承面：减小滑靴底面的接触比压</li><li>外辅助支承面：防止因滑靴倾斜使密封带破坏</li></ul><h2 id="液压马达"><a href="#液压马达" class="headerlink" title="液压马达"></a>液压马达</h2><h3 id="多作用径向柱塞内曲线马达的设计要求"><a href="#多作用径向柱塞内曲线马达的设计要求" class="headerlink" title="多作用径向柱塞内曲线马达的设计要求"></a>多作用径向柱塞内曲线马达的设计要求</h3><ul><li>满足柱塞的行程要求</li><li>转矩和角速度的脉动小或无脉动</li><li>柱塞径向运动加速度不能过大，而且应均匀变化，以减小回油背压、冲击、噪声</li><li>滚轮和导轨间接触应力不应过大，而且应均匀变化，以延长寿命</li><li>易于加工制造</li></ul><h2 id="液压马达-1"><a href="#液压马达-1" class="headerlink" title="液压马达"></a>液压马达</h2><h3 id="缓冲装置"><a href="#缓冲装置" class="headerlink" title="缓冲装置"></a>缓冲装置</h3><p>在活塞行驶至活塞终端时，在活塞和缸盖间封上一层油液，使其强制通过一小孔，产生很大的阻力。</p><ul><li>固定间隙缓冲装置</li><li>可变节流缓冲装置</li><li>可调节流缓冲装置</li></ul><h1 id="液压控制阀"><a href="#液压控制阀" class="headerlink" title="液压控制阀"></a>液压控制阀</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><h3 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h3><ul><li>管式</li><li>板式</li><li>插装</li><li>叠加</li></ul><h3 id="液压侧向力和摩擦力的减小方法"><a href="#液压侧向力和摩擦力的减小方法" class="headerlink" title="液压侧向力和摩擦力的减小方法"></a>液压侧向力和摩擦力的减小方法</h3><ul><li>提高加工精度</li><li>开圆周方向的均压槽</li><li>保证密封下减小配合尺寸</li><li>在控制系统中加入颤振信号</li></ul><h3 id="滑阀流量公式"><a href="#滑阀流量公式" class="headerlink" title="滑阀流量公式"></a>滑阀流量公式</h3><script type="math/tex; mode=display">q = C_dA\sqrt{\frac2\rho\Delta p}</script><h3 id="比例电磁铁"><a href="#比例电磁铁" class="headerlink" title="比例电磁铁"></a>比例电磁铁</h3><ul><li>吸合区：工作间隙基本为0，输出力急剧上升</li><li>工作行程区：输出力与输入电流成比例，与间隙基本无关</li><li>空行程区：间隙过大，输出力减小</li></ul><h3 id="稳态液压力对阀的工作性能的影响、减小措施"><a href="#稳态液压力对阀的工作性能的影响、减小措施" class="headerlink" title="稳态液压力对阀的工作性能的影响、减小措施"></a>稳态液压力对阀的工作性能的影响、减小措施</h3><p>影响：使阀芯操纵困难</p><p>减小措施：</p><ul><li>使用双级或多级调节</li><li>用压降补偿</li><li>开径向小孔</li><li>在阀套开斜孔</li></ul><h3 id="液阻作用"><a href="#液阻作用" class="headerlink" title="液阻作用"></a>液阻作用</h3><p>阻尼作用</p><h2 id="流量控制阀"><a href="#流量控制阀" class="headerlink" title="流量控制阀"></a>流量控制阀</h2><h3 id="将调速阀和溢流节流阀分别装在液压缸的回油路上，能否起到稳定速度的作用？"><a href="#将调速阀和溢流节流阀分别装在液压缸的回油路上，能否起到稳定速度的作用？" class="headerlink" title="将调速阀和溢流节流阀分别装在液压缸的回油路上，能否起到稳定速度的作用？"></a>将调速阀和溢流节流阀分别装在液压缸的回油路上，能否起到稳定速度的作用？</h3><ul><li>调速阀可以</li><li>溢流节流阀不行，因为溢流节流阀只能出现在<strong>进油口</strong></li></ul><h3 id="中位机能为-M、H、P、Y-的三位滑阀型换向阀的特点及其应用场合"><a href="#中位机能为-M、H、P、Y-的三位滑阀型换向阀的特点及其应用场合" class="headerlink" title="中位机能为 M、H、P、Y 的三位滑阀型换向阀的特点及其应用场合"></a>中位机能为 M、H、P、Y 的三位滑阀型换向阀的特点及其应用场合</h3><ul><li>M：P、T口互通；A、B口封闭；机构处于静止状态</li><li>H：A、B、P、T口互通；机构处于浮动状态</li><li>P：A、B、P口互通；双作用液压缸处于平衡状态</li><li>Y：A、B、T口互通，P口保持压力。机构呈浮动状态</li></ul><h3 id="盖板式插装阀组成"><a href="#盖板式插装阀组成" class="headerlink" title="盖板式插装阀组成"></a>盖板式插装阀组成</h3><ul><li>先导控制阀：控制主阀组件动作</li><li>控制盖板：固定插装件并保证密封，内嵌先导控制元件和节流螺塞，安装先导控制阀以及位移传感器，行程开关等电气附件，沟通插装块体内控制油路和主阀组件的连接并实施控制</li><li>插装件：控制液流通断或压力高低、流量大小实现对液压执行机构方向、流量、压力的控制</li></ul><h3 id="面积比"><a href="#面积比" class="headerlink" title="面积比"></a>面积比</h3><script type="math/tex; mode=display">\alpha_A=\frac {A_A}{A_X},\\\alpha_B=\frac {A_B}{A_X}</script><ul><li><p>$A_A,A_B$：主油口面积</p></li><li><p>$A_X$ ：控制油腔</p></li></ul><h3 id="电液比例阀"><a href="#电液比例阀" class="headerlink" title="电液比例阀"></a>电液比例阀</h3><h3 id="电液比例压力阀中的弹簧与普通压力阀之间的区别"><a href="#电液比例压力阀中的弹簧与普通压力阀之间的区别" class="headerlink" title="电液比例压力阀中的弹簧与普通压力阀之间的区别"></a>电液比例压力阀中的弹簧与普通压力阀之间的区别</h3><p>电液比例压力阀中的弹簧起传力作用，普通压力阀起调压作用。</p><h3 id="电液比例阀与普通开关阀、电液伺服阀相比较有何特点"><a href="#电液比例阀与普通开关阀、电液伺服阀相比较有何特点" class="headerlink" title="电液比例阀与普通开关阀、电液伺服阀相比较有何特点"></a>电液比例阀与普通开关阀、电液伺服阀相比较有何特点</h3><ul><li>电液比例阀是介于普通开关阀与伺服阀之间的一种液压元件。</li><li>与伺服阀相比，其优点是价廉、抗污染能力强。除了在控制精度和响应快速性方面不如伺服阀外，其他方面的性能和控制水平与伺服阀相当，其动、静态性能可以满足大多数工业应用的需求。</li><li>与普通开关阀相比，虽然价格较贵，但由于其良好的控制性能而得到补偿。因此在控制较复杂，特别是对控制性能要求较高的场合，普通开关阀正逐渐被比例阀等元件所替代。</li></ul><h1 id="液压系统工作介质、污染控制及液压辅件"><a href="#液压系统工作介质、污染控制及液压辅件" class="headerlink" title="液压系统工作介质、污染控制及液压辅件"></a>液压系统工作介质、污染控制及液压辅件</h1><h2 id="液压系统工作介质"><a href="#液压系统工作介质" class="headerlink" title="液压系统工作介质"></a>液压系统工作介质</h2><h3 id="粘度指数-VI"><a href="#粘度指数-VI" class="headerlink" title="粘度指数(VI)"></a>粘度指数(VI)</h3><p>用于表示油液运动粘度随温度的变化特性</p><h3 id="液压油的粘度等级（牌号）"><a href="#液压油的粘度等级（牌号）" class="headerlink" title="液压油的粘度等级（牌号）"></a>液压油的粘度等级（牌号）</h3><ul><li>概念：液压油40℃时其运动粘度的中心值</li><li>常见牌号：32，46，68，100</li></ul><h3 id="难燃液压液种类"><a href="#难燃液压液种类" class="headerlink" title="难燃液压液种类"></a>难燃液压液种类</h3><ul><li>HFA</li><li>HFB</li><li>HFC</li><li>HFDR</li></ul><h2 id="工作介质的污染控制来源及危害"><a href="#工作介质的污染控制来源及危害" class="headerlink" title="工作介质的污染控制来源及危害"></a>工作介质的污染控制来源及危害</h2><h3 id="污染物的种类"><a href="#污染物的种类" class="headerlink" title="污染物的种类"></a>污染物的种类</h3><ul><li>固体颗粒污染物</li><li>空气侵入</li><li>水的侵入</li></ul><h3 id="污染物的来源"><a href="#污染物的来源" class="headerlink" title="污染物的来源"></a>污染物的来源</h3><ul><li>残留的污染物</li><li>侵入的污染物</li><li>生成的污染物</li><li>已被污染的新油</li></ul><h3 id="油液污染物等级的测定"><a href="#油液污染物等级的测定" class="headerlink" title="油液污染物等级的测定"></a>油液污染物等级的测定</h3><ul><li>质量分析法：耗时长，结果只反映颗粒总数，无法反映尺寸及分布</li><li>显微镜计数法：对尺寸小、数量多的颗粒，检测精度较差</li><li>自动颗粒计数法</li></ul><h3 id="过滤器的性能参数"><a href="#过滤器的性能参数" class="headerlink" title="过滤器的性能参数"></a>过滤器的性能参数</h3><ul><li><p>过滤效率：被过滤器滤除的污染物数量 / 过滤器上游的污染物数量</p></li><li><p>过滤比 $\beta$ </p><script type="math/tex; mode=display">\beta_x=\frac{N_u}{N_d}</script><ul><li>$\beta_x$ ：相对尺寸 x 的过滤比。$\beta_{10}$ 为评定过滤器过滤精度的性能参数。$\beta_x =1 $，没过滤；$\beta_x =2$，过滤50%，过滤器的平均过滤精度；$\beta_x =75$，过滤器的绝对过滤精度。</li><li>$N_u,N_d$ ：过滤器上、下游中大于某一尺寸的污染物颗粒数</li></ul></li></ul><h2 id="液压辅件"><a href="#液压辅件" class="headerlink" title="液压辅件"></a>液压辅件</h2><h3 id="油箱的功用"><a href="#油箱的功用" class="headerlink" title="油箱的功用"></a>油箱的功用</h3><ul><li>能够储存足够的油液，以满足液压系统的需要</li><li>有足够的表面面积，能够散发系统工作产生的热量</li><li>油液应平缓迂回流动，以利于油液中空气的分离和污染物的沉淀</li><li>应能有效防止外界污染物入侵</li><li>能保证液压泵的正常吸油，防止气泡混入和气穴的产生</li><li>应为清洗油箱及油箱内元部件的安装维修提供方便，并便于注油和排油</li><li>应具备液面指示器等装置</li><li>应使外形整齐美观，具有一定强度和刚度</li></ul><h3 id="油箱容积的确定"><a href="#油箱容积的确定" class="headerlink" title="油箱容积的确定"></a>油箱容积的确定</h3><ul><li>系统有大量供油时，最低液面应该在泵过滤器之上；系统有大量回油时油液应不溢出</li><li>有足够的散热面积</li></ul><hr><p>Learning By Sharing，2019©Fu_Qingchen，Markdown，$\LaTeX$</p>]]></content>
    
    
    <categories>
      
      <category>液压相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>液压</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数控技术笔记</title>
    <link href="/2019/04/01/WHUT/NumericalControlTechnology/"/>
    <url>/2019/04/01/WHUT/NumericalControlTechnology/</url>
    
    <content type="html"><![CDATA[<p>介绍数控机床的一门课程。</p><span id="more"></span><h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><blockquote><p>提示：</p><p><strong>为了更好的阅读体验，请前往：<a href="http://www.xmind.net/m/HRFh">http://www.xmind.net/m/HRFh</a>  查看</strong></p></blockquote><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823211332.png" alt="思维导图"></p><hr><p>Learning By Sharing，2019©Fu_Qingchen，Markdown，$\LaTeX$</p>]]></content>
    
    
    <categories>
      
      <category>自动化相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自动化</tag>
      
      <tag>数控技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>现代测试技术笔记</title>
    <link href="/2019/04/01/WHUT/ModernTestingTechnology/"/>
    <url>/2019/04/01/WHUT/ModernTestingTechnology/</url>
    
    <content type="html"><![CDATA[<p>又名传感器，测控方向的要好好学下。</p><span id="more"></span><h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><blockquote><p><strong>为了更好的阅读体验，请前往：<a href="http://www.xmind.net/embed/LVYU">http://www.xmind.net/embed/LVYU</a>  查看</strong></p></blockquote><h1 id="信号分析基础"><a href="#信号分析基础" class="headerlink" title="信号分析基础"></a>信号分析基础</h1><h2 id="自相关函数"><a href="#自相关函数" class="headerlink" title="自相关函数"></a>自相关函数</h2><script type="math/tex; mode=display">R_{xx}(\tau)=\lim_{T\rightarrow∞}\frac1T\int_0^Tx(t)x(t-\tau)</script><script type="math/tex; mode=display">x(t)=x_0\sin(\omega t+\varphi)R_{xx}(\tau)=\frac{x_0^2}2\cos(\omega \tau)</script><h2 id="互相关函数"><a href="#互相关函数" class="headerlink" title="互相关函数"></a>互相关函数</h2><script type="math/tex; mode=display">R_{xy}(\tau)=\lim_{T\rightarrow∞}\frac1T\int_0^Tx(t)y(t-\tau)dt</script><script type="math/tex; mode=display">x(t)=x_0\sin(\omega t+\varphi_x),y(t)=y_0\sin(\omega t+\varphi_y)\Rightarrow R_{xy}(\tau)=\frac{x_0y_0}2\cos(\omega \tau+\theta_y-\theta_x)</script><h2 id="傅里叶级数"><a href="#傅里叶级数" class="headerlink" title="傅里叶级数"></a>傅里叶级数</h2><script type="math/tex; mode=display">x(t)=a_0/2+\sum_{n=1}^∞[a_n\cos n\omega_0t+b_n\sin n\omega_0t],\\a_0=\frac2T\int_{-\frac T2}^{\frac T2}x(t)dt,\\a_n=\frac T2\int_{-\frac T2}^{\frac T2}x(t)\cos n\omega_0tdt,\\b_n=\frac T2\int_{-\frac T2}^{\frac T2}x(t)\sin n\omega_0tdt</script><script type="math/tex; mode=display">x(t)=\sum_{n=-∞}^∞ C_ne^{jn\omega_0t},\\C_n=\frac{a_n-jb_n}{2}</script><h2 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h2><script type="math/tex; mode=display">e^{jx}=\cos x+j\sin x</script><script type="math/tex; mode=display">\cos\omega t=\frac12(e^{-j\omega t}+e^{j\omega t}),\\\sin\omega t=j\frac12(e^{-j\omega t}-e^{j\omega t})</script><h2 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><script type="math/tex; mode=display">X(f)=\int_{-∞}^{+∞}x(t)e^{-j2\pi ft}dt,\\x(t)=\int_{-∞}^{+∞}X(f)e^{2\pi ft}df</script><script type="math/tex; mode=display">x(t)为窗函数,F[x(t)]=\tau sinc(\omega\tau/2)</script><script type="math/tex; mode=display">F(\cos2\pi f_0t)=\frac12[\delta(f-f_0)+\delta(f+f_0)],\\F(\sin2\pi f_0t)=\frac1{2j}[\delta(f-f_0)-\delta(f+f_0)]</script><script type="math/tex; mode=display">x(t-t_0)-X(f)e^{-j2\pi ft_0},\\e^{j2\pi f_0t}x(t)-X(f-f_0),\\\frac{dx(t)}{dt}-j2\pi fX(f),\\\int_{-\infty}^tx(t)dt-\frac1{j2\pi f}X(f)</script><blockquote><p>通过傅里叶变换可以进行一些骚操作，比如说画图</p></blockquote><iframe id=sbrxp src="//player.bilibili.com/player.html?aid=85377237&bvid=BV1j7411r7oM&cid=169562491&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width: 720px; height: 430px; max-width: 100%"> </iframe><h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><script type="math/tex; mode=display">x(t)*y(t)=\int_{-∞}^{+∞}x(\tau)y(\tau-t)d\tau</script><script type="math/tex; mode=display">F[x(t)*y(t)]=X(f)Y(f)</script><script type="math/tex; mode=display">F[x(t)y(t)]=2\pi X(f)*Y(f)</script><h2 id="delta-函数"><a href="#delta-函数" class="headerlink" title="$\delta$ 函数"></a>$\delta$ 函数</h2><script type="math/tex; mode=display">\int_{-∞}^{+∞}\delta(t)dt=1</script><script type="math/tex; mode=display">x(t)\delta(t-t_0)=x(t_0)\delta(t-t_0),\\\int_{-∞}^{+∞}x(t)\delta(t-t_0)dt=x(t_0),\\x(t)*\delta(t)=x(t)</script><h1 id="线性系统分析"><a href="#线性系统分析" class="headerlink" title="线性系统分析"></a>线性系统分析</h1><h2 id="一阶系统"><a href="#一阶系统" class="headerlink" title="一阶系统"></a>一阶系统</h2><script type="math/tex; mode=display">H(\omega)=\frac{1}{1+j\tau\omega_0},\\A(\omega)=\frac{1}{\sqrt{1+\tau^2\omega_0^2}},\\\varphi(\omega)=-\arctan(\tau\omega_0)</script><h1 id="误差分析"><a href="#误差分析" class="headerlink" title="误差分析"></a>误差分析</h1><h2 id="直接测量"><a href="#直接测量" class="headerlink" title="直接测量"></a>直接测量</h2><script type="math/tex; mode=display">R=x_\max-x_\min,\\\sigma=\sqrt{\frac1n\sum_{i=1}^n\Delta x_i^2}=\sqrt{\frac1{N-1}\sum_{i=1}^N(x_i-\bar{x})^2},\\w=\frac\sigma{\bar{x}},\\\delta_m=3\sigma,\\\rho=0.6745\sigma</script><script type="math/tex; mode=display">s=\frac\sigma{\sqrt N},\\\lambda=3s,\\R=0.6745s</script><h2 id="间接测量"><a href="#间接测量" class="headerlink" title="间接测量"></a>间接测量</h2><script type="math/tex; mode=display">\sigma_y=\sqrt{\sum_{i=1}^n[(\frac{\partial f}{\partial x_i})\sigma_i]^2},\\\sigma_i=\frac{\sigma_y}{\sqrt n(\frac{\partial f}{\partial x_i})}</script><h1 id="信号的传输、变换及记录"><a href="#信号的传输、变换及记录" class="headerlink" title="信号的传输、变换及记录"></a>信号的传输、变换及记录</h1><script type="math/tex; mode=display">U_{BD}=\frac{R_1R_3-R_2R_4}{(R_1+R_2)(R_3+R_4)}U_0</script><script type="math/tex; mode=display">U=\frac{KU_0}{4}(\varepsilon_1-\varepsilon_2+\varepsilon_3-\varepsilon_4)</script><script type="math/tex; mode=display">A=\frac{4}{KU_0\varepsilon}{\Delta U}=\frac{\Delta R/R}{\varepsilon}</script><script type="math/tex; mode=display">Z_1Z_3=Z_2Z_4,\\\varphi_1+\varphi_3=\varphi_2+\varphi_4</script><h1 id="数字信号处理"><a href="#数字信号处理" class="headerlink" title="数字信号处理"></a>数字信号处理</h1><script type="math/tex; mode=display">X(k)=\sum_{i=0}^{N-1}x(n)W^{kn},\\x(n)=\frac1N\sum_{i=0}^{N-1}X(k)W^{-kn},\\W=e^{-j2\pi/N}</script><h1 id="应力应变测量"><a href="#应力应变测量" class="headerlink" title="应力应变测量"></a>应力应变测量</h1><script type="math/tex; mode=display">\left[\begin{matrix}\sigma_1\\\sigma_2\\\sigma_3\\\sigma_4\\\end{matrix}\right]=\left[\begin{matrix}1&1&1&1\\1&1&-1&-1\\1&-1&1&-1\\1&-1&-1&1\\\end{matrix}\right]\left[\begin{matrix}\sigma_N\\\sigma_{M_z}\\\sigma_{M_y}\\\sigma_\omega\\\end{matrix}\right]</script><script type="math/tex; mode=display">\left[\begin{matrix}\sigma_N\\\sigma_{M_z}\\\sigma_{M_y}\\\sigma_\omega\\\end{matrix}\right]=\frac14\left[\begin{matrix}1&1&1&1\\1&1&-1&-1\\1&-1&1&-1\\1&-1&-1&1\\\end{matrix}\right]\left[\begin{matrix}\sigma_1\\\sigma_2\\\sigma_3\\\sigma_4\\\end{matrix}\right]</script><hr><p>Learning By Sharing，2019©Fu_Qingchen，Markdown，$\LaTeX$</p>]]></content>
    
    
    <categories>
      
      <category>自动化相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自动化</tag>
      
      <tag>传感器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习中的数学基础笔记</title>
    <link href="/2019/01/25/WHUT/MachineLearning/"/>
    <url>/2019/01/25/WHUT/MachineLearning/</url>
    
    <content type="html"><![CDATA[<p>挺火的一个概念，选了一节公选课上，不过最后也就学了个皮毛。截图是来自 3Blue1Brown 数学频道，以文字识别为例</p><span id="more"></span><h1 id="神经网络的架构"><a href="#神经网络的架构" class="headerlink" title="神经网络的架构"></a>神经网络的架构</h1><ol><li>神经元：神经元就相当于一个函数，输入以上一层为输入，输出给下一层。在文字识别中，一个神经元就是一个文字图像中一个像素的颜色深浅。这些深浅不一的像素（神经元）就组成了我们的文字。</li><li>在神经网络中，神经元将自己的数据一层一层的传递，最后得到了最终的结果。例如文字识别中，第一层识别小的笔画，然后将自己的数据传递给下一层，然后再识别大的笔画，最终识别出来的文字</li></ol><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823215702.png" alt=""></p><ol><li><p>识别的过程：以第二层的神经元为例，第一层的一个神经元要想识别小笔画，就必须要对第一层的每一个数据$a$，赋予一个权重$w$（表示第一层的那个神经元对这个地方的敏感程度）然后求和，得到这个神经元所代表的的数值</p><script type="math/tex; mode=display">w_1a_1+w_2a_2+...+w_na_n</script><p>在实际情况中需要这个值在 0~1 之间，因此需要给它将这个数据减去加上一个函数（比如Sigmoid函数）</p><script type="math/tex; mode=display">\sigma(w_1a_1+w_2a_2+...+w_na_n)</script><p>不过，$w_1a_1+w_2a_2+…+w_na_n$ 的出来可以是任何数，直接用上面的公式表示会出现过早激发的现象，因此需要减去一个偏置值$b$ </p><script type="math/tex; mode=display">\sigma(w_1a_1+w_2a_2+...+w_na_n-b)</script><p>这样的话就得到了第二层神经元的数据，以此类推，可以得到最终结果。</p><p>用向量表示，可以得到下面的（$a^{(0)}$ 为第0层神经元的数值（激活值）） </p><script type="math/tex; mode=display">a^{(1)}=\sigma(Wa^{(0)}+b)</script></li></ol><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823215647.png" alt=""></p><h1 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h1><p>上面我们得到了那个可以计算激活值的递推方程，但是一开始的时候，上面所有的系数都是随机的，因此此时得到的结果误差会非常大。梯度下降算法能够使得这些系数得到的偏差最小。为了表示这个偏差，引出代价函数的概念，下面是一种常见的代价函数</p><script type="math/tex; mode=display">Cost=\sum(\hat y^{(i)}-y^{(i)})^2</script><p>我们的目标就是使得这个函数的值最小。而沿着这个函数的负梯度方向走，这个函数的函数值就下降的越快，因此让这个函数变小的算法就出来了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs flow">st=&gt;start: 开始<br>op1=&gt;operation: 计算梯度<br>op2=&gt;operation: 按照梯度反方向走一小步下山<br>op3=&gt;condition: 精度要求是否达到<br>e=&gt;end: 结束<br><br>st-&gt;op1-&gt;op2-&gt;op3<br>op3(yes)-&gt;e<br>op3(no)-&gt;op1<br></code></pre></td></tr></table></figure><p>相关的数学公式为</p><script type="math/tex; mode=display">\vec{W} = \vec W-\bigtriangledown C(\vec W)</script><h1 id="反向传播算法"><a href="#反向传播算法" class="headerlink" title="反向传播算法"></a>反向传播算法</h1><p>反向传播算法的核心就是计算上面提到的梯度 $\bigtriangledown C$ </p><p>先考虑两个神经元之间的传播。</p><p>记第一个神经元的所有参数上角标为$(L-1)$，下角标为$L$ .</p><p>因此有以下参数：</p><ul><li>$a^{(L-1)},a^{(L)}$ 两个神经元的激活值</li><li>$w^{(L)}，b^{(L)}$ 从（L-1）层到（L）层的权重</li><li>$y^{(L)}$ 想要达到的激活值</li></ul><p>为了计算的方便，记 $z^{(L)}=w^{(L)}a^{(L-1)}+b^{(L)}$，则有</p><script type="math/tex; mode=display">C^{(L)}=(y^{(L)}-a^{(L)})^2\\a^{(L)}=\sigma(z^{(L)})\\z^{(L)}=w^{(L)}a^{(L-1)}+b^{(L)}</script><p>由$a^{(L-1)}$到$a^{(L)}$ 的计算的过程是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs flow">w=&gt;operation: w(L)，a(L-1)，b(L)<br>z=&gt;operation: z(L)<br>a2=&gt;operation: a(L)<br>C=&gt;operation: C(L)<br>w-&gt;z-&gt;a2-&gt;C<br></code></pre></td></tr></table></figure><p>而要求的是</p><script type="math/tex; mode=display">\frac{\partial C^{(L)}}{\partial w^{(L)}}=\frac{\partial C^{(L)}}{\partial a^{(L)}}\frac{\partial a^{(L)}}{\partial z^{(L)}}\frac{\partial z^{(L)}}{\partial w^{(L)}}</script><p>根据上面的方程可以得到</p><script type="math/tex; mode=display">\frac{\partial C^{(L)}}{\partial a^{(L)}}=2(a^{(L)}-y^{(L)})\\\frac{\partial a^{(L)}}{\partial z^{(L)}}=\sigma'(z^{(L)})\\\frac{\partial z^{(L)}}{\partial w^{(L)}}=a^{(L-1)}\\\frac{\partial C^{(L)}}{\partial w^{(L)}}=\frac{\partial C^{(L)}}{\partial a^{(L)}}\frac{\partial a^{(L)}}{\partial z^{(L)}}\frac{\partial z^{(L)}}{\partial w^{(L)}}=2(a^{(L)}-y^{(L)})\sigma'(z^{(L)})a^{(L-1)}</script><p>同理</p><script type="math/tex; mode=display">\frac{\partial C^{(L)}}{\partial w^{(L)}}=2(a^{(L)}-y^{(L)})\sigma'(z^{(L)})a^{(L-1)}\\\frac{\partial C^{(L)}}{\partial a^{(L-1)}}=2(a^{(L)}-y^{(L)})\sigma'(z^{(L)})w^{(L)}\\\frac{\partial C^{(L)}}{\partial b^{(L)}}=2(a^{(L)}-y^{(L)})\sigma'(z^{(L)})</script><p>将这个简单的两个神经元之间的传播扩展到一般情况</p><script type="math/tex; mode=display">C^{(L)}=\sum\limits_{i}(y^{(L)}_i-a^{(L)}_i)^2\\a_i^{(L)}=\sigma(z_i^{(L)})\\z_i^{(L)}=\sum\limits_{j}w_{ij}^{(L)}a_j^{(L-1)}+b_i^{(L)}</script><p>其中，i是上层的第i个神经元；j为下层的第j个神经元</p><script type="math/tex; mode=display">\frac{\partial C^{(L)}}{\partial w_{ij}^{(L)}}=\frac{\partial C^{(L)}}{\partial a_i^{(L)}}\frac{\partial a_i^{(L)}}{\partial z_i^{(L)}}\frac{\partial z_i^{(L)}}{\partial w_{ij}^{(L)}}=2(a_i^{(L)}-y_i^{(L)})\sigma'(z_i^{(L)})a_j^{(L-1)}</script><h1 id="实际举例"><a href="#实际举例" class="headerlink" title="实际举例"></a>实际举例</h1><p>构建一个四层的BP人工神经网络，不少于16个神经元结点，自定义一个样本，模拟计算一次完整的样本训练过程，整个过程必须包括各个神经元结点的输入值、输出值以及反馈过程中对权向量的修改情况。</p><h2 id="构建的网络"><a href="#构建的网络" class="headerlink" title="构建的网络"></a>构建的网络</h2><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823215627.png" alt=""></p><p>其中：</p><ul><li>输入层 $a^{(0)}=\left[4\ 3\ 2\ 1 \right]^T$</li><li>权重 $w^{(1)}=\left[<br>\begin{matrix}<br>0.01 &amp; 0.06 &amp; 0.11 &amp; 0.16\\<br>0.02 &amp; 0.07 &amp; 0.12 &amp; 0.17\\<br>0.03 &amp; 0.08 &amp; 0.13 &amp; 0.18\\<br>0.04 &amp; 0.09 &amp; 0.14 &amp; 0.19\\<br>0.05 &amp; 0.10 &amp; 0.15 &amp; 0.20\\<br>\end{matrix}<br>\right],w^{(2)}=\left[<br>\begin{matrix}0.21 &amp; 0.22 &amp; 0.23 &amp;0.24 &amp; 0.25\\<br>0.16 &amp; 0.17 &amp; 0.18 &amp;0.19 &amp; 0.20\\<br>0.11 &amp; 0.12 &amp; 0.13 &amp;0.14 &amp; 0.15\\<br>0.06 &amp; 0.07 &amp; 0.08 &amp; 0.09 &amp; 0.10\\<br>0.01 &amp; 0.02 &amp; 0.03 &amp; 0.04 &amp; 0.05\\\end{matrix}<br>\right],w^{(3)}=\left[<br>\begin{matrix}<br>0.16 &amp; 0.21 \\0.17 &amp; 0.22 \\ 0.18 &amp;0.23\\0.19 &amp; 0.24\\0.20 &amp; 0.25\\<br>\end{matrix}<br>\right]^T$</li><li>期望输出层 $y^{(3)}=[0.10\ 0.24]^T$  </li><li>每个节点没有偏置</li><li>节点激活函数 $\sigma(x)=1/{(1+e^{-x})}$，导数$\sigma’(x)=\sigma(x)(1-\sigma(x))$</li></ul><h2 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a>符号说明</h2><ul><li>$a_i^{(L)}$：第 (L) 层节点的第 i 个元素的 <strong>输出值</strong></li><li>$z_i^{(L)}$：第 (L) 层节点的第 i 个元素的 <strong>输入值</strong></li><li>$w_{ij}^{(L)}$：第 (L-1) 层 的第 i 个节点 到 第 (L) 层 的第 j 个节点的 <strong>权重</strong> </li></ul><h2 id="正向传播"><a href="#正向传播" class="headerlink" title="正向传播"></a>正向传播</h2><h3 id="0层→1层"><a href="#0层→1层" class="headerlink" title="0层→1层"></a>0层→1层</h3><p>第一层输入值为：</p><script type="math/tex; mode=display">z^{(1)}=\left[\begin{matrix}z_0^{(1)} \\z_1^{(1)} \\z_2^{(1)} \\z_3^{(1)} \\\end{matrix}\right]=w^{(1)}a^{(0)}=\left[\begin{matrix}w_{00}^{(1)} & w_{01}^{(1)} & w_{02}^{(1)} & w_{03}^{(1)}\\w_{10}^{(1)} & w_{11}^{(1)} & w_{12}^{(1)} & w_{13}^{(1)}\\w_{20}^{(1)} & w_{21}^{(1)} & w_{22}^{(1)} & w_{23}^{(1)}\\w_{30}^{(1)} & w_{31}^{(1)} & w_{32}^{(1)} & w_{33}^{(1)}\\w_{40}^{(1)} & w_{41}^{(1)} & w_{42}^{(1)} & w_{43}^{(1)}\\\end{matrix}\right]·\left[\begin{matrix}a_0^{(0)} \\a_1^{(0)} \\a_2^{(0)} \\a_3^{(0)} \\\end{matrix}\right]\\=\left[\begin{matrix}0.01 & 0.06 & 0.11 & 0.16\\0.02 & 0.07 & 0.12 & 0.17\\0.03 & 0.08 & 0.13 & 0.18\\0.04 & 0.09 & 0.14 & 0.19\\0.05 & 0.10 & 0.15 & 0.20\\\end{matrix}\right]·\left[\begin{matrix}4\\3\\2\\1\\\end{matrix}\right]=\left[\begin{matrix}0.6\\0.7\\0.8\\0.9\\1.0\\\end{matrix}\right]</script><p>第一层输出值为：</p><script type="math/tex; mode=display">a^{(1)}=\left[\begin{matrix}a_0^{(1)} \\a_1^{(1)} \\a_2^{(1)} \\a_3^{(1)} \\\end{matrix}\right]=\sigma\left(z^{(1)}\right)=\sigma\left(\left[\begin{matrix}6\\7\\8\\9\\10\\\end{matrix}\right]\right)=\left[\begin{matrix}0.6457\\0.6682\\0.6900\\0.7109\\0.7311\\\end{matrix}\right]</script><h3 id="1层→2层"><a href="#1层→2层" class="headerlink" title="1层→2层"></a>1层→2层</h3><p>第二层输入值为：</p><script type="math/tex; mode=display">z^{(2)}=\left[\begin{matrix}z_0^{(2)} \\z_1^{(2)} \\z_2^{(2)} \\z_3^{(2)} \\z_4^{(2)} \\\end{matrix}\right]=w^{(2)}a^{(1)}=\left[\begin{matrix}w_{00}^{(2)} & w_{01}^{(2)} & w_{02}^{(2)} & w_{03}^{(2)} & w_{04}^{(2)}\\w_{10}^{(2)} & w_{11}^{(2)} & w_{12}^{(2)} & w_{13}^{(2)} & w_{04}^{(2)}\\w_{20}^{(2)} & w_{21}^{(2)} & w_{22}^{(2)} & w_{23}^{(2)} & w_{04}^{(2)}\\w_{30}^{(2)} & w_{31}^{(2)} & w_{32}^{(2)} & w_{33}^{(2)} & w_{04}^{(2)}\\w_{40}^{(2)} & w_{41}^{(2)} & w_{42}^{(2)} & w_{43}^{(2)} & w_{04}^{(2)}\\\end{matrix}\right]·\left[\begin{matrix}a_0^{(1)} \\a_1^{(1)} \\a_2^{(1)} \\a_3^{(1)} \\a_4^{(1)} \\\end{matrix}\right]\\=\left[\begin{matrix}0.21 & 0.22 & 0.23 &0.24 & 0.25\\0.16 & 0.17 & 0.18 &0.19 & 0.20\\0.11 & 0.12 & 0.13 &0.14 & 0.15\\0.06 & 0.07 & 0.08 & 0.09 & 0.10\\0.01 & 0.02 & 0.03 & 0.04 & 0.05\\\end{matrix}\right]·\left[\begin{matrix}0.6457\\0.6682\\0.6900\\0.7109\\0.7311\\\end{matrix}\right]=\left[\begin{matrix}0.7947\\0.6224\\0.4501\\0.2778\\0.1055\\\end{matrix}\right]</script><p>第二层输出值为：</p><script type="math/tex; mode=display">a^{(2)}=\left[\begin{matrix}a_0^{(2)} \\a_1^{(2)} \\a_2^{(2)} \\a_3^{(2)} \\\end{matrix}\right]=\sigma\left(z^{(2)}\right)=\sigma\left(\left[\begin{matrix}0.7947\\0.6224\\0.4501\\0.2778\\0.1055\\\end{matrix}\right]\right)=\left[\begin{matrix}0.6888\\0.6508\\0.6107\\0.5690\\0.5264\\\end{matrix}\right]</script><h3 id="2层→3层"><a href="#2层→3层" class="headerlink" title="2层→3层"></a>2层→3层</h3><p>第三层输入值为：</p><script type="math/tex; mode=display">z^{(3)}=\left[\begin{matrix}z_0^{(3)} \\z_1^{(3)} \\\end{matrix}\right]=w^{(3)}a^{(2)}=\left[\begin{matrix}w_{00}^{(3)} & w_{01}^{(3)} & w_{02}^{(3)} & w_{03}^{(3)} & w_{04}^{(3)}\\w_{10}^{(3)} & w_{11}^{(3)} & w_{12}^{(3)} & w_{13}^{(3)} & w_{04}^{(3)}\\\end{matrix}\right]·\left[\begin{matrix}a_0^{(2)} \\a_1^{(2)} \\a_2^{(2)} \\a_3^{(2)} \\a_4^{(2)} \\\end{matrix}\right]\\=\left[\begin{matrix}0.16 & 0.17 & 0.18 & 0.19 & 0.20\\0.21 & 0.22 & 0.23 & 0.24 & 0.25\\\end{matrix}\right]·\left[\begin{matrix}0.6888\\0.6508\\0.6107\\0.5690\\0.5264\\\end{matrix}\right]=\left[\begin{matrix}0.5441\\0.6964\\\end{matrix}\right]</script><p>第三层输出值为：</p><script type="math/tex; mode=display">a^{(3)}=\left[\begin{matrix}a_0^{(3)} \\a_1^{(3)} \\\end{matrix}\right]=\sigma\left(z^{(3)}\right)=\sigma\left(\left[\begin{matrix}0.7947\\0.6224\\\end{matrix}\right]\right)=\left[\begin{matrix}0.6328\\0.6674\\\end{matrix}\right]</script><h3 id="误差"><a href="#误差" class="headerlink" title="误差"></a>误差</h3><script type="math/tex; mode=display">C^{(3)}=\sum\limits_i\frac12(y_i^{(3)}-a_i^{(3)})^2\\=\frac 12(0.6328-0.10)^2+\frac 12(0.6674-0.24)^2=0.2332</script><h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2><h3 id="3层→2层"><a href="#3层→2层" class="headerlink" title="3层→2层"></a>3层→2层</h3><p>有以下数学关系：</p><script type="math/tex; mode=display">C^{(3)}=\frac12(y^{(3)}-a^{(3)})^2\\a^{(3)}=\sigma(z^{(3)})\\z^{(3)}=w^{(3)}a^{(2)}</script><p>因此 权重梯度</p><script type="math/tex; mode=display">\bigtriangledown w_{ij}^{(3)}=\frac{\partial C^{(3)}}{\partial w_{ij}^{(3)}}=\frac{\partial C^{(3)}}{\partial a_i^{(3)}}\frac{\partial a_i^{(3)}}{\partial z_i^{(3)}}\frac{\partial z_i^{(3)}}{\partial w_{ij}^{(3)}}=(a_i^{(3)}-y_i^{(3)})\sigma(z_i^{(3)})[1-\sigma(z_i^{(3)})]a_j^{(2)}\\\bigtriangledown w^{(3)}=\left[\begin{matrix}0.0853 & 0.0806 & 0.0756 & 0.0704 & 0.0652\\0.0654 & 0.0617 & 0.0579 & 0.0540 & 0.0499\\\end{matrix}\right]</script><p>修正后权重：</p><script type="math/tex; mode=display">w^{(3)'}=w^{(3)}-\bigtriangledown w^{(3)}=\left[\begin{matrix}0.0747 & 0.0894 & 0.1044 & 0.1196 & 0.1348\\0.1446 & 0.1583 & 0.1721 & 0.1860 & 0.2001\\\end{matrix}\right]</script><h3 id="2层→1层"><a href="#2层→1层" class="headerlink" title="2层→1层"></a>2层→1层</h3><p>有以下数学关系：</p><script type="math/tex; mode=display">C^{(3)}=\frac12(y^{(3)}-a^{(3)})^2\\a^{(3)}=\sigma(z^{(3)})\\z^{(3)}=w^{(3)}a^{(2)}\\a^{(2)}=\sigma(z^{(2)})\\z^{(2)}=w^{(2)}a^{(1)}\\</script><p>因此 权重梯度</p><script type="math/tex; mode=display">\bigtriangledown w_{ij}^{(2)}=\frac{\partial C^{(3)}}{\partial w_{ij}^{(2)}}=\frac{\partial C^{(3)}}{\partial a_i^{(2)}}\frac{\partial a_i^{(2)}}{\partial z_{i}^{(2)}}\frac{\partial z_i^{(2)}}{\partial w_{ij}^{(2)}}=\frac{\partial C^{(3)}}{\partial a_i^{(2)}}\sigma(z_i^{(2)})[1-\sigma(z_i^{(2)})]a_j^{(1)}\\\bigtriangledown w^{(2)}=\left[\begin{matrix}0.0032 & 0.0033 & 0.0034 & 0.0035 & 0.0036\\0.0038 & 0.0040 & 0.0041 & 0.0042 & 0.0043\\0.0045 & 0.0046 & 0.0048 & 0.0049 & 0.0051\\0.0051 & 0.0053 & 0.0055 & 0.0057 & 0.0058\\0.0057 & 0.0059 & 0.0061 & 0.0063 & 0.0065\\\end{matrix}\right]</script><p>其中</p><script type="math/tex; mode=display">\frac{\partial C^{(3)}}{\partial a_i^{(2)}}=\sum\limits_i\frac{\partial C^{(3)}}{\partial a_i^{(3)}}\frac{\partial a_i^{(3)}}{\partial z_i^{(3)}}\frac{\partial z_i^{(3)}}{\partial a_{j}^{(2)}}=\sum\limits_i\frac{\partial C^{(3)}}{\partial a_i^{(3)}}a_i^{(3)}(1-a_i^{(3)})w_{ij}^{(3)'}\\</script><p>修正后权重：</p><script type="math/tex; mode=display">w^{(2)'}=w^{(2)}-\bigtriangledown w^{(3)}=\left[\begin{matrix}0.2068 & 0.2167 & 0.2266 & 0.2365 & 0.2464\\0.1562 & 0.1660 & 0.1759 & 0.1858 & 0.1957\\0.1055 & 0.1154 & 0.1252 & 0.1351 & 0.1449\\0.0549 & 0.0647 & 0.0745 & 0.0843 & 0.0942\\0.0043 & 0.0141 & 0.0239 & 0.0337 & 0.0435\\\end{matrix}\right]</script><h3 id="1层→0层"><a href="#1层→0层" class="headerlink" title="1层→0层"></a>1层→0层</h3><p>有以下数学关系：</p><script type="math/tex; mode=display">C^{(3)}=\frac12(y^{(3)}-a^{(3)})^2\\a^{(3)}=\sigma(z^{(3)})\\z^{(3)}=w^{(3)}a^{(2)}\\a^{(2)}=\sigma(z^{(2)})\\z^{(2)}=w^{(2)}a^{(1)}\\a^{(1)}=\sigma(z^{(1)})\\z^{(1)}=w^{(1)}a^{(0)}\\</script><p>因此 权重梯度</p><script type="math/tex; mode=display">\bigtriangledown w_{ij}^{(1)}=\frac{\partial C^{(3)}}{\partial w_{ij}^{(1)}}=\frac{\partial C^{(3)}}{\partial a_i^{(1)}}\frac{\partial a_i^{(1)}}{\partial z_{i}^{(1)}}\frac{\partial z_i^{(2)}}{\partial w_{ij}^{(1)}}=\frac{\partial C^{(3)}}{\partial a_i^{(1)}}\sigma(z_i^{(1)})[1-\sigma(z_i^{(1)})]a_j^{(0)}\\\bigtriangledown w^{(1)}=\left[\begin{matrix}0.0029 & 0.0022 & 0.0014 & 0.0007\\0.0031 & 0.0023 & 0.0015 & 0.0008\\0.0033 & 0.0025 & 0.0016 & 0.0008\\0.0034 & 0.0026 & 0.0017 & 0.0009\\0.0036 & 0.0027 & 0.0018 & 0.0009\\\end{matrix}\right]</script><p>其中</p><script type="math/tex; mode=display">\frac{\partial C^{(3)}}{\partial a_i^{(1)}}=\sum\limits_i\frac{\partial C^{(3)}}{\partial a_i^{(2)}}\frac{\partial a_i^{(2)}}{\partial z_i^{(3)}}\frac{\partial z_i^{(2)}}{\partial a_{j}^{(2)}}=\sum\limits_i\frac{\partial C^{(3)}}{\partial a_i^{(2)}}a_i^{(2)}(1-a_i^{(2)})w_{ij}^{(2)}\\</script><p>修正后权重：</p><script type="math/tex; mode=display">w^{(1)'}=w^{(1)}-\bigtriangledown w^{(3)}=\left[\begin{matrix}0.0071 & 0.0578 & 0.1086 & 0.1593\\0.0169 & 0.0677 & 0.1185 & 0.1692\\0.0267 & 0.0775 & 0.1284 & 0.1792\\0.0366 & 0.0874 & 0.1383 & 0.1891\\0.0464 & 0.0973 & 0.1482 & 0.1991\\\end{matrix}\right]</script><p>一次完整的样本训练过程就结束了</p><h3 id="训练后误差"><a href="#训练后误差" class="headerlink" title="训练后误差"></a>训练后误差</h3><script type="math/tex; mode=display">C^{(3)'}=\sum\limits_i\frac12(y_i^{(3)}-a_i^{(3)})^2\\=\frac 12(0.5769-0.10)^2+\frac 12(0.6259-0.24)^2=0.1882<0.2332=C^{(3)}</script><h3 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h3><blockquote><p>Matlab代码，比较低级，算是半个手工计算。。。</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs matlab">Y = [<span class="hljs-number">0.10</span> <span class="hljs-number">0.24</span>]&#x27;;<br>W10 = [<span class="hljs-number">0.01</span>:<span class="hljs-number">0.05</span>:<span class="hljs-number">0.16</span>;...<br>           <span class="hljs-number">0.02</span>:<span class="hljs-number">0.05</span>:<span class="hljs-number">0.17</span>;...<br>           <span class="hljs-number">0.03</span>:<span class="hljs-number">0.05</span>:<span class="hljs-number">0.18</span>;...<br>           <span class="hljs-number">0.04</span>:<span class="hljs-number">0.05</span>:<span class="hljs-number">0.19</span>;...<br>           <span class="hljs-number">0.05</span>:<span class="hljs-number">0.05</span>:<span class="hljs-number">0.20</span>];<br>A0 = [<span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span>]&#x27;;<br>W20 = [<span class="hljs-number">0.21</span>:<span class="hljs-number">0.01</span>:<span class="hljs-number">0.25</span>;...<br>           <span class="hljs-number">0.16</span>:<span class="hljs-number">0.01</span>:<span class="hljs-number">0.20</span>;...<br>           <span class="hljs-number">0.11</span>:<span class="hljs-number">0.01</span>:<span class="hljs-number">0.15</span>;...<br>           <span class="hljs-number">0.06</span>:<span class="hljs-number">0.01</span>:<span class="hljs-number">0.10</span>;...<br>           <span class="hljs-number">0.01</span>:<span class="hljs-number">0.01</span>:<span class="hljs-number">0.05</span>];<br>W30 =  [<span class="hljs-number">0.16</span>:<span class="hljs-number">0.01</span>:<span class="hljs-number">0.20</span>;...<br>           <span class="hljs-number">0.21</span>:<span class="hljs-number">0.01</span>:<span class="hljs-number">0.25</span>];<br>Z1 = W10*A0;<br>A1 = <span class="hljs-number">1.</span>/(<span class="hljs-number">1.</span>+<span class="hljs-built_in">exp</span>(-Z1));<br>Z2 = W20*A1;<br>A2 = <span class="hljs-number">1.</span>/(<span class="hljs-number">1.</span>+<span class="hljs-built_in">exp</span>(-Z2));<br>Z3 = W30*A2;<br>A3 = <span class="hljs-number">1.</span>/(<span class="hljs-number">1.</span>+<span class="hljs-built_in">exp</span>(-Z3));<br>C = <span class="hljs-number">0.5</span>.*(Y - A3).*(Y - A3);<br>DW3 = (A3-Y).*(A3).*(<span class="hljs-number">1</span>-A3)*A2&#x27;;<br>W3 = W30 - DW3;<br>DA3 = A3-Y;<br>DA2 = (DA3.*A3.*(<span class="hljs-number">1</span>-A3))&#x27;*W3;<br>DA2 = DA2&#x27;;<br>DW2 = DA2.*A2.*(<span class="hljs-number">1</span>-A2)*A1&#x27;;<br>W2 = W20 - DW2;<br>DA1 = (DA2.*A2.*(<span class="hljs-number">1</span>-A2))&#x27;*W2;<br>DA1 = DA1&#x27;;<br>DW1 = DA1.*A1.*(<span class="hljs-number">1</span>-A1)*A0&#x27;;<br>W1 = W10 - DW1;<br><br>Z11 = W1*A0;<br>A11 = <span class="hljs-number">1.</span>/(<span class="hljs-number">1.</span>+<span class="hljs-built_in">exp</span>(-Z11));<br>Z21 = W2*A11;<br>A21 = <span class="hljs-number">1.</span>/(<span class="hljs-number">1.</span>+<span class="hljs-built_in">exp</span>(-Z21));<br>Z31 = W3*A21;<br>A31 = <span class="hljs-number">1.</span>/(<span class="hljs-number">1.</span>+<span class="hljs-built_in">exp</span>(-Z31));<br>C1 = <span class="hljs-number">0.5</span>.*(Y - A31).*(Y - A31);<br></code></pre></td></tr></table></figure><hr><p>2018-10-21</p>]]></content>
    
    
    <categories>
      
      <category>计算机相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>Matlab</tag>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>技术经济学笔记</title>
    <link href="/2019/01/18/WHUT/TechnicalEconomics/"/>
    <url>/2019/01/18/WHUT/TechnicalEconomics/</url>
    
    <content type="html"><![CDATA[<p>资金有时间价值，资金有时间价值，资金有时间价值，重要的话说3遍。</p><span id="more"></span><hr><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200822205435.png" alt="思维导图"></p><hr><p>Learning By Sharing，2018©Fu_Qingchen，Markdown，XMind</p>]]></content>
    
    
    <categories>
      
      <category>机械相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>有限元</tag>
      
      <tag>经济</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最优化技术笔记</title>
    <link href="/2018/12/21/WHUT/OptimalDesignOfMachine/"/>
    <url>/2018/12/21/WHUT/OptimalDesignOfMachine/</url>
    
    <content type="html"><![CDATA[<p>学的时候没太在意，不过在后面遇到了蛮多相关的知识点（机器学习、起重机等都有它的身影）。</p><span id="more"></span><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="优化的概念"><a href="#优化的概念" class="headerlink" title="优化的概念"></a>优化的概念</h2><ul><li>可以理解为：求极小值</li><li>优化问题的解决离不开数学手段</li><li>优化技术要解决的问题<ul><li>数学建模</li><li>优化问题的求解</li><li>优化结果的评价</li></ul></li></ul><h2 id="最优化问题的数学模型"><a href="#最优化问题的数学模型" class="headerlink" title="最优化问题的数学模型"></a>最优化问题的数学模型</h2><blockquote><p>例 : 某工厂生产A、B产品如下 表 ，合理分配使利润最大</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">产品</th><th style="text-align:center">材料</th><th style="text-align:center">工时</th><th style="text-align:center">电力</th><th style="text-align:center">利润</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center">9</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">60</td></tr><tr><td style="text-align:center">B</td><td style="text-align:center">4</td><td style="text-align:center">10</td><td style="text-align:center">5</td><td style="text-align:center">120</td></tr><tr><td style="text-align:center">供应量</td><td style="text-align:center">360</td><td style="text-align:center">300</td><td style="text-align:center">200</td><td style="text-align:center">-</td></tr></tbody></table></div><h3 id="优化问题的数学模型的概念"><a href="#优化问题的数学模型的概念" class="headerlink" title="优化问题的数学模型的概念"></a>优化问题的数学模型的概念</h3><ul><li>设计变量：设计方案中待求的可变的量（是独立变量)，用 $X=(x_1,x_2…x_n)^T$ 表示</li><li>预定参数：设计中的已知项</li><li>设计空间：以设计分量 $x_i$ 为坐标轴所构成的空间</li><li>目标函数：将优化的目标表达成设计变量的函数，记为 $F(X)$，用于评价方案的好坏</li><li>约束函数限制条件：用 $g_u(X)\leq0,h_v(X)=0(u,v=1,2…)$ </li><li>可行域：同时满足 $g_u(X),h_v(X)$ 的点的集合</li><li>等值线：等值线上的所有 $X$ 使目标函数或约束函数值相等</li></ul><h3 id="优化问题的数学模型的标准模式"><a href="#优化问题的数学模型的标准模式" class="headerlink" title="优化问题的数学模型的标准模式"></a>优化问题的数学模型的标准模式</h3><p>求设计变量 $X=(x_1,x_2…x_n)^T$ ，使得</p><script type="math/tex; mode=display">f(X)\rightarrow\min</script><p>并且满足</p><script type="math/tex; mode=display">g_u(X)\leq0,u=1,2...\\h_v(X)=0,v=1,2...</script><h2 id="优化问题的分类"><a href="#优化问题的分类" class="headerlink" title="优化问题的分类"></a>优化问题的分类</h2><ul><li><p>有无约束</p></li><li><p>目标函数约束函数性质</p><ul><li><p>线性规划：$F,g,h$ 中 <strong>均为</strong> 线性</p></li><li><p>非线性规划：$F,g,h$ 中 <strong>有一个不是</strong> 线性</p></li></ul></li><li><p>目标函数个数</p><ul><li><p>单目标优化：模型中只有一个目标函数</p></li><li><p>多 目标优化：模型有多个目标函数</p></li></ul></li><li><p>设计变量</p></li></ul><h2 id="优化问题的求解思路"><a href="#优化问题的求解思路" class="headerlink" title="优化问题的求解思路"></a>优化问题的求解思路</h2><ul><li>解析法</li><li>数值计算方法</li></ul><p>对于优化问题，依次从初始点出发，找到一串点 $X^0,X^1…X^k$ ，对应的目标函数值 $f(X^0)&gt;f(X^1)&gt;…$ 若存在最优解，$f(X)$ 最终收敛于 $f(X^<em>)$ ，$X^</em>$ 为最优解</p><p>根据 $X^k$ 和 $X^*$ 的接近程度，有 3 种收敛条件</p><ul><li>$|X^{k+1}-X^k|&lt;\varepsilon$ </li><li>$|F(X^{k+1})-F(X^k)|&lt;\varepsilon$ </li><li>$|\nabla F(X^k)|&lt;\varepsilon$</li></ul><h3 id="迭代一般格式"><a href="#迭代一般格式" class="headerlink" title="迭代一般格式"></a>迭代一般格式</h3><ol><li>给定初始点 $X^{k}|_{k=0}$，收敛精度 $\varepsilon$</li><li>按某种规则构造搜索方向 $S^{k}$</li><li>从 $X^{k}$ 出发 , 沿 $S^k$ 方向，找到在此方向上的最优点 $X^{k+1}$</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">x[k]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;Z(X)&lt;ε;k++)&#123;<br>    X[k+<span class="hljs-number">1</span>]=X[k]+α[k]S[k]<br>&#125;<br></code></pre></td></tr></table></figure><p>​    其中<code>Z(X)</code> 为收敛条件，<code>α[k]</code>为步长因子</p><h1 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h1><h2 id="极值理论"><a href="#极值理论" class="headerlink" title="极值理论"></a>极值理论</h2><h3 id="一元函数极值"><a href="#一元函数极值" class="headerlink" title="一元函数极值"></a>一元函数极值</h3><ul><li><p>必要条件：$f’(x_0)=0$ ，$x_0$ 为驻点</p></li><li><p>充分条件：$f’’(x_0)&gt;0$ ， $x_0$ 为极小值；$f’’(x_0)&lt;0$ ， $x_0$ 为极大值；</p></li></ul><h3 id="二元函数极值"><a href="#二元函数极值" class="headerlink" title="二元函数极值"></a>二元函数极值</h3><ul><li>必要条件：$f’_x(x_0,y_0)=0,f’_y(x_0,y_0)=0$ </li><li>充分条件：若 $\partial^2f/\partial x^2=A$，$\partial^2f/\partial xy=B$，$\partial^2f/\partial x^2=C$，$AC-B^2&gt;0$ 有极值；$AC-B^2&lt;0$ 无极值</li></ul><h3 id="多元函数极值"><a href="#多元函数极值" class="headerlink" title="多元函数极值"></a>多元函数极值</h3><h4 id="方向导数与梯度"><a href="#方向导数与梯度" class="headerlink" title="方向导数与梯度"></a>方向导数与梯度</h4><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823204527.png" alt=""></p><p>以二元函数为例，在点 $X^0$ 沿任意方向 $S_0$ 的变化率</p><script type="math/tex; mode=display">\frac{\partial f}{\partial S_0}\\=\lim\limits_{ds\rightarrow0}\frac{f(X^1)-f(X^0)}{ds}\\=\lim\limits_{dx,dy\rightarrow0}\left[\frac{f(x_0+dx,y_0)-f(x_0,y_0)}{dx}\frac{dx}{ds}+\frac{f(x_0+dx,y_0+dy)-f(x_0+dx,y_0)}{dy}\frac{dy}{ds}\right]\\=\frac{\partial f}{\partial x}\cos\theta_1+\frac{\partial f}{\partial y}\cos\theta_2=\begin{bmatrix}\frac{\partial f}{\partial x}\\\frac{\partial f}{\partial y}\end{bmatrix}\begin{bmatrix}\cos\theta_1\\\cos\theta_2\end{bmatrix}=\nabla f\begin{bmatrix}\cos\theta_1\\\cos\theta_2\end{bmatrix}</script><blockquote><p>这里写成 $\cos\theta_1,\cos\theta_2$ 是考虑到多元函数</p></blockquote><p>​    其中：$\nabla f$ 为梯度，$\begin{bmatrix}<br>\cos\theta_1\\<br>\cos\theta_2<br>\end{bmatrix}$ 为单位向量，记为 $S$ </p><script type="math/tex; mode=display">\frac{\partial f}{\partial S}=|\nabla f|\cos\theta,\theta=<\nabla f,S></script><h5 id="梯度性质"><a href="#梯度性质" class="headerlink" title="梯度性质"></a>梯度性质</h5><ul><li>$\nabla F$ 表示该函数上升最快的方向，也是等值线的法线方向</li><li>梯度是函数在一点邻域的局部描述，离开邻域不一定是下降最快的方向</li></ul><h4 id="多元函泰勒展开"><a href="#多元函泰勒展开" class="headerlink" title="多元函泰勒展开"></a>多元函泰勒展开</h4><ul><li>作用：对复杂函数在一点邻域内简化</li></ul><script type="math/tex; mode=display">f(X)=f(X_0)+\nabla f(X)(X-X_0)+\frac12(X-X_0)^T\nabla^2f(X)(X-X_0)</script><p>​    其中 $\nabla=\begin{bmatrix}<br>\partial/\partial x \\<br>\partial /\partial y<br>\end{bmatrix},\nabla^2=\begin{bmatrix}<br>\partial^2/\partial x^2 &amp;\partial^2/\partial x\partial y\\<br>\partial ^2/\partial y\partial x&amp;\partial^2/\partial y^2<br>\end{bmatrix}$ </p><blockquote><p>$\nabla^2f$ 又称海塞矩阵 </p></blockquote><h3 id="函数在-X-处取极值条件"><a href="#函数在-X-处取极值条件" class="headerlink" title="函数在 $X^*$ 处取极值条件"></a>函数在 $X^*$ 处取极值条件</h3><ul><li>必要条件：$\nabla f(X^*)=0$ <blockquote><p>对任意 $S,\nabla f·S\geq0$ ，取 $S=S_0,S=-S_0$ 得到</p></blockquote></li><li>充分条件：$\nabla^2f(X^*)$ 正定</li></ul><blockquote><p>其他点都要比极小点大</p><p>设 $M$ 是 $n$ 阶方阵，如果对任何非零向量 $z$ ，都有 $z^TMz\geq0$ ，其中 $z^T$ 表示 $z$ 的转置，就称 $M$ 为正定矩阵。</p><p>【补充：判断正定矩阵的方法】</p><p>计算对称矩阵A的各阶顺序主子式。若A的各阶顺序主子式均大于零，则A是正定的</p></blockquote><h2 id="函数凹凸性"><a href="#函数凹凸性" class="headerlink" title="函数凹凸性"></a>函数凹凸性</h2><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823204604.png" alt=""></p><ul><li>凸集：任意连接<strong>点集</strong>中任意两点 $x_1,x_2$ 的线段全包含在集合内</li><li>凸函数：$f[\alpha x_1+(1-\alpha)x_2]\leq\alpha f(x_1)+(1-\alpha)f(x_2),0&lt;\alpha&lt;1$ </li><li>若 $f(X)$ 的海塞矩阵 $\nabla f$ 处处正定，$f(X)$ 为严格凸函数</li><li>凹凸性应用<ul><li>约束函数 $g(X)$ 是凸函数，$g(X)&lt;0$ 围成区域为凸集</li><li>约束函数 $g(X)$ 是凹函数，$g(X)&gt;0$ 围成区域为凸集</li><li>凹凸性与极值关系<ul><li>目标函数<strong>是</strong>凸函数，约束函数<strong>是</strong>凸函数，极值点在可行域内（a）</li><li>目标函数<strong>是</strong>凸函数，约束函数<strong>是</strong>凸函数，极值点不在可行域内（b）</li><li>目标函数<strong>是</strong>凸函数，约束函数<strong>不是</strong>凸函数（c）</li><li>目标函数<strong>不是</strong>凸函数，约束函数<strong>是</strong>凸函数（d）</li></ul></li></ul></li></ul><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823204629.png" alt=""></p><h1 id="一维搜索"><a href="#一维搜索" class="headerlink" title="一维搜索"></a>一维搜索</h1><p>对于一个优化问题 $\min f(X)$ ，通过搜索方向 $S$ 的构造，从初始点 $X_0$ 出发，寻找一组是目标函数下降的点的序列。在迭代的每一步 $X^{k+1}=X^K+\alpha_KS^K$ ，带入到目标函数，得 $f(\alpha_K)$ ，每一步迭代都归结于求 $\alpha_k$ （$X,S$ 已知）</p><blockquote><p>$f(X^K)\rightarrow f(X^{K+1})$ 转变为 $f(\alpha_K)\rightarrow f(X^{K=1})$</p></blockquote><p>求解基本步骤</p><ol><li>找到一个包含极小点的区间</li><li>在区间内找到 $\alpha^*$</li></ol><h2 id="进退法（搜索区间的确定）"><a href="#进退法（搜索区间的确定）" class="headerlink" title="进退法（搜索区间的确定）"></a>进退法（搜索区间的确定）</h2><p>从某给定初值 $\alpha_0$ 开始，以初始步长 $h$ 向前试探。如果函数值上升，则步长变号，即改变试探方向；如果函数值下降，则维持原来的试探方向。区间的始点、中间点依次沿试探方向移动一步。此过程一直进行到函数值再次上升时为止，即可找到搜索区间的终点。最后得到的三点即为搜索区间的始点、中间点和终点，形成函数值的 “高—低—高” 趋势。</p><p>步骤：给定初始点及步长 $\alpha_0,h$</p><ul><li><p>若 $f(\alpha_k+h)&gt;f(\alpha_k)$ ，最优步长位于 $\alpha_k+h$ 左侧，右端点可以确定。搜索方向不对，使 $h=-h$ ,重新搜索，直到出现 $f(a_K+h)&gt;f(\alpha_k))$ 。这个 $\alpha_K+h$ 就是左端点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (f(alpha_k + h) &gt; f(alpha_k))&#123;<br>    b = alpha_k + h;<br>    <span class="hljs-keyword">while</span>(f(alpha_k - h) &gt; f(alpha_k))&#123;<br>        alpha_k -= h;<br>    &#125;<br>    a = alpha_k - h;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>反过来也是类似的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (f(alpha_k + h) &lt; f(alpha_k))&#123;<br>    a = alpha_k;<br>    <span class="hljs-keyword">while</span>(f(alpha_k + h) &gt; f(alpha_k))&#123;<br>        alpha_k += h;<br>    &#125;<br>    a = alpha_k + h;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823204752.png" alt="进退法"></p><h2 id="区间消去法（不断减少区间最终获得极小点）"><a href="#区间消去法（不断减少区间最终获得极小点）" class="headerlink" title="区间消去法（不断减少区间最终获得极小点）"></a>区间消去法（不断减少区间最终获得极小点）</h2><p>已知区间 $[a,b]$ 在其中任取 $a_1&lt;b_2$ </p><ul><li>若 $f(a_1)&lt;f(b_1)$ ，极值点在 $b_1$ 左侧，消去无用区间得到$[a,b_1]$ </li><li>若 $f(a_1)=f(b_1)$ ，极值点在 $a_1,b_1$ 中间，消去无用区间得到$[a_1,b_1]$ </li><li>若 $f(a_1)&gt;f(b_1)$ ，极值点在 $a_1$ 右侧，消去无用区间得到$[a_1,b]$ </li></ul><h3 id="黄金分割法"><a href="#黄金分割法" class="headerlink" title="黄金分割法"></a>黄金分割法</h3><p>以搜索区间的0.618倍作为比较点 $a_1,b_1$ 的确定原则</p><ul><li>$a_1=a+0.618(b-a)$</li><li>$b_1=b-0.618(b-a)$</li></ul><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823204832.png" alt="黄金分割法"></p><h3 id="格点法"><a href="#格点法" class="headerlink" title="格点法"></a>格点法</h3><p>其算法为：给定区间 $[a,b]$，将其等分为 $n+1$ 个区间 $(n\geq3)$，计算 $f(a_1),f(a_2)…f(a_n)$，找出其中的最小点 $f(a_m)=\min\{f(a_1),f(a_2)…f(a_n)\}$，$a_m$左右两点就构成搜索区间 $[a_{m-1},a_{m+1}]$，直至 $|a_{m+1}-a_{m-1}|\leq\varepsilon$ </p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823204916.png" alt="格点法"></p><h3 id="平分法"><a href="#平分法" class="headerlink" title="平分法"></a>平分法</h3><p>取 $a,b$ 中点 $a_K=(a+b)/2$ 利用中点附近的导数的正负性，判断取舍区间</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823204955.png" alt="平分法"></p><blockquote><p>当一阶导数无法求时，可以使用 $f(\alpha_k+\varepsilon)-f(\alpha_k-\varepsilon)$ 代替</p></blockquote><h2 id="二次插值法"><a href="#二次插值法" class="headerlink" title="二次插值法"></a>二次插值法</h2><p>原理：</p><p>对函数$f(x)$取三点 ${x_1}&lt;{x_2}&lt;{x_3}$ 对应函数值 $f(x_1)&gt;f(x_2)&lt;f(x_3) $ ，以此构造插值多项式 $ P(x)=a_0+a_1x+a_2x^2 $ ，其极值点 $ x^*=-a_1/2a_2 $ </p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823205103.png" alt="二次插值法"></p><h1 id="无约束规划"><a href="#无约束规划" class="headerlink" title="无约束规划"></a>无约束规划</h1><p>上一章确定了步长，但是没有确定方向，这一章就是在无约束问题中确定方向的</p><h2 id="梯度法（最速下降法）"><a href="#梯度法（最速下降法）" class="headerlink" title="梯度法（最速下降法）"></a>梯度法（最速下降法）</h2><p>$-\nabla f(X)$ 方向是函数值下降最快的方向，取方向 $S=-\nabla f(X)$ </p><ul><li>迭代格式：$X^{K+1}=X^K-\alpha_K\nabla f(X)$ </li><li>收敛条件：$||\nabla f(X)||&lt;\varepsilon$ </li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>相邻两次搜索正交，搜索路径呈锯齿形，越靠近极点，越慢，搜索效率越低</p><h2 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h2><p>由于<strong>高次</strong>函数的导数不好求，于是现将其用泰勒公式<strong>转化为二次</strong> ，再求梯度</p><ul><li>迭代格式 $X^{K+1}=X^K-[\nabla^2 f(X)]^{-1}\nabla f(X)$ </li></ul><p>流程图太简单了。。。。</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>工作量大、对高次函数，泰勒展开只是近似解，且步长恒为1，其极值不准确</p><h2 id="修正牛顿法"><a href="#修正牛顿法" class="headerlink" title="修正牛顿法"></a>修正牛顿法</h2><p>在牛顿法的基础上引入了最优步长，确保沿 $\nabla f(X)$ 方向下降最快</p><ul><li>迭代格式 $X^{K+1}=X^K-\alpha_K[\nabla^2 f(X)]^{-1}\nabla f(X)$ </li></ul><p>流程图与梯度法类似，知识把迭代格式改了一下</p><h2 id="共轭方向法"><a href="#共轭方向法" class="headerlink" title="共轭方向法"></a>共轭方向法</h2><p>构造共轭方向，函数值下降的方向就是共轭方向，这样得出极小点</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>设 $A$ 为正定矩阵， 若一组向量 $s_1,s_2…s_k$ 满足 $s_i^TAs_j=0,i,j=1,2…k,i\neq j$ 则称这组向量关于 $A$ 共轭。当 $A=E$ 时，则这组向量为共轭向量。 </p><blockquote><p>设 $M$ 是 $n$ 阶方阵，如果对任何非零向量 $z$ ，都有 $z^TMz\geq0$ ，其中 $z^T$ 表示 $z$ 的转置，就称 $M$ 为正定矩阵。</p></blockquote><h3 id="共轭性质"><a href="#共轭性质" class="headerlink" title="共轭性质"></a>共轭性质</h3><ul><li>要使 $X^2$ 为二元函数的极小点，只需要使两次一维搜索方向 $S^0,S^1$ 与 $\nabla^2 f(X)$ 共轭</li><li>对 n 元二次函数，若 $S^i,i=1,2…n$ 与 $\nabla^2f(X)$ 共轭，沿着这几个方向进行一维搜索，最多进行 n 次即可找到极小点</li></ul><h3 id="共轭方向的构造"><a href="#共轭方向的构造" class="headerlink" title="共轭方向的构造"></a>共轭方向的构造</h3><h4 id="平行搜索法"><a href="#平行搜索法" class="headerlink" title="平行搜索法"></a>平行搜索法</h4><ul><li>对函数 $f(X)=\frac12X^T\nabla^2fX+BX+C$ 任意两个点 $X_1^0,X_2^0$ ，分别沿着同一方向 $S^0$ 进行一维搜索，得到两个一维搜索点 $X_1^1,X_2^1$ ，连接两点的方向 $S^1=X_2^1-X_1^1$ 与 $S^0$ 关于 $\nabla^2f(X)$ 共轭</li></ul><h4 id="共轭梯度法"><a href="#共轭梯度法" class="headerlink" title="共轭梯度法"></a>共轭梯度法</h4><ul><li>$S^0=\nabla f(X^0),S^{K+1}=-\nabla f(X)+\beta_KS^K,\beta_K=||\nabla f(X^{K+1})||^2/||\nabla f(X^{K})||^2$ </li></ul><h1 id="实验报告"><a href="#实验报告" class="headerlink" title="实验报告"></a>实验报告</h1><h2 id="1-进退法求解初始区间"><a href="#1-进退法求解初始区间" class="headerlink" title="1. 进退法求解初始区间"></a>1. 进退法求解初始区间</h2><p>实验日期：2018 年 11 月 8 日</p><h3 id="1-1-实验目的"><a href="#1-1-实验目的" class="headerlink" title="1.1 实验目的"></a>1.1 实验目的</h3><ol><li>加深对进退法的基本理论和算法步骤的理解。</li><li>培养学生独立编制计算机程序的能力。</li><li>掌握常用进退法程序的使用方法。</li></ol><h3 id="1-2-上机内容"><a href="#1-2-上机内容" class="headerlink" title="1.2 上机内容"></a>1.2 上机内容</h3><h4 id="1-2-1-算法概述"><a href="#1-2-1-算法概述" class="headerlink" title="1.2.1 算法概述"></a>1.2.1 算法概述</h4><p>进退法用于求解一元函数 $f(\alpha)$ 极小点 ${\alpha^❀}$ 所在区间 $[a,b]$ 。假设函数 $f(\alpha)$ 为单态函数，根据单态区间的性质，为了确定极小点 $\alpha^❀$ 所在区间 $[a,b]$ ，应使函数 $f(\alpha)$ 在 $[a,b]$ 区间形成 “高—低—高” 趋势。</p><p>其算法为：从某给定初值 $\alpha_0$ 开始，以初始步长 $h$ 向前试探。如果函数值上升，则步长变号，即改变试探方向；如果函数值下降，则维持原来的试探方向。区间的始点、中间点依次沿试探方向移动一步。此过程一直进行到函数值再次上升时为止，即可找到搜索区间的终点。最后得到的三点即为搜索区间的始点、中间点和终点，形成函数值的 “高—低—高” 趋势。</p><h4 id="1-2-2-程序框图"><a href="#1-2-2-程序框图" class="headerlink" title="1.2.2 程序框图"></a>1.2.2 程序框图</h4><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823204752.png" alt=""></p><h4 id="1-2-3-源程序"><a href="#1-2-3-源程序" class="headerlink" title="1.2.3 源程序"></a>1.2.3 源程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*************************************************</span><br><span class="hljs-comment">* @Author: Fu_Qingchen</span><br><span class="hljs-comment">* @Date: 2018-11-7 </span><br><span class="hljs-comment">* @Description: 进退法求解区间</span><br><span class="hljs-comment">*************************************************/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A0 1234</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> H 1069</span><br><br><span class="hljs-comment">/*************************************************</span><br><span class="hljs-comment">* @Description: 要找区间的函数</span><br><span class="hljs-comment">*************************************************/</span><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">function</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span> </span>&#123;<br><span class="hljs-keyword">return</span> (x * x + <span class="hljs-number">15</span> * x + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/*************************************************</span><br><span class="hljs-comment">* @Description: 进退法主函数</span><br><span class="hljs-comment">* @Input: a0:初始值,h:步长,*range:区间左右端点</span><br><span class="hljs-comment">* @Return: 区间左右端点</span><br><span class="hljs-comment">*************************************************/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">jintui</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a0, <span class="hljs-keyword">double</span> h, <span class="hljs-keyword">double</span> *range)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (function(a0)==function(a0+h))<br>&#123;<br>*(range) = a0;<br>*(range + <span class="hljs-number">1</span>) = a0 + h;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (function(a0) &gt; function(a0 + h))<br>&#123;<br>*(range) = a0;<br><span class="hljs-keyword">do</span><br>&#123;<br>a0 += h;<br>&#125; <span class="hljs-keyword">while</span> (function(a0)&gt;function(a0 + h));<br>*(range + <span class="hljs-number">1</span>) = a0 + h;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>*(range + <span class="hljs-number">1</span>) = a0 + h;<br><span class="hljs-keyword">do</span><br>&#123;<br>a0 -= h;<br>&#125; <span class="hljs-keyword">while</span> (function(a0)&lt;function(a0 + h));<br>*(range) = a0 - h;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">double</span> a0 = A0, h = H;<br><span class="hljs-keyword">double</span> range[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>jintui(a0, h, range);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Result:%f,%f\n&quot;</span>, range[<span class="hljs-number">0</span>], range[<span class="hljs-number">1</span>]);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-过程分析"><a href="#1-3-过程分析" class="headerlink" title="1.3 过程分析"></a>1.3 过程分析</h3><p>遇到的问题：</p><h4 id="1-3-1-数组在函数中的传递"><a href="#1-3-1-数组在函数中的传递" class="headerlink" title="1.3.1 数组在函数中的传递"></a>1.3.1 数组在函数中的传递</h4><p>我发现C语言函数一般只能返回一个值，传递数组就比较麻烦</p><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>使用指针在函数之间传递数组</p><p>例如：主函数中，调用的 <code>jintui</code> 函数通过 <code>range</code> 传递区间左右两个端点值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">double</span> range[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>jintui(a0, h, range);<br></code></pre></td></tr></table></figure><h3 id="1-4-结果分析"><a href="#1-4-结果分析" class="headerlink" title="1.4 结果分析"></a>1.4 结果分析</h3><p>给定函数：</p><script type="math/tex; mode=display">f(\alpha)=\alpha^2+15\alpha+1</script><p>其理论极小点为 $\alpha^*=-7.5$ </p><p>给定初值 $\alpha_0=1234$ ，给定步长 $h=1069$</p><p>结果：</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823205311.png" alt=""></p><p>所求区间 $[-1973.000000,2303.000000]$ 包含极小点 $\alpha=-7.5$ ，通过验证</p><h2 id="2-一维搜索法求解最优步长"><a href="#2-一维搜索法求解最优步长" class="headerlink" title="2. 一维搜索法求解最优步长"></a>2. 一维搜索法求解最优步长</h2><p>实验日期：2018 年 11 月 15 日</p><h3 id="2-1-实验目的"><a href="#2-1-实验目的" class="headerlink" title="2.1 实验目的"></a>2.1 实验目的</h3><ol><li>加深对一维搜索方法的基本理论和算法步骤的理解。</li><li>培养学生独立编制计算机程序的能力。</li><li>掌握常用一维搜索方法程序的使用方法。</li></ol><h3 id="2-2-上机内容"><a href="#2-2-上机内容" class="headerlink" title="2.2 上机内容"></a>2.2 上机内容</h3><h4 id="2-2-1-算法概述"><a href="#2-2-1-算法概述" class="headerlink" title="2.2.1 算法概述"></a>2.2.1 算法概述</h4><p>此处使用格点法进行求解。格点法用于通过给定区间 $[a,b]$ 求解函数极小点 $\alpha^*$ 。</p><p>其算法为：给定区间 $[a,b]$，将其等分为 $n+1$ 个区间 $(n\geq3)$，计算 $f(a_1),f(a_2)…f(a_n)$，找出其中的最小点 $f(a_m)=\min\{f(a_1),f(a_2)…f(a_n)\}$，$a_m$左右两点就构成搜索区间 $[a_{m-1},a_{m+1}]$，直至 $|a_{m+1}-a_{m-1}|\leq\varepsilon$ </p><h4 id="2-2-2-程序框图"><a href="#2-2-2-程序框图" class="headerlink" title="2.2.2 程序框图"></a>2.2.2 程序框图</h4><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823204916.png" alt=""></p><h4 id="2-2-3-源程序"><a href="#2-2-3-源程序" class="headerlink" title="2.2.3 源程序"></a>2.2.3 源程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*************************************************</span><br><span class="hljs-comment">* @Author: Fu_Qingchen</span><br><span class="hljs-comment">* @Date: 2018-10-30</span><br><span class="hljs-comment">* @Description: 格点法求解迭代步长</span><br><span class="hljs-comment">*************************************************/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A0 999</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> H 10<span class="hljs-comment">//格点法步长</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 10 <span class="hljs-comment">//格点法等分数</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> V 0.00001<span class="hljs-comment">//精度</span></span><br><br><span class="hljs-comment">/*************************************************</span><br><span class="hljs-comment">* @Description: 要找极小点的函数</span><br><span class="hljs-comment">*************************************************/</span><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">function</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span> </span>&#123;<br><span class="hljs-keyword">return</span> (x * x + <span class="hljs-number">2</span> * x + <span class="hljs-number">1</span>);<br>&#125;<br><br><br><span class="hljs-comment">/*************************************************</span><br><span class="hljs-comment">* @Description: 进退法主函数</span><br><span class="hljs-comment">* @Input: a0:初始值,h:步长,*range:区间左右端点</span><br><span class="hljs-comment">* @Return: 区间左右端点</span><br><span class="hljs-comment">*************************************************/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">jintui</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a0, <span class="hljs-keyword">double</span> h, <span class="hljs-keyword">double</span> *range)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (function(a0) == function(a0 + h))<br>&#123;<br>*(range) = a0;<br>*(range + <span class="hljs-number">1</span>) = a0 + h;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (function(a0) &gt; function(a0 + h))<br>&#123;<br>*(range) = a0;<br><span class="hljs-keyword">do</span><br>&#123;<br>a0 += h;<br>&#125; <span class="hljs-keyword">while</span> (function(a0)&gt;function(a0 + h));<br>*(range + <span class="hljs-number">1</span>) = a0 + h;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>*(range + <span class="hljs-number">1</span>) = a0 + h;<br><span class="hljs-keyword">do</span><br>&#123;<br>a0 -= h;<br>&#125; <span class="hljs-keyword">while</span> (function(a0)&lt;function(a0 + h));<br>*(range) = a0 - h;<br>&#125;<br>&#125;<br><br><br><span class="hljs-comment">/*************************************************</span><br><span class="hljs-comment">* @Description: 平分区间[a,b]为(n+1)等分</span><br><span class="hljs-comment">* @Input: a:区间左端点,b:区间右端点,A:等分点数组</span><br><span class="hljs-comment">* @Return: A[i]</span><br><span class="hljs-comment">*************************************************/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findA</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a, <span class="hljs-keyword">double</span> b, <span class="hljs-keyword">double</span> *A)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>&#123;<br>*(A + i) = (b - a) / (N + <span class="hljs-number">1</span>)*(i + <span class="hljs-number">1</span>) + a;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*************************************************</span><br><span class="hljs-comment">* @Description: 求数组最小值序号</span><br><span class="hljs-comment">* @Input: A:数组</span><br><span class="hljs-comment">* @Return: 最小值序号</span><br><span class="hljs-comment">*************************************************/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(<span class="hljs-keyword">double</span> *A)</span> </span>&#123;<br><span class="hljs-keyword">double</span> tem = *(A + <span class="hljs-number">0</span>);<br><span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (tem &gt; *(A+i))<br>&#123;<br>num = i;<br>tem = *(A + i);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> num;<br>&#125;<br><br><span class="hljs-comment">/*************************************************</span><br><span class="hljs-comment">* @Description: 格点法求解主要函数</span><br><span class="hljs-comment">* @Input: a:区间左端点,b:区间右端点,varepsilon：精度</span><br><span class="hljs-comment">* @Return: A[i]</span><br><span class="hljs-comment">*************************************************/</span><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">geDian</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a, <span class="hljs-keyword">double</span> b, <span class="hljs-keyword">double</span> varepsilon)</span> </span>&#123;<br><span class="hljs-keyword">int</span> num;<br><span class="hljs-keyword">double</span> A[N], F[N];<span class="hljs-comment">//A为等分的点，F为等分点的函数值</span><br><span class="hljs-keyword">do</span><br>&#123;<br>findA(a, b, A);<span class="hljs-comment">//得到等分点</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<span class="hljs-comment">//得到等分点对应函数值</span><br>&#123;<br>F[i] = function(A[i]);<br>&#125;<br>num = findMin(F);<br><span class="hljs-keyword">switch</span> (num)<span class="hljs-comment">//迭代</span><br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:b = A[num + <span class="hljs-number">1</span>]; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> N:a = A[num - <span class="hljs-number">1</span>]; <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> N - <span class="hljs-number">1</span>:a = A[(num - <span class="hljs-number">1</span>)]; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:a = A[num - <span class="hljs-number">1</span>]; b = A[num + <span class="hljs-number">1</span>]; <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">while</span> (b - a &gt; <span class="hljs-number">0</span> ? ((b - a) &gt; varepsilon) : ((a - b) &gt; varepsilon));<br><span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> / <span class="hljs-number">2</span> * (a + b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">double</span> a0 = A0, h = H, range[<span class="hljs-number">2</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">0</span> &#125;, varepsilon = V, result;<br>jintui(a0, h, range);<br>result = geDian(range[<span class="hljs-number">0</span>],range[<span class="hljs-number">1</span>],varepsilon);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Result:%f\n&quot;</span>, result);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-过程分析"><a href="#2-3-过程分析" class="headerlink" title="2.3 过程分析"></a>2.3 过程分析</h3><p>遇到的问题</p><h4 id="2-3-1-C语言与C-的区别"><a href="#2-3-1-C语言与C-的区别" class="headerlink" title="2.3.1 C语言与C++的区别"></a>2.3.1 C语言与C++的区别</h4><p>我的循环是这样写的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)&#123;<br>    <span class="hljs-comment">//Do Some Thing</span><br>&#125;<br></code></pre></td></tr></table></figure><p>C++及Java等语言是支持这个的</p><p>但是我发现在【VC6.0】中的标准C语言不支持临时变量在for循环中定义</p><h5 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h5><p>在函数的开始申明变量，之后再使用变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> i;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length; i++)&#123;<br>    <span class="hljs-comment">//Do Some Thing</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-2-数组的越界"><a href="#2-3-2-数组的越界" class="headerlink" title="2.3.2 数组的越界"></a>2.3.2 数组的越界</h4><p>当输入为一个很大的负数时，输出结果就会出现一个比较奇怪的数据</p><h5 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h5><p>调试程序，分析异常数据，最后发现是在 <code>geDian</code> 函数中，<code>switch</code> 语句少考虑了一种情况，导致数组越界。</p><p>将 <code>geDian</code> 函数中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">switch</span> (num)<span class="hljs-comment">//迭代</span><br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:a = a; b = A[num + <span class="hljs-number">1</span>]; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> N:b = b; a = A[num - <span class="hljs-number">1</span>]; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:a = A[num - <span class="hljs-number">1</span>]; b = A[num + <span class="hljs-number">1</span>]; <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">switch</span> (num)<span class="hljs-comment">//迭代</span><br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:b = A[num + <span class="hljs-number">1</span>]; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> N:a = A[num - <span class="hljs-number">1</span>]; <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> N - <span class="hljs-number">1</span>:a = A[(num - <span class="hljs-number">1</span>)]; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:a = A[num - <span class="hljs-number">1</span>]; b = A[num + <span class="hljs-number">1</span>]; <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>成功解决问题</p><h3 id="2-4-结果分析"><a href="#2-4-结果分析" class="headerlink" title="2.4 结果分析"></a>2.4 结果分析</h3><p>给定函数：</p><script type="math/tex; mode=display">f(\alpha)=\alpha^2+2\alpha+1</script><p>其理论极小点为 $\alpha^*=-1$ </p><p>给定初值 $\alpha_0=999$ ，给定步长 $h=10$</p><p>结果：</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823205447.png" alt=""></p><p>所求极小点 $\alpha^*=-1.000000$ ，满足精度，通过验证</p><h2 id="3-求解多元函数的最优解"><a href="#3-求解多元函数的最优解" class="headerlink" title="3. 求解多元函数的最优解"></a>3. 求解多元函数的最优解</h2><p>实验日期：2018 年 11 月 22 日，2018 年 11 月 29 日</p><h3 id="3-1-实验目的"><a href="#3-1-实验目的" class="headerlink" title="3.1 实验目的"></a>3.1 实验目的</h3><ol><li>加深对多元函数无约束优化方法的基本理论和算法步骤的理解。</li><li>培养学生独立编制计算机程序的能力。</li><li>掌握常用多元函数无约束优化方法程序的使用方法。</li></ol><h3 id="3-2-上机内容"><a href="#3-2-上机内容" class="headerlink" title="3.2 上机内容"></a>3.2 上机内容</h3><h4 id="3-2-1-算法概述"><a href="#3-2-1-算法概述" class="headerlink" title="3.2.1 算法概述"></a>3.2.1 算法概述</h4><p>此处使用改进鲍威尔法进行求解。改进鲍威尔法用于求解多元函数函数极小点 $\alpha^*$ 。</p><p>其算法为：在每一轮迭代中总有个始点（第一轮的始点是任选的初始点）和 $n$ 个线性独立的搜索方向。从始点出发顺次沿 $n$ 个方向作一维搜索得一终点，由始点和终点决定了一个新的搜索方向。判断是否需要替换，若需要替换，用这个方向替换原来 $n$ 个方向中的一个，形成新的搜索方向组。这样就形成算法的循环。</p><p>替换的原则是去掉原方向组的第一个方向而将新方向排在原方向的最后。此外规定，从这一轮的搜索终点出发沿新的搜索方向作一维搜索而得到的极小点，作为下一轮迭代的始点。</p><h4 id="3-2-2-程序框图"><a href="#3-2-2-程序框图" class="headerlink" title="3.2.2 程序框图"></a>3.2.2 程序框图</h4><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823205507.png" alt="改进鲍威尔法"></p><h4 id="3-2-3-源程序"><a href="#3-2-3-源程序" class="headerlink" title="3.2.3 源程序"></a>3.2.3 源程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*************************************************</span><br><span class="hljs-comment">* @Author: Fu_Qingchen</span><br><span class="hljs-comment">* @Date: 2018-11-22</span><br><span class="hljs-comment">* @Description: 改进鲍威尔法无约束优化</span><br><span class="hljs-comment">*************************************************/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;math.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A00<span class="hljs-comment">//给定初值1</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A10<span class="hljs-comment">//给定初值2</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> V0.000001<span class="hljs-comment">//给定精度</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N2<span class="hljs-comment">//函数变量个数</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> H10<span class="hljs-comment">//格点法步长</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N_1d10<span class="hljs-comment">//格点法等分数-1</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> function_main(x1,x2) ((x1)*(x1)+2*(x2)*(x2)-4*(x1)-2*(x1)*(x2))<span class="hljs-comment">//要求解的函数</span></span><br><br><span class="hljs-comment">/*************************************************</span><br><span class="hljs-comment">* @Description: 进退法主函数</span><br><span class="hljs-comment">* @Input: a0:初始值,h:步长,*range:区间左右端点,*x:无约束问题的点，*S:搜索方向</span><br><span class="hljs-comment">* @Return: 区间左右端点</span><br><span class="hljs-comment">*************************************************/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">jintui</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a0, <span class="hljs-keyword">double</span> h, <span class="hljs-keyword">double</span> *range,<span class="hljs-keyword">double</span> *x,<span class="hljs-keyword">double</span> *S)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (function_main(*(x)+a0*S[<span class="hljs-number">0</span>],*(x+<span class="hljs-number">1</span>)+a0*S[<span class="hljs-number">1</span>]) == function_main(*(x)+(a0+h) * S[<span class="hljs-number">0</span>], *(x + <span class="hljs-number">1</span>) + (a0+h) * S[<span class="hljs-number">1</span>]))<br>&#123;<br>*(range) = a0;<br>*(range + <span class="hljs-number">1</span>) = a0 + h;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (function_main(*(x)+a0 * S[<span class="hljs-number">0</span>], *(x + <span class="hljs-number">1</span>) + a0 * S[<span class="hljs-number">1</span>]) &gt; function_main(*(x)+(a0 + h) * S[<span class="hljs-number">0</span>], *(x + <span class="hljs-number">1</span>) + (a0 + h) * S[<span class="hljs-number">1</span>]))<br>&#123;<br>*(range) = a0;<br><span class="hljs-keyword">do</span><br>&#123;<br>a0 += h;<br>&#125; <span class="hljs-keyword">while</span> (function_main(*(x)+a0 * S[<span class="hljs-number">0</span>], *(x + <span class="hljs-number">1</span>) + a0 * S[<span class="hljs-number">1</span>])&gt;function_main(*(x)+(a0 + h) * S[<span class="hljs-number">0</span>], *(x + <span class="hljs-number">1</span>) + (a0 + h) * S[<span class="hljs-number">1</span>]));<br>*(range + <span class="hljs-number">1</span>) = a0 + h;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>*(range + <span class="hljs-number">1</span>) = a0 + h;<br><span class="hljs-keyword">do</span><br>&#123;<br>a0 -= h;<br>&#125; <span class="hljs-keyword">while</span> (function_main(*(x)+a0 * S[<span class="hljs-number">0</span>], *(x + <span class="hljs-number">1</span>) + a0 * S[<span class="hljs-number">1</span>])&lt;function_main(*(x)+(a0 + h) * S[<span class="hljs-number">0</span>], *(x + <span class="hljs-number">1</span>) + (a0 + h) * S[<span class="hljs-number">1</span>]));<br>*(range) = a0 - h;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*************************************************</span><br><span class="hljs-comment">* @Description: 平分区间[a,b]为(n+1)等分</span><br><span class="hljs-comment">* @Input: a:区间左端点,b:区间右端点,A:等分点数组</span><br><span class="hljs-comment">* @Return: A[i]</span><br><span class="hljs-comment">*************************************************/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findA</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a, <span class="hljs-keyword">double</span> b, <span class="hljs-keyword">double</span> *A)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N_1d; i++)<br>&#123;<br>*(A + i) = (b - a) / (N_1d + <span class="hljs-number">1</span>)*(i + <span class="hljs-number">1</span>) + a;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*************************************************</span><br><span class="hljs-comment">* @Description: 求数组最小值序号</span><br><span class="hljs-comment">* @Input: A:数组</span><br><span class="hljs-comment">* @Return: 最小值序号</span><br><span class="hljs-comment">*************************************************/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(<span class="hljs-keyword">double</span> *A)</span> </span>&#123;<br><span class="hljs-keyword">double</span> tem = *(A + <span class="hljs-number">0</span>);<br><span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N_1d; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (tem &gt; *(A + i))<br>&#123;<br>num = i;<br>tem = *(A + i);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> num;<br>&#125;<br><br><span class="hljs-comment">/*************************************************</span><br><span class="hljs-comment">* @Description: 求数组最大值序号</span><br><span class="hljs-comment">* @Input: A:数组</span><br><span class="hljs-comment">* @Return: 最小值序号</span><br><span class="hljs-comment">*************************************************/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMax</span><span class="hljs-params">(<span class="hljs-keyword">double</span> *A)</span> </span>&#123;<br><span class="hljs-keyword">double</span> tem = *(A + <span class="hljs-number">0</span>);<br><span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (tem &lt; *(A + i))<br>&#123;<br>num = i;<br>tem = *(A + i);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> num;<br>&#125;<br><br><span class="hljs-comment">/*************************************************</span><br><span class="hljs-comment">* @Description: 格点法求解主要函数</span><br><span class="hljs-comment">* @Input: a:区间左端点,b:区间右端点,varepsilon:精度,*x:无约束问题的点，*S:搜索方向</span><br><span class="hljs-comment">* @Return: A[i]</span><br><span class="hljs-comment">*************************************************/</span><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">geDian</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a, <span class="hljs-keyword">double</span> b, <span class="hljs-keyword">double</span> varepsilon,<span class="hljs-keyword">double</span> *x, <span class="hljs-keyword">double</span> *S)</span> </span>&#123;<br><span class="hljs-keyword">int</span> num;<br><span class="hljs-keyword">double</span> A[N_1d], F[N_1d];<span class="hljs-comment">//A为等分的点，F为等分点的函数值</span><br><span class="hljs-keyword">do</span><br>&#123;<br>findA(a, b, A);<span class="hljs-comment">//得到等分点</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N_1d; i++)<span class="hljs-comment">//得到等分点对应函数值</span><br>&#123;<br>F[i] = function_main(*(x)+A[i] * S[<span class="hljs-number">0</span>], *(x + <span class="hljs-number">1</span>) + A[i] * S[<span class="hljs-number">1</span>]);<br>&#125;<br>num = findMin(F);<br><span class="hljs-keyword">switch</span> (num)<span class="hljs-comment">//迭代</span><br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:b = A[(num + <span class="hljs-number">1</span>)]; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> N_1d:a = A[(num - <span class="hljs-number">1</span>)]; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> N_1d - <span class="hljs-number">1</span>:a = A[(num - <span class="hljs-number">1</span>)]; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:a = A[(num - <span class="hljs-number">1</span>)]; b = A[(num + <span class="hljs-number">1</span>)]; <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">while</span> (b - a &gt; <span class="hljs-number">0</span> ? ((b - a) &gt; varepsilon) : ((a - b) &gt; varepsilon));<br><span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> / <span class="hljs-number">2</span> * (a + b);<br>&#125;<br><br><span class="hljs-comment">/*************************************************</span><br><span class="hljs-comment">* @Description: 鲍威尔法求解主要函数</span><br><span class="hljs-comment">* @Input: *a0:初始点,varepsilon：精度</span><br><span class="hljs-comment">* @Return: *a0极小点</span><br><span class="hljs-comment">*************************************************/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">powell</span><span class="hljs-params">(<span class="hljs-keyword">double</span> *a0, <span class="hljs-keyword">double</span> varepsilon)</span> </span>&#123;<br><span class="hljs-comment">//设置初值</span><br><span class="hljs-keyword">double</span> S[N+<span class="hljs-number">1</span>][N+<span class="hljs-number">1</span>] = &#123; <span class="hljs-number">0</span> &#125;;<span class="hljs-comment">//前进方向</span><br><span class="hljs-keyword">double</span> S_new[N+<span class="hljs-number">1</span>] = &#123; <span class="hljs-number">0</span> &#125;,sn1 = <span class="hljs-number">0</span>,sn2 = <span class="hljs-number">0</span>;<span class="hljs-comment">//构造的新方向</span><br><span class="hljs-keyword">double</span> f[N + <span class="hljs-number">1</span>] = &#123; <span class="hljs-number">0</span> &#125;;<span class="hljs-comment">//迭代中的极小点</span><br><span class="hljs-keyword">double</span> size[N] = &#123; <span class="hljs-number">0</span> &#125;;<span class="hljs-comment">//步长</span><br><span class="hljs-keyword">double</span> delta[N] = &#123; <span class="hljs-number">0</span> &#125;;<span class="hljs-comment">//每前进一步的下降量</span><br><span class="hljs-keyword">int</span> delta_max = <span class="hljs-number">0</span>;<span class="hljs-comment">//最大下降量对应序号</span><br><span class="hljs-keyword">double</span> a00[N] = &#123; <span class="hljs-number">0</span> &#125;;<span class="hljs-comment">//初始点</span><br><span class="hljs-keyword">double</span> a000[N] = &#123; <span class="hljs-number">0</span> &#125;;<span class="hljs-comment">//反射点</span><br><span class="hljs-keyword">double</span> f1 = <span class="hljs-number">0</span>, f2 = <span class="hljs-number">0</span>, f3 = <span class="hljs-number">0</span>;<span class="hljs-comment">//方向有效性中的f1,f2,f3</span><br><span class="hljs-keyword">double</span> h = H, range[<span class="hljs-number">2</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">0</span> &#125;;<span class="hljs-comment">//一维搜索相关参数</span><br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>&#123;<br>S[i][i] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">do</span><br>&#123;<br>k++;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, k);<br>f[<span class="hljs-number">0</span>] = function_main(*(a0), *(a0 + <span class="hljs-number">1</span>));<br>a00[<span class="hljs-number">0</span>] = *(a0);<br>a00[<span class="hljs-number">1</span>] = *(a0 + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++)<span class="hljs-comment">//一维搜索</span><br>&#123;<br>jintui(a0[i], h, range, a0, S[i]);<br>size[i] = geDian(range[<span class="hljs-number">0</span>], range[<span class="hljs-number">1</span>], varepsilon, a0, S[i]);<span class="hljs-comment">//获取最优步长</span><br>*(a0 + <span class="hljs-number">0</span>) = *(a0 + <span class="hljs-number">0</span>) + size[i] * S[i][<span class="hljs-number">0</span>];<span class="hljs-comment">//获取极值点</span><br>*(a0 + <span class="hljs-number">1</span>) = *(a0 + <span class="hljs-number">1</span>) + size[i] * S[i][<span class="hljs-number">1</span>];<br>f[i + <span class="hljs-number">1</span>] = function_main(*(a0), *(a0 + <span class="hljs-number">1</span>));<span class="hljs-comment">//获取极值点函数值</span><br>delta[i] = f[i] - f[i + <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">pow</span>(*(a0)-a00[<span class="hljs-number">0</span>], <span class="hljs-number">2</span>) + <span class="hljs-built_in">pow</span>(*(a0+<span class="hljs-number">1</span>)-a00[<span class="hljs-number">1</span>], <span class="hljs-number">2</span>))&lt;varepsilon)<span class="hljs-comment">//收敛判断</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>delta_max = findMax(delta);<span class="hljs-comment">//找到最大下降值</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>&#123;<br>S_new[i] = *(a0 + i) - a00[i];<span class="hljs-comment">//构造新方向</span><br>a000[i] = <span class="hljs-number">2</span> * (*(a0 + i)) - a00[i];<br>&#125;<br>sn1 = S_new[<span class="hljs-number">0</span>];<br>sn2 = S_new[<span class="hljs-number">1</span>];<br>f1 = f[<span class="hljs-number">0</span>], f2 = f[N], f3 = function_main(a000[<span class="hljs-number">0</span>], a000[<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">if</span> (f3&lt;f1 &amp;&amp; ((f1 - <span class="hljs-number">2</span> * f2 + f3)*<span class="hljs-built_in">pow</span>(f1 - f2 - delta[delta_max], <span class="hljs-number">2</span>)&lt;<span class="hljs-number">0.5</span>*delta[delta_max] * <span class="hljs-built_in">pow</span>(f1 - f3, <span class="hljs-number">2</span>)))<span class="hljs-comment">//方向有效</span><br>&#123;<br>jintui(a0[<span class="hljs-number">0</span>], h, range, a00, S_new);<br>size[<span class="hljs-number">0</span>] = geDian(range[<span class="hljs-number">0</span>], range[<span class="hljs-number">1</span>], varepsilon, a00, S_new);<span class="hljs-comment">//获取最优步长</span><br>*(a0 + <span class="hljs-number">0</span>) = *(a00 + <span class="hljs-number">0</span>) + size[<span class="hljs-number">0</span>] * S_new[<span class="hljs-number">0</span>];<span class="hljs-comment">//获取极值点</span><br>*(a0 + <span class="hljs-number">1</span>) = *(a00 + <span class="hljs-number">1</span>) + size[<span class="hljs-number">0</span>] * S_new[<span class="hljs-number">1</span>];<br>f[<span class="hljs-number">0</span>] = function_main(*(a0), *(a0 + <span class="hljs-number">1</span>));<span class="hljs-comment">//获取极值点函数值</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (i&gt;=delta_max)<br>&#123;<br><span class="hljs-keyword">for</span> ( j = <span class="hljs-number">0</span>; j &lt; N; j++)<br>&#123;<br>S[i - <span class="hljs-number">1</span>][j] = S[i][j];<br>&#125;<br>&#125;<br>&#125;<br>S[N - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = sn1;<br>S[N - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = sn2;<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//方向无效</span><br>&#123;<br><span class="hljs-keyword">if</span> (f3&lt;f2)<br>&#123;<br>*(a0 + <span class="hljs-number">0</span>) = a000[<span class="hljs-number">0</span>];<span class="hljs-comment">//获取新初值</span><br>*(a0 + <span class="hljs-number">1</span>) = a000[<span class="hljs-number">1</span>];<br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">double</span> a0[N], varepsilon = V;<br>a0[<span class="hljs-number">0</span>] = A0;<br>a0[<span class="hljs-number">1</span>] = A1;<br>powell(a0, varepsilon);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x1:%lf\nx2:%lf\n&quot;</span>, a0[<span class="hljs-number">0</span>], a0[<span class="hljs-number">1</span>]);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-过程分析"><a href="#3-3-过程分析" class="headerlink" title="3.3 过程分析"></a>3.3 过程分析</h3><p>遇到的问题</p><h4 id="3-3-1-参数的传递"><a href="#3-3-1-参数的传递" class="headerlink" title="3.3.1 参数的传递"></a>3.3.1 参数的传递</h4><p>在改进鲍威尔法中进行方向替换时，发现有一处一直替换不了</p><p>调试程序：<code>powell</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf;%lf\n&quot;</span>,S_new[<span class="hljs-number">0</span>],S_new[<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (i&gt;=delta_max)<br>&#123;<br><span class="hljs-keyword">for</span> ( j = <span class="hljs-number">0</span>; j &lt; N; j++)<br>&#123;<br>S[i - <span class="hljs-number">1</span>][j] = S[i][j];<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf;%lf\n&quot;</span>,S_new[<span class="hljs-number">0</span>],S_new[<span class="hljs-number">1</span>]);<br>S[N - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = S_new[<span class="hljs-number">0</span>];<br>S[N - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = S_new[<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>发现两次输出不一样</p><h5 id="解决方法-3"><a href="#解决方法-3" class="headerlink" title="解决方法"></a>解决方法</h5><p>引入变量 <code>sn1</code> 和  <code>sn2</code> 通过它们来传递新方向</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">double</span> sn1 = <span class="hljs-number">0</span>,sn2 = <span class="hljs-number">0</span>;<span class="hljs-comment">//引入的新方向</span><br>...<br>sn1 = S_new[<span class="hljs-number">0</span>];<br>sn2 = S_new[<span class="hljs-number">1</span>];<br>...<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (i&gt;=delta_max)<br>&#123;<br><span class="hljs-keyword">for</span> ( j = <span class="hljs-number">0</span>; j &lt; N; j++)<br>&#123;<br>S[i - <span class="hljs-number">1</span>][j] = S[i][j];<br>&#125;<br>&#125;<br>&#125;<br>S[N - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = sn1;<br>S[N - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = sn2;<br></code></pre></td></tr></table></figure><h4 id="3-3-2-原来代码的调用"><a href="#3-3-2-原来代码的调用" class="headerlink" title="3.3.2 原来代码的调用"></a>3.3.2 原来代码的调用</h4><p>通过一维搜索求步长时，发现一维搜索的函数总是改变的，因此无法直接套用之前的一维搜索方法</p><h5 id="解决方法-4"><a href="#解决方法-4" class="headerlink" title="解决方法"></a>解决方法</h5><ul><li>宏定义函数，这样就可以带表达式计算了</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> function_main(x1,x2) ((x1)*(x1)+2*(x2)*(x2)-4*(x1)-2*(x1)*(x2))<span class="hljs-comment">//要求解的函数</span></span><br></code></pre></td></tr></table></figure><ul><li>更改之前的代码</li></ul><p>以 <code>geDian</code> 函数为例，将其中的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">F[i] = function(A[i]);<br></code></pre></td></tr></table></figure><p>改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">F[i] = function_main(*(x)+A[i] * S[<span class="hljs-number">0</span>], *(x + <span class="hljs-number">1</span>) + A[i] * S[<span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><p>成功解决问题</p><h4 id="3-3-3-数组的越界"><a href="#3-3-3-数组的越界" class="headerlink" title="3.3.3 数组的越界"></a>3.3.3 数组的越界</h4><p>输出结果时，一开始总是提示堆栈溢出的错误，但是无视这个错误之后能够输出正确的结果</p><h5 id="解决方法-5"><a href="#解决方法-5" class="headerlink" title="解决方法"></a>解决方法</h5><p>根据报错信息， <code>powell</code> 函数中为数组越界问题</p><p>将 <code>powell</code> 函数中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">double</span> S[N][N] = &#123; <span class="hljs-number">0</span> &#125;;<span class="hljs-comment">//前进方向</span><br><span class="hljs-keyword">double</span> S_new[N] = &#123; <span class="hljs-number">0</span> &#125;,sn1 = <span class="hljs-number">0</span>,sn2 = <span class="hljs-number">0</span>;<span class="hljs-comment">//构造的新方向</span><br></code></pre></td></tr></table></figure><p>改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">double</span> S[N+<span class="hljs-number">1</span>][N+<span class="hljs-number">1</span>] = &#123; <span class="hljs-number">0</span> &#125;;<span class="hljs-comment">//前进方向</span><br><span class="hljs-keyword">double</span> S_new[N+<span class="hljs-number">1</span>] = &#123; <span class="hljs-number">0</span> &#125;,sn1 = <span class="hljs-number">0</span>,sn2 = <span class="hljs-number">0</span>;<span class="hljs-comment">//构造的新方向</span><br></code></pre></td></tr></table></figure><p>成功解决问题</p><h3 id="3-4-结果分析"><a href="#3-4-结果分析" class="headerlink" title="3.4 结果分析"></a>3.4 结果分析</h3><p>给定函数：</p><script type="math/tex; mode=display">f(x_1,x_2)=x_1^2+2x_2^2-4x_1-2x_1x_2</script><p>其理论极小点为 $\left[<br>\begin{matrix}<br>x_0^❀\\<br>x_1^❀\\<br>\end{matrix}<br>\right]=\left[<br>\begin{matrix}<br>4\\<br>2\\<br>\end{matrix}<br>\right]$ </p><p>给定初值 $\left[<br>\begin{matrix}<br>x_0\\<br>x_1\\<br>\end{matrix}<br>\right]=\left[<br>\begin{matrix}<br>0\\<br>0\\<br>\end{matrix}<br>\right]$ </p><p>结果：</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823205548.png" alt=""></p><p>所求极小点 $\left[<br>\begin{matrix}<br>x_0^❀\\<br>x_1^❀\\<br>\end{matrix}<br>\right]=\left[<br>\begin{matrix}<br>4.000000\\<br>2.000000\\<br>\end{matrix}<br>\right]$ ，满足精度，通过验证</p><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【最优化技术】笔记_Page_03.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【最优化技术】笔记_Page_04.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【最优化技术】笔记_Page_05.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【最优化技术】笔记_Page_06.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【最优化技术】笔记_Page_07.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【最优化技术】笔记_Page_08.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【最优化技术】笔记_Page_09.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【最优化技术】笔记_Page_10.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【最优化技术】笔记_Page_11.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【最优化技术】笔记_Page_12.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【最优化技术】笔记_Page_13.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823210809.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823210907.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【最优化技术】笔记_Page_16.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【最优化技术】笔记_Page_17.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【最优化技术】笔记_Page_18.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823211048.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【最优化技术】笔记_Page_21.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【最优化技术】笔记_Page_22.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823211224.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【最优化技术】笔记_Page_27.png" alt=""></p><hr><p>Learning By Sharing，2018©Fu_Qingchen，Markdown，$\LaTeX$</p>]]></content>
    
    
    <categories>
      
      <category>自动化相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最优化</tag>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>控制工程基础笔记</title>
    <link href="/2018/12/20/WHUT/MechanicalControlEngineering/"/>
    <url>/2018/12/20/WHUT/MechanicalControlEngineering/</url>
    
    <content type="html"><![CDATA[<p>这本课程比较考验数学，里面涉及到大量复变函数的概念和应用。</p><span id="more"></span><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823215355.png" alt=""></p><h1 id="Introduction-绪论"><a href="#Introduction-绪论" class="headerlink" title="Introduction //绪论"></a>Introduction //绪论</h1><ul><li><p>机械控制工程实质：研究机械工程技术广义系统中的动力学问题</p></li><li><p>系统的性能不仅与系统的元素有关，还与系统的结构有关</p></li><li>系统往往在时域、频域或空域等域内表现出动态特性</li><li>对机械系统，系统的输入与输出分别称为 “激励” 和 “相应”</li><li>开环系统：没反馈回路的系统<ul><li>特点：结构简单，成本低</li></ul></li><li>闭环系统：有反馈回路的系统</li><li>对控制系统的基本要求：快、准、<strong>稳</strong></li></ul><h1 id="Mathematical-models-数学模型"><a href="#Mathematical-models-数学模型" class="headerlink" title="Mathematical models //数学模型"></a>Mathematical models //数学模型</h1><h2 id="Laplace-Transform"><a href="#Laplace-Transform" class="headerlink" title="Laplace Transform"></a>Laplace Transform</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition:"></a>Definition:</h3><script type="math/tex; mode=display">L(f(t))=F(s)=\int_0^\infty f(t)e^{-st}dt</script><h3 id="Typically-Laplace-Transform"><a href="#Typically-Laplace-Transform" class="headerlink" title="Typically Laplace Transform"></a>Typically Laplace Transform</h3><script type="math/tex; mode=display">L(1)=\frac1s</script><blockquote><p>unit impulse //单位阶跃</p></blockquote><script type="math/tex; mode=display">L(t)=\frac1{s^2}</script><blockquote><p>unit step//单位斜坡</p></blockquote><script type="math/tex; mode=display">L(e^{at})=\frac1{s-a}</script><script type="math/tex; mode=display">L(\sin\omega t)=\frac\omega{s^2+\omega^2}</script><script type="math/tex; mode=display">L(\cos\omega t)=\frac s{s^2+\omega^2}</script><script type="math/tex; mode=display">L(t^n)=\frac{n!}{t^{n+1}}</script><script type="math/tex; mode=display">L(\lim\limits_{\varepsilon\rightarrow0}\frac1\varepsilon)=1</script><blockquote><p>unit impulse //单位脉冲</p></blockquote><h3 id="Properties-of-Laplace-Transform-拉普拉斯变换的性质"><a href="#Properties-of-Laplace-Transform-拉普拉斯变换的性质" class="headerlink" title="Properties of Laplace Transform //拉普拉斯变换的性质"></a>Properties of Laplace Transform //拉普拉斯变换的性质</h3><p>Under the Zero state response:</p><script type="math/tex; mode=display">L[a_1f_1(x)+a_2f_2(x)]=a_1F_1(s)+a_2F_2(s)</script><script type="math/tex; mode=display">L[f(t-a)]=e^{-as}F(s)</script><script type="math/tex; mode=display">L[f^{(n)}(x)]=s^nF(s)</script><script type="math/tex; mode=display">L[\int f(x)dx^n]=\frac1{s^n}F(s)</script><script type="math/tex; mode=display">\lim\limits_{t\rightarrow0}f(t)=\lim\limits _{s\rightarrow\infty}sF(s)</script><script type="math/tex; mode=display">\lim\limits_{t\rightarrow\infty}f(t)=\lim\limits _{s\rightarrow0}sF(s)</script><p>应该就这些了。。。</p><blockquote><p>Laplace变换的起源：</p></blockquote><iframe id=sbrxp src="//player.bilibili.com/player.html?aid=8970989&bvid=BV1Xx411k7FE&cid=204595985&page=2" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width: 720px; height: 430px; max-width: 100%"> </iframe><h2 id="Mathmatical-Model"><a href="#Mathmatical-Model" class="headerlink" title="Mathmatical Model"></a>Mathmatical Model</h2><ul><li>微分方程是在<strong>时域</strong>中描述系统动态特性的数学模型</li><li>传递函数是在<strong>复域</strong>中描述系统动态特性的数学模型</li><li>线性定常系统：$\ddot x_o(t)+3\dot x_o(t)+x_o(t)=4\dot x_i(t)+5x_i(t)$ </li><li>线性时变系统：$\ddot x_o(t)+3t\dot x_o(t)+x_o(t)=4\dot x_i(t)+5x_i(t)$</li><li>非线性系统：$\ddot x_o(t)+3x_o\dot x_o(t)+x_o(t)=4\dot x_i(t)+5x_i(t)$  </li></ul><h3 id="典型元件微分方程"><a href="#典型元件微分方程" class="headerlink" title="典型元件微分方程"></a>典型元件微分方程</h3><h4 id="机械系统"><a href="#机械系统" class="headerlink" title="机械系统"></a>机械系统</h4><ul><li>质量元件：$f=m\ddot x,T=J\ddot\theta$</li><li>弹性元件：$f=kx,T=k\theta$</li><li>阻尼元件：$f=c\dot x,T=c\dot\theta$</li></ul><h4 id="电网系统"><a href="#电网系统" class="headerlink" title="电网系统"></a>电网系统</h4><ul><li>电容：$u=\frac1C\int idt$</li><li>电感：$u=L\frac{di}{dt}$</li><li>电阻：$u=Ri$</li></ul><h2 id="Transfer-Function"><a href="#Transfer-Function" class="headerlink" title="Transfer Function"></a>Transfer Function</h2><ul><li><p>零初始条件</p></li><li><p>线性定常系统</p></li><li>系统输出的Laplace变换与系统输入的Laplace变换之比</li></ul><p>For a general n^{th}-order linear ,time invariant differential equation:</p><script type="math/tex; mode=display">a_n\frac{d^nx_o(t)}{dt^n}+a_{n-1}\frac{d^{n-1}x_o(t)}{dt^{n-1}}+...+a_0x_o=b_m\frac{d^mx_i(t)}{dt^m}+b_{m-1}\frac{d^{m-1}x_i(t)}{dt^{m-1}}+...+b_0x_i</script><p>The Transfer Function is</p><script type="math/tex; mode=display">G(s)=\frac{b_ms^m+b_{m-1}s^{m-1}+...+b_0}{a_ns^n+a_{n-1}s^{n-1}+...+a_0}\\X_o(s)=G(s)X_i(s)</script><ul><li>传递函数的分母与外界无关，分子反映与外界的关系</li><li>相似系统传递函数相同</li></ul><p>传递函数的零极点模型</p><script type="math/tex; mode=display">G(s)=\frac{K(s-z_1)(s-z_2)...(s-z_3)}{(s-p_1)(s-p_2)...(s-p_3)}</script><ul><li><p>$z_1,z_2…$ : 零点；$p_1,p_2$: 极点；$K$: 开环增益</p></li><li><p>系统的零点、极点对系统动态性能有影响，其中：零点影响系统的瞬态性能，极点影响系统的稳态性能</p></li></ul><blockquote><p>对系统的研究可以转化为对零点、极点、开环增益的研究</p></blockquote><h3 id="典型环节传递函数"><a href="#典型环节传递函数" class="headerlink" title="典型环节传递函数"></a>典型环节传递函数</h3><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823215412.png" alt=""></p><blockquote><p>这个图是为了解释下面那个表的</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">传递函数</th><th style="text-align:center">特点</th></tr></thead><tbody><tr><td style="text-align:center">比例环节</td><td style="text-align:center">$k$</td><td style="text-align:center">不失真、不延迟</td></tr><tr><td style="text-align:center">惯性环节</td><td style="text-align:center">$1/(Ts+1)$</td><td style="text-align:center">输出不能立即到达稳态</td></tr><tr><td style="text-align:center">微分环节</td><td style="text-align:center">$s$</td><td style="text-align:center">反映输出的变化趋势</td></tr><tr><td style="text-align:center">积分环节</td><td style="text-align:center">$1/s$</td><td style="text-align:center">输出的累加效应</td></tr><tr><td style="text-align:center">延时环节</td><td style="text-align:center">$e^{-τs}$</td><td style="text-align:center">输出滞后</td></tr><tr><td style="text-align:center">振荡环节</td><td style="text-align:center">${w_n^2}/({s^2+2\xi w_ns+w_n^2})$</td><td style="text-align:center">$0&lt;\xi&lt;1$ 震荡</td></tr></tbody></table></div><h3 id="对振荡环节"><a href="#对振荡环节" class="headerlink" title="对振荡环节"></a>对振荡环节</h3><p>传递函数</p><script type="math/tex; mode=display">\frac{\omega_n^2}{s^2+2\xi\omega_n s+\omega_n^2}</script><p>或</p><script type="math/tex; mode=display">\frac1{T^2s^2+2\xi Ts+1}</script><p>其中：$\xi$ 为阻尼比，$\omega_n$ 为无阻尼固有频率， $\omega_n=1/T$ </p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823215424.png" alt=""></p><p>当 $0&lt;\xi<1$ 时输出存在震荡，$\xi$ 越小，震荡越剧烈；$\xi>1$ 时，无震荡</p><h2 id="Block-Diagram-Models-方框图模型"><a href="#Block-Diagram-Models-方框图模型" class="headerlink" title="Block Diagram Models //方框图模型"></a>Block Diagram Models //方框图模型</h2><h3 id="Equivalent-Diagram-等效图"><a href="#Equivalent-Diagram-等效图" class="headerlink" title="Equivalent Diagram//等效图"></a>Equivalent Diagram//等效图</h3><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823215437.png" alt=""></p><blockquote><p>方框图变化的要点就是变化前后传递函数不改变</p></blockquote><h3 id="Discussion-on-Feedback-Control-System"><a href="#Discussion-on-Feedback-Control-System" class="headerlink" title="Discussion on Feedback Control System"></a>Discussion on Feedback Control System</h3><p>Feedback Control System is at Equivalent Diagram Picture No.3</p><ul><li>Open loop transfer function $G_k=G_1G_2$ //开环传递函数</li><li>Feed forward transfer function $G=G_1$ //前向通道传递函数</li><li>Close loop transfer function ${G_1}/({1\mp G_1G_2})$ //闭环传递函数</li></ul><h3 id="※梅勋公式-梅森增益公式"><a href="#※梅勋公式-梅森增益公式" class="headerlink" title="※梅勋公式(梅森增益公式)"></a>※梅勋公式(梅森增益公式)</h3><ul><li>只有一条前向通道</li><li>各反馈回路包含公共传递函数方框</li></ul><script type="math/tex; mode=display">G=\frac{\prod G_{FeedForward}}{1\pm\sum[G_{OpenLoop}]}</script><h1 id="Time-domain-analysis-时间响应分析"><a href="#Time-domain-analysis-时间响应分析" class="headerlink" title="Time-domain analysis //时间响应分析"></a>Time-domain analysis //时间响应分析</h1><p>时间响应主要研究系统是 <strong>瞬态性能</strong></p><h2 id="时间响应及其组成"><a href="#时间响应及其组成" class="headerlink" title="时间响应及其组成"></a>时间响应及其组成</h2><p>时间响应：在输入作用下，输出在时域的表现形式，在数学上就是系统动力学方程的解。</p><p>对于一般的方程，这个解是</p><script type="math/tex; mode=display">y(t)=\sum\limits_{i=1}^nA_{1i}e^{s_it}+\sum\limits_{i=1}^nA_{2i}e^{s_it}+B(t)</script><p>$s_i$ 为微分方程特征根。</p><ul><li><p>当特征根都位于复平面的左半平面时，系统自由响应收敛于0，此时，<strong>系统稳定</strong> </p><blockquote><p>此时的自由响应项称为 <strong>瞬态响应</strong>，强迫响应项称为 <strong>稳态响应</strong></p></blockquote></li><li><p>若存在特征根有一个位于右半平面，系统自由响应发散</p></li><li>若存在特征根有一个位于虚轴上，系统自由项等幅振荡</li></ul><blockquote><p>对于非齐次微分方程 $y’+P(x)y=Q(x)$，其解的结构为：非齐次微分方程 = 齐次的通解 + 非齐次的特解，$y=Ce^{-\int P(x)dx}+e^{-\int P(x)dx}\int Q(x)e^{\int P(x)dx}dx$，刚好与上面的对应</p></blockquote><ul><li>第一项为<strong>零输入响应</strong>，后面那两项是<strong>零状态响应</strong></li><li>前两项为<strong>自由响应项</strong>，后一项为<strong>强迫响应项</strong></li><li>系统阶次 $n$ 和方程特征根 $s_i$ 只与系统有关，与输入无关</li><li>对于线性系统，若由输入为 $x(t)$ 引起的输出 $y(t)$ ，则由输入为 $x’(t)$ 引起的输出 $y’(t)$ </li></ul><h2 id="一阶系统的时间响应"><a href="#一阶系统的时间响应" class="headerlink" title="一阶系统的时间响应"></a>一阶系统的时间响应</h2><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823215451.png" alt=""></p><p>对 $G(s)={1}/{(Ts+1)}$ 来说</p><h3 id="单位脉冲响应"><a href="#单位脉冲响应" class="headerlink" title="单位脉冲响应"></a>单位脉冲响应</h3><script type="math/tex; mode=display">x_i(t)=\lim\limits_{\varepsilon\rightarrow0}\frac 1\varepsilon\Rightarrow X_i(s)=1\\X_o(s)=X_i(s)G(s)=\frac 1 {Ts+1}\\x_o(t)=L^{-1}(\frac 1T\frac1{s+\frac1T})=\frac 1Te^{-\frac tT}</script><h3 id="单位阶跃响应"><a href="#单位阶跃响应" class="headerlink" title="单位阶跃响应"></a>单位阶跃响应</h3><script type="math/tex; mode=display">x_i(t)=1\Rightarrow X_i(s)=\frac 1s\\X_o(s)=X_i(s)G(s)=\frac 1 {s}\frac 1 {Ts+1}\\x_o(t)=L^{-1}(\frac 1s-\frac T{Ts+1})=1-e^{-\frac tT}</script><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><p>$t_s$<strong>调整时间</strong> </p><p>一阶系统在阶跃输入下达到稳态的 $(1-\Delta)$ 时所用的时间 （ $\Delta$ 为容许误差）</p><script type="math/tex; mode=display">\Delta =2\%,t_s=4T,\Delta=5\%,t_s=3T</script><p>$t_s$ 反应系统的快速性，T越大，调整时间越大，响应速度越慢</p><h2 id="二阶系统的时间响应"><a href="#二阶系统的时间响应" class="headerlink" title="二阶系统的时间响应"></a>二阶系统的时间响应</h2><p>对 $G(s)=\frac{\omega_n^2}{s^2+2\xi\omega_n s+\omega_n^2}$ 来说：</p><p>特征方程：${s^2+2\xi\omega_n s+\omega_n^2}$ </p><p>特征根：$s=\xi\omega_n\pm\omega_n\sqrt{1-\xi^2}$ </p><ul><li>$\omega_n$ 为无阻尼固有频率，令 $\omega_d=\omega_n\sqrt{1-\xi^2}$ ，称为有阻尼固有频率</li><li>$\xi=0$ ，系统为无阻尼系统，等幅振荡</li><li>$0&lt;\xi&lt;1$ ，系统为欠阻尼系统，震荡收敛</li><li>$\xi=1$，系统为临界阻尼系统，不震荡收敛</li><li>$\xi&gt;1$ ，系统为过阻尼系统，不震荡收敛</li></ul><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823215505.png" alt=""></p><h3 id="性能指标-1"><a href="#性能指标-1" class="headerlink" title="性能指标"></a>性能指标</h3><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823215520.png" alt=""></p><ul><li>上升时间 ：系统第一次到达稳态的时间</li></ul><script type="math/tex; mode=display">t_r=\frac{\pi-\arctan\frac{\sqrt{1-\xi^2}}{\xi}}{\omega_d}</script><ul><li>峰值时间：系统第一次到达峰值的时间</li></ul><script type="math/tex; mode=display">t_p=\frac{\pi}{\omega_d}</script><ul><li>最大超调量：(峰值 - 稳态)/峰值</li></ul><script type="math/tex; mode=display">M_p=\frac{x_o(t_p)-x_o(\infty)}{x_o(\infty)}=e^{-\frac{\xi\pi}{\sqrt{1-\xi^2}}}</script><ul><li>调整时间，当 $0&lt;\xi&lt;0.7$ 时</li></ul><script type="math/tex; mode=display">t_s\approx\frac{4}{\xi\omega_n}(\Delta=2\%),t_s\approx\frac{3}{\xi\omega_n}(\Delta=5\%)</script><blockquote><ul><li>$\xi$  主要与震荡性（稳定性）正相关，$\omega_n$ 主要与快速性正相关。</li><li>系统的响应速度往往与震荡性能之间是矛盾的</li><li>$\omega_d=\omega_n\sqrt{1-\xi^2}$ </li></ul></blockquote><h2 id="高阶系统时间响应"><a href="#高阶系统时间响应" class="headerlink" title="高阶系统时间响应"></a>高阶系统时间响应</h2><p>分析高阶系统时间响应的主要思路是把它近似成低阶的叠加，其系统响应特性主要由 <strong>主导极点</strong> 决定</p><p><strong>主导极点</strong> ：系统离虚轴最近的极点，其实部小于其他实部的 1/5 ，且附近不存在极点</p><h2 id="系统偏差"><a href="#系统偏差" class="headerlink" title="系统偏差"></a>系统偏差</h2><p>在闭环传递系统中：</p><script type="math/tex; mode=display">e_{ss}(t)=\lim\limits_{t\rightarrow\infty}e(t)=\lim\limits_{t\rightarrow0}sE(s)=\lim\limits_{t\rightarrow0}s\frac{1}{1+G(s)H(s)}X_i(s)</script><p>​    其中，当 $G(s)$ 为前向通道传递函数， $H(s)$ 为反馈回路传递函数时，$E(s)=G(s)$</p><ul><li>单位阶跃输入</li></ul><script type="math/tex; mode=display">e_{ss}(t)=\lim\limits_{t\rightarrow0}\frac1{1+G(s)H(s)}=\frac1{1+K_p}</script><p>​    $K_p=G(s)H(s)$ ：位置无偏系数</p><ul><li>单位斜坡输入</li></ul><script type="math/tex; mode=display">e_{ss}(t)=\lim\limits_{t\rightarrow0}\frac1{sG(s)H(s)}=\frac1{K_v}</script><p>​    $K_v=sG(s)H(s)$ ：速度无偏系数</p><ul><li>单位加速度输入</li></ul><script type="math/tex; mode=display">e_{ss}(t)=\lim\limits_{t\rightarrow0}\frac1{s^2G(s)H(s)}=\frac1{K_a}</script><p>​    $K_a=s^2G(s)H(s)$ ：加速度无偏系数</p><p>对一般的系统：</p><script type="math/tex; mode=display">G(s)H(s)=\frac{K\prod(T_is+1)}{s^v\prod(T_js+1)}</script><p>​    $v$：系统阶数</p><blockquote><p>设计系统时最好不要超过两阶</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">输入</th><th style="text-align:center">0阶</th><th style="text-align:center">1阶</th><th style="text-align:center">2阶</th></tr></thead><tbody><tr><td style="text-align:center">单位阶跃</td><td style="text-align:center">1/(1+Kp)</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">单位斜坡</td><td style="text-align:center">∞</td><td style="text-align:center">1/Kv</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">单位加速度</td><td style="text-align:center">∞</td><td style="text-align:center">∞</td><td style="text-align:center">1/Ka</td></tr></tbody></table></div><ul><li>型次越高，稳态误差越小</li><li>开环增益越大，稳态误差越小</li></ul><h1 id="Frequency-Domain-Anaysis-频率特性分析"><a href="#Frequency-Domain-Anaysis-频率特性分析" class="headerlink" title="Frequency Domain Anaysis //频率特性分析"></a>Frequency Domain Anaysis //频率特性分析</h1><p>频率特性是频域中描述系统动态特性的数学模型，是单位脉冲函数下的傅里叶变换</p><ul><li>时间响应：系统在阶跃或脉冲下的瞬态响应</li><li>频域分析：系统在谐波输入下的稳态响应</li></ul><p>系统在谐波下的稳态输出为</p><script type="math/tex; mode=display">x_o(t)=|G(j\omega)|X_isin[\omega t+\angle G(j\omega)]</script><ul><li>幅频特性：$A(\omega)=|G(j\omega)|$ </li><li>相频特性：$\varphi(\omega)=\angle G(j\omega)$ </li></ul><h2 id="Nyquist图"><a href="#Nyquist图" class="headerlink" title="Nyquist图"></a>Nyquist图</h2><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823215536.png" alt=""></p><p>其中，对 </p><script type="math/tex; mode=display">G_1(s)=\frac{T_1s+1}{T_2s+1}\\G_2(s)=-\frac{T_1s+1}{T_2s+1}</script><p>有简便计算方法</p><script type="math/tex; mode=display">|G_1(j\omega)|=|G_2(j\omega)|=\frac{\sqrt{1+T_1^2\omega^2}}{\sqrt{1+T_2^2\omega^2}}\\\angle G_1(j\omega)=\arctan T_1\omega-\arctan T_2\omega\\\angle G_2(j\omega)=\pi+\arctan T_1\omega-\arctan T_2\omega\\</script><p>对振荡环节：</p><ul><li>当 $0&lt;\xi&lt;0.707$ 时，$|G(j\omega)|$ 在 $w_r=\omega_n\sqrt{1-2\xi}$ 处取得峰值</li><li><p>当 $\xi&gt;0.707$ 时，不出现峰值</p></li><li><p>谐振频率：$\omega_r=w_n\sqrt{1-2\xi^2}$ </p></li></ul><h2 id="Bode图"><a href="#Bode图" class="headerlink" title="Bode图"></a>Bode图</h2><ol><li>$G(s)$ 化成标准型，计算 $G(j\omega)$ </li><li>计算转角频率，并有小到大表在对数坐标轴上</li><li>过点 $(1,20\lg K)$ 作斜率为 $-20v$ 的直线</li><li>延长该直线，每遇到一个转角频率就改变一次斜率，其原则是：<ul><li>一阶微分环节：+20</li><li>二阶微分环节：+40</li><li>惯性环节：-20</li><li>振荡环节：-40</li></ul></li></ol><h2 id="频域性能指标"><a href="#频域性能指标" class="headerlink" title="频域性能指标"></a>频域性能指标</h2><ul><li>零频值 $A(0)=|G(j0)|$ ，越靠近1越好</li><li>复现频率 $\omega_M$ ：事先规定一个 $\Delta$ 作为低频输入信号的允许误差，$\omega_M$ 是幅频特性第一次与 $A(0)$ 相差 $\Delta$ 时的频率，$0-\omega_M$ 为复现带宽</li><li>幅频特性出现最大值时，对应的频率为谐振频率 $\omega_r$ ，其幅值 $A(j\omega_r)=A_M$ 为谐振频率，相对谐振峰值 $M_r=A_M/A(0)$</li><li>$A(0)$ 下降到 $0.707A(0)$ 时的频率叫做截止频率 $\omega_b$ ，$0-\omega_b$ 为截止带宽</li></ul><h1 id="Stability-of-linear-systems-系统稳定性"><a href="#Stability-of-linear-systems-系统稳定性" class="headerlink" title="Stability of linear systems //系统稳定性"></a>Stability of linear systems //系统稳定性</h1><ul><li>系统是否稳定，取决于系统本身，与输入无关</li><li>不稳定现象的存在是因为有反馈回路</li><li>稳定是自由响应的收敛性</li></ul><p>通过特征根判断系统是否稳定</p><ul><li>稳定：<strong>所有极点都位于 $[s]$ 平面左半平面</strong></li><li>不稳定：有极点都位于 $[s]$ 平面右半平面</li><li>临界稳定：有极点位于 $[s]$ 平面虚轴，其他都位于左半平面</li><li>稳定：有极点位于 $[s]$ 平面原点，其他都位于左半平面</li></ul><blockquote><p>PPT上说所有极点都位于 $[s]$ 平面左半平面是系统稳定的充要条件</p></blockquote><h2 id="关于稳定性的一些提法"><a href="#关于稳定性的一些提法" class="headerlink" title="关于稳定性的一些提法"></a>关于稳定性的一些提法</h2><ul><li>李亚普诺夫意义下的稳定：扰动使系统偏离，但是偏离在一定范围内，这个就是稳定</li><li>渐进稳定：由初态引起的偏差最终削减为0</li><li>小偏差稳定：由初态引起的偏差在一定范围内稳定</li></ul><h2 id="Routh判据"><a href="#Routh判据" class="headerlink" title="Routh判据"></a>Routh判据</h2><p>通过对特征根的分析，判断特征根的分布，判断稳定性</p><p>系统稳定充要条件：Routh 表每一列元素符号都为正，且不为0</p><h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><ul><li>任意一列第一行为0：用一个很小的正数 $\varepsilon$ 代替</li><li>其中一行所有元素为0：用该行的上一行的元构成一个辅助多项式，并用这个多项式方程的导数组成下一行</li></ul><h2 id="Nyquist判据"><a href="#Nyquist判据" class="headerlink" title="Nyquist判据"></a>Nyquist判据</h2><p>略</p><h2 id="相对稳定性"><a href="#相对稳定性" class="headerlink" title="相对稳定性"></a>相对稳定性</h2><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823215552.png" alt=""></p><h3 id="相位裕度-gamma"><a href="#相位裕度-gamma" class="headerlink" title="相位裕度 $\gamma$"></a>相位裕度 $\gamma$</h3><script type="math/tex; mode=display">\gamma=180°+\varphi(\omega_c)</script><p>​    其中：$\omega_c$ 为剪切频率（又叫做幅值穿越频率）</p><ul><li>$\omega_c$ 为 Nyquist 图与单位圆的交点，是 Bode 图与横轴的交点，即 $|G(j\omega_c)H(j\omega_c)|=1$ </li><li>对于稳定系统，$\gamma&gt;0$ </li></ul><h2 id="幅值裕度-K-g"><a href="#幅值裕度-K-g" class="headerlink" title="幅值裕度 $K_g$"></a>幅值裕度 $K_g$</h2><script type="math/tex; mode=display">K=\frac1{|G(j\omega_g)H(j\omega_g)|}</script><p>​    其中：$\omega_g$ 为相位穿越频率</p><ul><li>$\omega_g$ 为 Nyquist 图与负实轴的交点，是 Bode 图与180°的交点，即 $|G(j\omega_g)H(j\omega_g)|=1$ </li><li>对于稳定系统，$K_g&gt;1,K(dB)&gt;0$  </li></ul><blockquote><p>增益 K 会使相位裕度和幅值裕度变小，使系统相对稳定性变差</p></blockquote><h1 id="System-Compensation-系统校正"><a href="#System-Compensation-系统校正" class="headerlink" title="System Compensation //系统校正"></a>System Compensation //系统校正</h1><h2 id="性能指标-2"><a href="#性能指标-2" class="headerlink" title="性能指标"></a>性能指标</h2><ul><li>时域性能指标<ul><li>调整时间 $t_s$ </li><li>上升时间 $t_r$ </li><li>峰值时间 $t_p$ </li><li>最大超调量 $M_p$  </li></ul></li><li>频域性能指标<ul><li>相位裕度 $\gamma$ </li><li>幅值裕度 $K_g$ </li><li>复现频率 $\omega_M$ </li><li>谐振频率 $\omega_r$ </li><li>截止频率 $\omega_b$ </li></ul></li></ul><h2 id="系统校正"><a href="#系统校正" class="headerlink" title="系统校正"></a>系统校正</h2><p>在系统中增加新的环节，以改善系统系性能</p><h3 id="相位超前"><a href="#相位超前" class="headerlink" title="相位超前"></a>相位超前</h3><ul><li><p>既提高系统<strong>快速性</strong>和<strong>相对稳定性</strong>，有保证其他性能不会变差</p></li><li><p>使截止频率及更高频率相位提前</p><ul><li>增大相位裕度（增加相对稳定性）</li><li>增大带宽（增加响应速度）</li></ul></li></ul><blockquote><p>带宽越大，响应速度越快</p></blockquote><h3 id="相位滞后"><a href="#相位滞后" class="headerlink" title="相位滞后"></a>相位滞后</h3><ul><li>减小<strong>稳态误差</strong>又不影响稳定性和快速性</li><li>使低频段增益增加</li></ul><h3 id="相位超前滞后"><a href="#相位超前滞后" class="headerlink" title="相位超前滞后"></a>相位超前滞后</h3><h3 id="PID"><a href="#PID" class="headerlink" title="PID"></a>PID</h3><ul><li>P：Proportional 比例（对应上面的增益）</li><li>I：Integral 积分 （有滞后效应）</li><li>D：Derivative 微分（有超前效应）</li></ul><h4 id="PD调节器"><a href="#PD调节器" class="headerlink" title="PD调节器"></a>PD调节器</h4><p>对应相位超前</p><h4 id="PI调节器"><a href="#PI调节器" class="headerlink" title="PI调节器"></a>PI调节器</h4><p>对应相位滞后</p><h4 id="PID调节器"><a href="#PID调节器" class="headerlink" title="PID调节器"></a>PID调节器</h4><p>对应相位超前-滞后</p><hr><p>Learning By Sharing，2018©Fu_Qingchen，Markdown，$\LaTeX$</p>]]></content>
    
    
    <categories>
      
      <category>自动化相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>控制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机械制造工艺学笔记</title>
    <link href="/2018/12/12/WHUT/JiXieZhiZaoGongYiXue/"/>
    <url>/2018/12/12/WHUT/JiXieZhiZaoGongYiXue/</url>
    
    <content type="html"><![CDATA[<p>这玩意很重要，尤其是工步那块，一些移动机器人的操作和算法需要这一块的知识。</p><span id="more"></span><h1 id="加工表面几何形状误差包括哪些"><a href="#加工表面几何形状误差包括哪些" class="headerlink" title="加工表面几何形状误差包括哪些"></a>加工表面几何形状误差包括哪些</h1><ul><li><p><strong>表面粗糙度</strong>：加工表面微观的几何形状误差</p><p>主要由机械加工中切削刀具的运动轨迹，以及一些物理因素引起</p></li><li><p><strong>波纹度</strong>：介于微观的几何形状误差（表面粗糙度），以及宏观几何形状误差（形位误差）之间的几何形状误差</p><p>主要由切削刀具的低频振动和位移造成的</p></li><li><p><strong>纹理方向</strong>：表面刀纹方向</p><p>取决于采用的机械加工方法</p></li><li><p><strong>伤痕</strong>：加工表面个别位置出现的缺陷、气眼、裂纹等</p></li></ul><blockquote><p>来源：3D版课本P347</p></blockquote><h1 id="零件加工精度包括哪些"><a href="#零件加工精度包括哪些" class="headerlink" title="零件加工精度包括哪些"></a>零件加工精度包括哪些</h1><p>包括<strong>尺寸精度</strong>、<strong>位置精度</strong>、<strong>形状精度</strong>，分别由尺寸公差、位置公差、形状公差决定</p><h1 id="工艺系统热源的来源及其影响"><a href="#工艺系统热源的来源及其影响" class="headerlink" title="工艺系统热源的来源及其影响"></a>工艺系统热源的来源及其影响</h1><ul><li><strong>切削热</strong>：最主要的热源，影响工件的加工精度与表面质量</li><li><strong>摩擦热</strong>：机床和液压系统中运动部件引起的，引起局部温升和变形，破坏了原有系统的几何精度，对加工精度有严重影响</li><li><strong>外部热源</strong>：昼夜温差会影响工艺系统的热变形不同，从而影响加工精度；一些照明灯光等局部热源会引起机床各部分有不同的温升和变形</li></ul><blockquote><p>来源：3D版课本P326</p></blockquote><h1 id="装配的基本组织形式和节拍分类"><a href="#装配的基本组织形式和节拍分类" class="headerlink" title="装配的基本组织形式和节拍分类"></a>装配的基本组织形式和节拍分类</h1><p>通常有两种基本组成形式：固定式装配、移动式装配</p><ul><li><p>固定式装配：产品固定，所需零部件向产品集中</p><ul><li>集中式装配</li><li>分散式装配</li><li>巡回式装配</li></ul></li><li><p>移动式装配：流水线作业</p></li></ul><p>装配节拍：生产的时间定额（完成每一个工序所需时间）</p><ul><li>强制节拍：对于固定装配：装配工人在每一个工作地所规定的装配时间定额；对于移动装配，装配工人各自在指定的时间完成各自的工作量</li><li>自由节拍</li></ul><h1 id="金属切削过程如何抑制强迫振动"><a href="#金属切削过程如何抑制强迫振动" class="headerlink" title="金属切削过程如何抑制强迫振动"></a>金属切削过程如何抑制强迫振动</h1><ul><li>抑制激增力的峰值</li><li>隔离振源</li><li>提高工艺系统刚度和阻尼</li><li>减震装置</li></ul><h1 id="粗，精基准的选择原则"><a href="#粗，精基准的选择原则" class="headerlink" title="粗，精基准的选择原则"></a>粗，精基准的选择原则</h1><h2 id="粗基准"><a href="#粗基准" class="headerlink" title="粗基准"></a>粗基准</h2><ul><li>选择重要面为粗基准</li><li>选择不加工表面为粗基准</li><li>选择加工余量较小的为粗基准</li><li>选择较为光洁平整、无分型面，冒口、面积较大的表面为粗基准</li><li>粗基准在同一自由度方向只能使用一次</li></ul><h2 id="精基准"><a href="#精基准" class="headerlink" title="精基准"></a>精基准</h2><ul><li>基准重合原则：被加工面的设计基准与定位基准（精基准）重合</li><li>基准同一原则：尽量选择大家都能用的基准</li><li>自为基准原则：对加工精度要求高、余量小且均匀的表面，常用加工表面本身作为定位基准</li><li>互为基准原则：对于两个面位置精度要求很高，同时自身尺寸形状精度要求高的表面，常采用“互为基准，反复加工”的方法</li><li>所选基准保证工件夹装牢固可靠，操作方便</li></ul><h1 id="工件单件工序时间"><a href="#工件单件工序时间" class="headerlink" title="工件单件工序时间"></a>工件单件工序时间</h1><p>单件工序时间 $t_{单件}$：在一定生产条件下，生产一件产品或完成一道工序所需要的时间</p><script type="math/tex; mode=display">t_{单件}=t_{基本}+t_{辅助}+t_{布置}+t_{休息}</script><ul><li>$t_{基本}$：基本时间；$t_{辅助}$：辅助时间；$t_{布置}$：布置工作地时间；$t_{休息}$：休息和生理所需时间</li></ul><p>单件核算时间 $t_{单核}$：</p><script type="math/tex; mode=display">t_{单核}=t_{单件}+\frac{t_{准备}}n</script><h1 id="加工和装配工艺规程的主要内容"><a href="#加工和装配工艺规程的主要内容" class="headerlink" title="加工和装配工艺规程的主要内容"></a>加工和装配工艺规程的主要内容</h1><ul><li>加工工艺规程：各工序加工内容&amp;要求、所用机床&amp;工艺设备、工件的检验方法、切削用量&amp;工时定额</li><li>装配工艺规程：产品及部件的装配顺序、采用的装配方法、装配的技术要求、装配所需的工具及设备、装配时间定额</li></ul><h1 id="粗糙度，表面硬度，残余应力与耐磨性，抗疲劳性，配合性，接触刚度对性能的影响"><a href="#粗糙度，表面硬度，残余应力与耐磨性，抗疲劳性，配合性，接触刚度对性能的影响" class="headerlink" title="粗糙度，表面硬度，残余应力与耐磨性，抗疲劳性，配合性，接触刚度对性能的影响"></a>粗糙度，表面硬度，残余应力与耐磨性，抗疲劳性，配合性，接触刚度对性能的影响</h1><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">耐磨性</th><th style="text-align:center">抗疲劳性</th><th style="text-align:center">接触刚度</th><th style="text-align:center">配合性</th></tr></thead><tbody><tr><td style="text-align:center">粗糙度</td><td style="text-align:center">过大或过小的表面粗糙度值均会引起工作时的严重磨损</td><td style="text-align:center">表面粗糙度越高，抗疲劳性越差</td><td style="text-align:center">粗糙度越高，接触刚度越差</td><td style="text-align:center">高的表面粗糙度值严重影响配合质量</td></tr><tr><td style="text-align:center">表面硬度</td><td style="text-align:center">适当提高表面硬度一般都能使耐磨性有所提高</td><td style="text-align:center">适度提高表面硬度能提高抗疲劳性，过高的硬度反而降低抗疲劳性</td><td style="text-align:center">适当提高表面硬度可提高接触刚度</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">残余应力</td><td style="text-align:center">适度的残留压应力一般使结构紧密，有助于提高耐磨性</td><td style="text-align:center">适度的残留压应力可提高抗疲劳性，残留拉应力使疲劳性降低</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr></tbody></table></div><h1 id="为什么要进行光整加工？常用光整加工的方法有哪些？各有什么特点？"><a href="#为什么要进行光整加工？常用光整加工的方法有哪些？各有什么特点？" class="headerlink" title="为什么要进行光整加工？常用光整加工的方法有哪些？各有什么特点？"></a>为什么要进行光整加工？常用光整加工的方法有哪些？各有什么特点？</h1><p>光整加工是精加工后，从工件表面上不切除或切除极薄金属层，用以提高加工表面尺寸和形状精度、降低表面粗糙值得加工方法。</p><p>常用的光整加工方法主要有研磨、珩磨、超精加工和抛光等。</p><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">特点</th></tr></thead><tbody><tr><td style="text-align:center">研磨</td><td style="text-align:center">设备比较简单，成本低，加工质量容易得到保证，研磨外圆可获得很高的公差等级、极小的表面粗糙度和较高的形状精度。但不能提高位置精度，生产率较低。</td></tr><tr><td style="text-align:center">珩磨</td><td style="text-align:center">能获得较高的尺寸精度和形状精度，但它不能提高孔的形状精度。不适于加工软而韧的非铁金属工件上的孔，也不能加工带键槽的孔和内花键等断续表面。</td></tr><tr><td style="text-align:center">超精加工</td><td style="text-align:center">设备简单，自动化程度高，操作简便，生产率高。可以减小工件的表面粗糙值，但不能提高尺寸精度和几何精度，工件精度需要前一工序来保证。</td></tr><tr><td style="text-align:center">抛光</td><td style="text-align:center">只能减小表面粗糙值，不能提高尺寸和几何精度，也不能保持抛光前的加工精度。</td></tr></tbody></table></div><h1 id="影响机床回转主轴运动的主要因素"><a href="#影响机床回转主轴运动的主要因素" class="headerlink" title="影响机床回转主轴运动的主要因素"></a>影响机床回转主轴运动的主要因素</h1><ul><li>主轴误差</li><li>轴承误差</li><li>与轴承配合的零件误差</li><li>主轴转速</li><li>主轴系统的径向不等刚度和热变形</li></ul><h1 id="什么是误差复映？减少误差复映有哪些工艺措施？"><a href="#什么是误差复映？减少误差复映有哪些工艺措施？" class="headerlink" title="什么是误差复映？减少误差复映有哪些工艺措施？"></a>什么是误差复映？减少误差复映有哪些工艺措施？</h1><p><strong>误差复映</strong>：加工前的误差以类似的规律反映为加工后的误差</p><p>减少措施：</p><ul><li>直接减少原始误差</li><li>转移原始误差</li><li>均分原始误差</li><li>均化原始误差</li><li>采用就地加工法</li><li>控制误差因素</li></ul><h1 id="机械设备装配工艺应该考虑哪些内容"><a href="#机械设备装配工艺应该考虑哪些内容" class="headerlink" title="机械设备装配工艺应该考虑哪些内容"></a>机械设备装配工艺应该考虑哪些内容</h1><ul><li>机器的总体结构应该能划分成几个独立的装配单元</li><li>机器结构应具有正确的装配基准面</li><li>尽量减少装配过程中的修配劳动量</li><li>机器结构应该装配和拆卸方便</li></ul><h1 id="焊接工艺顺序"><a href="#焊接工艺顺序" class="headerlink" title="焊接工艺顺序"></a>焊接工艺顺序</h1><ol><li>钢材预处理，喷丸除锈</li><li>板材下料</li><li>定位（划线，工装加固）</li><li>施焊</li><li>焊后热处理</li><li>焊接质量检验</li></ol><hr><p>Learning By Sharing，2018©Fu_Qingchen，Markdown，$\LaTeX$</p>]]></content>
    
    
    <categories>
      
      <category>机械相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机械制造工艺学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工程流体力学笔记</title>
    <link href="/2018/12/12/WHUT/EngineeringFluidMechanics/"/>
    <url>/2018/12/12/WHUT/EngineeringFluidMechanics/</url>
    
    <content type="html"><![CDATA[<p>据说很难，不过我感觉还好。巩固了下线性代数和材料力学的一些知识。其中的一些公式用来做动画很有意思。</p><span id="more"></span><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200822203524.png" alt="思维导图"></p><h1 id="流体基本概念"><a href="#流体基本概念" class="headerlink" title="流体基本概念"></a>流体基本概念</h1><h2 id="牛顿粘性定律"><a href="#牛顿粘性定律" class="headerlink" title="牛顿粘性定律"></a>牛顿粘性定律</h2><p>对牛顿流体：</p><script type="math/tex; mode=display">F=\mu A\frac{du}{dy}\\\tau =\mu\frac{du}{dy}</script><p>其中：$\tau$ 为剪应力，$\mu$ 为粘度，$du/dy$ 为速度梯度</p><blockquote><p>工程中，粘度还会有其他表示形式，例如：</p><ul><li>运动粘度：$\nu=\mu/\rho$ ，常见单位 $mm^2/s$ (里斯)</li><li>相对粘度：这个在测量粘性时会用到</li></ul></blockquote><h2 id="流体可压缩性"><a href="#流体可压缩性" class="headerlink" title="流体可压缩性"></a>流体可压缩性</h2><p>一定温度 T 下，单位压强升高引起的体积变化率</p><script type="math/tex; mode=display">\kappa=-\frac{\delta V/V}{\delta P},K=\frac 1\kappa</script><p>​    其中：$\kappa$ 为压缩系数，$K$ 为压缩模量。$K\uparrow$ ，可压缩性 $\downarrow$</p><h1 id="流体静力学"><a href="#流体静力学" class="headerlink" title="流体静力学"></a>流体静力学</h1><h2 id="液体静压强"><a href="#液体静压强" class="headerlink" title="液体静压强"></a>液体静压强</h2><p>当流体处于静止或相对静止状态时，内法线表面力为压强。</p><ul><li><p>在静止的流体中，流体静压强的方向沿着作用面的内法线方向（无切向压强）</p></li><li><p>静止流体任意一点流体静压强大小与作用面在空间方位无关，是点坐标的可微函数（只与坐标有关）</p><p>$p_x=p_y=p_z=p_n$</p></li></ul><h2 id="欧拉流体静力平衡方程"><a href="#欧拉流体静力平衡方程" class="headerlink" title="欧拉流体静力平衡方程"></a>欧拉流体静力平衡方程</h2><p><strong>质量力</strong> 与 <strong>压力分布</strong> 的关系</p><script type="math/tex; mode=display">\vec{f}=\frac1\rho \nabla p</script><p>​    其中：$\nabla =\frac{\partial}{\partial x}\vec i+\frac{\partial}{\partial y}\vec j+\frac{\partial}{\partial z}\vec k$</p><ul><li><p>物理意义：在静止流体内一点，单位质量力与流体静压力合力平衡</p></li><li><p>欧拉平衡方程对任意种类平衡流体适用</p></li><li><p>静力平衡全微分方程：$dp=\rho(f_xdx+f_ydy+f_zdz)$ </p><p>也叫做压强差公式，表明静压强的增量取决于单位质量力和坐标增量</p></li><li><p>等压面：$dp=0\Rightarrow\vec f·dr=0$，等压面上，任意一点方向与质量力方向相同，即质量力与等压面垂直</p></li></ul><h2 id="流体静力学基本方程"><a href="#流体静力学基本方程" class="headerlink" title="流体静力学基本方程"></a>流体静力学基本方程</h2><script type="math/tex; mode=display">z_1+\frac{p_1}{\rho g}=z_2+\frac{p_2}{\rho g}</script><ul><li>适用于重力作用下的不可压缩流体</li><li>在重力作用下的不可压缩流体，单位质量流体的总势能保持不变</li></ul><h2 id="有自由液面的静止液体压强公式"><a href="#有自由液面的静止液体压强公式" class="headerlink" title="有自由液面的静止液体压强公式"></a>有自由液面的静止液体压强公式</h2><script type="math/tex; mode=display">p=p_0+\rho gh</script><p>​    其中：$p_0$ 为自由液面压强，$\rho gh$ 为液体重力引起压强</p><ul><li>自由液面压强可沿流体各个方向等值传递</li></ul><h2 id="液体相对平衡"><a href="#液体相对平衡" class="headerlink" title="液体相对平衡"></a>液体相对平衡</h2><h3 id="容器匀加速运动"><a href="#容器匀加速运动" class="headerlink" title="容器匀加速运动"></a>容器匀加速运动</h3><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200822203614.png" alt=""></p><ul><li>容器内任意一点压强： $p(y,z)=p_0-\rho g(ay+gz)$</li><li>等压面：$ay+gz=0$</li><li>A压强：$p_A=\rho gh$</li></ul><h3 id="容器匀加速运动-1"><a href="#容器匀加速运动-1" class="headerlink" title="容器匀加速运动"></a>容器匀加速运动</h3><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200822203643.png" alt=""></p><ul><li>容器内任意一点压强： $p(y,z)=p_0+\rho g(\omega^2r^2/2g-z)$</li><li>等压面：$z=\omega^2r^2/2g$</li><li>A压强：$p_A=\rho gh$</li></ul><h2 id="液体对壁面作用力"><a href="#液体对壁面作用力" class="headerlink" title="液体对壁面作用力"></a>液体对壁面作用力</h2><h3 id="平面"><a href="#平面" class="headerlink" title="平面"></a>平面</h3><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200822203709.png" alt=""></p><script type="math/tex; mode=display">F_P=\rho gh_CA</script><ul><li>$h_C$：平面形心淹没高度；$A$：平面面积</li><li>液体作用在平面上的力等于：以 平面为底、以平面形心淹没深度为高的柱体内液体体积</li><li>方向：垂直于平面</li><li>作用点：$y_D=y_C+I_{Cx}/{y_CA}$<ul><li>利用力矩等效+平行移轴定理求解得到</li><li>作用点又称为压力中心，总是作用在形心下方</li></ul></li></ul><h3 id="曲面"><a href="#曲面" class="headerlink" title="曲面"></a>曲面</h3><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200822203738.png" alt=""></p><script type="math/tex; mode=display">F_{PH}=\rho gh_{Cx}A_x\\F_{PV}=\rho gV_P</script><ul><li>$A_x$：曲面在水平方向上的投影面积；$V_P$：压力体体积</li><li>静止液体在曲面总压力<ul><li>水平分力 = 液体作用在曲面投影面积 $Ax$ 上压力，作用点为其压力中心</li><li>竖直分力 = 曲面上压力体体积，作用线通过压力体的中心</li></ul></li></ul><h2 id="浮力"><a href="#浮力" class="headerlink" title="浮力"></a>浮力</h2><script type="math/tex; mode=display">F_P=\rho gV</script><p>​    其中：V为排开水的体积</p><h1 id="流体运动学"><a href="#流体运动学" class="headerlink" title="流体运动学"></a>流体运动学</h1><h2 id="质点导数"><a href="#质点导数" class="headerlink" title="质点导数"></a>质点导数</h2><p>质点的导数对时间的变化量，物理量 $B(x,y,z,t)$ 的质点导数定义为</p><script type="math/tex; mode=display">\frac{DB}{Dt}=\frac{\partial B}{\partial t}+\frac{\partial B}{\partial x}u+\frac{\partial B}{\partial y}v+\frac{\partial B}{\partial z}w</script><h2 id="迹线方程"><a href="#迹线方程" class="headerlink" title="迹线方程"></a>迹线方程</h2><script type="math/tex; mode=display">\frac{dx}{u(x,y,z,t)}=\frac{dy}{v(x,y,z,t)}=\frac{dz}{w(x,y,z,t)}=dt</script><h2 id="流线方程"><a href="#流线方程" class="headerlink" title="流线方程"></a>流线方程</h2><script type="math/tex; mode=display">\frac{dx}{u(x,y,z,t)}=\frac{dy}{v(x,y,z,t)}=\frac{dz}{w(x,y,z,t)}</script><h1 id="流体动力学"><a href="#流体动力学" class="headerlink" title="流体动力学"></a>流体动力学</h1><h2 id="雷诺输运方程"><a href="#雷诺输运方程" class="headerlink" title="雷诺输运方程"></a>雷诺输运方程</h2><p>控制体：在流场中人为选取的空间几何体系。</p><blockquote><p>在欧拉法中，系统的流量与控制体中的流量是不一样的，雷诺输运方程就是将系统与控制体联系起来的方程</p></blockquote><p>在流场中取控制体 $CV$，其表面为控制面 $CS$ ，对于物理量 $N$ ，有</p><script type="math/tex; mode=display">\frac{dN_{sys}}{dt}=\frac{\partial N_{CV}}{\partial t}+\int_{CS} \eta\rho(\vec v·\vec n)dA=\frac{\partial}{\partial t}\int_{CV}\eta\rho dV+\int_{CS}\eta\rho(\vec v·\vec n)dA</script><p>​    其中：$\eta=N/m$</p><h2 id="连续性方程"><a href="#连续性方程" class="headerlink" title="连续性方程"></a>连续性方程</h2><p>令 $N=m,\eta=1$ ，由 <strong>质量守恒定理</strong> </p><script type="math/tex; mode=display">\frac{dm_{sys}}{dt}=\frac{\partial}{\partial t}\int_{CV}\rho dV+\int_{CS}\rho(\vec v·\vec n)dA=0</script><p>对定常流动，$dN/dt=0$</p><script type="math/tex; mode=display">\frac {dm_{sys}}{dt}=\int_{CS}\rho(\vec v·\vec n)dA=0</script><p>对不可压缩流体</p><script type="math/tex; mode=display">\int_{CS}(\vec v·\vec n)dA=0\Rightarrow\sum Q_{in}=\sum Q_{out}</script><h2 id="动量方程"><a href="#动量方程" class="headerlink" title="动量方程"></a>动量方程</h2><p>令 $N=m\vec v,\eta=\vec v$ ，由 <strong>动量定理</strong> </p><script type="math/tex; mode=display">\frac{d(mv)_{sys}}{dt}=\frac{\partial}{\partial t}\int_{CV}\vec v\rho dV+\int_{CS}\vec v\rho(\vec v·\vec n)dA=\sum F</script><p>对定常流动，$dN/dt=0$</p><script type="math/tex; mode=display">\frac {d(mv)_{sys}}{dt}=\int_{CS}\vec v\rho(\vec v·\vec n)dA=\sum F</script><p>对不可压缩流体</p><script type="math/tex; mode=display">\int_{CS}\vec v(\vec v·\vec n)dA=\sum F\Rightarrow\sum\limits_{out}m\vec v-\sum\limits_{in}m\vec v=\sum F</script><h2 id="动量矩定理"><a href="#动量矩定理" class="headerlink" title="动量矩定理"></a>动量矩定理</h2><p>同理</p><script type="math/tex; mode=display">\sum\limits_{out}\rho Q_{out}(\vec v·\vec r)-\sum\limits_{in}\rho Q_{in}(\vec v·\vec r)=\sum T</script><h1 id="量纲分析-amp-相似理论"><a href="#量纲分析-amp-相似理论" class="headerlink" title="量纲分析&amp;相似理论"></a>量纲分析&amp;相似理论</h1><h2 id="相似理论"><a href="#相似理论" class="headerlink" title="相似理论"></a>相似理论</h2><p>步骤：</p><ol><li>列举出所有相关的物理量，组成关系式</li><li>选择包含不同基本量纲的物理量为基本量</li><li>将导出量与基本量的幂式组成 $\Pi$ 表达式，用量纲次数求解每个 $\Pi$ 表达式的指数，组成 $\Pi$ 数</li></ol><blockquote><p>例：泵的效率 $η$  是流体密度$\rho$、转速 $n$、特征直径 $D$ 、流量 $Q$、粘度 $μ$、特征长度 $l$ 和表面粗糙度 $ε$ 等物理量的函数。取 $\rho$，$n$，$D$为基本量，试用量纲分析法推导无量纲质量能头系数效率 $η$ 的 $\Pi$ 数方程式。</p><p>解：</p><ol><li><p>列出物理量：$η=f(\rho,n,D,Q,\mu,l,\varepsilon)$</p></li><li><p>求 $η$ 的 $\Pi$ 数</p><p>$\Pi_1=\rho^an^bD^cη\Rightarrow M^0L^0T^0=(ML^{-3})^a(T^{-1})^b(L)^c1\Rightarrow a=0,b=0,c=0\Rightarrow\Pi_1=\eta$ </p></li><li><p>求 $Q$ 的 $\Pi$ 数</p><p>$\Pi_2=\rho^an^bD^cQ\Rightarrow M^0L^0T^0=(ML^{-3})^a(T^{-1})^b(L)^c(L^3T^{-1})\Rightarrow a=0,b=-1,c=-3\Rightarrow\Pi_2=Q/(nD^3)$</p></li><li><p>求 $\mu$ 的 $\Pi$ 数</p><p>$\Pi_3=\rho^an^bD^cη\Rightarrow M^0L^0T^0=(ML^{-3})^a(T^{-1})^b(L)^c(ML^{-1}T^{-1})\Rightarrow a=-1,b=-1,c=-2\Rightarrow\Pi_3=\mu/(\rho nD^2)$</p></li><li><p>求 $l$ 的 $\Pi$ 数</p><p>$\Pi_4=\rho^an^bD^cη\Rightarrow M^0L^0T^0=(ML^{-3})^a(T^{-1})^b(L)^c(L)\Rightarrow a=0,b=0,c=-1\Rightarrow \Pi_4=l/D$</p></li><li><p>求 $\varepsilon$ 的 $\Pi$ 数</p><p>$\Pi_5=\rho^an^bD^cη\Rightarrow M^0L^0T^0=(ML^{-3})^a(T^{-1})^b(L)^c1\Rightarrow a=0,b=0,c=-1\Rightarrow \Pi_4=\varepsilon/D$</p></li><li><p>列表达式</p><p>$\Pi_1=f(\Pi_2,\Pi_3,\Pi_4,\Pi_5)\Rightarrow\eta=f(Q/(nD^3),\mu/(\rho nD^2),l/D,\varepsilon/D)$</p></li></ol></blockquote><h2 id="常见的相似准则"><a href="#常见的相似准则" class="headerlink" title="常见的相似准则"></a>常见的相似准则</h2><p>流体力学常用的相似准则包含：密度 $\rho$ 、速度 $v$ 、粘度 $\mu$ 、重力加速度 $g$ 、压强差 $\Delta p$ 、外力 $F$    </p><ul><li>粘性力相似<script type="math/tex; mode=display">Re=\frac{\rho vl}{\mu}</script></li></ul><blockquote><p>适用于有压管流、射流、绕流、流体机械中的流动</p></blockquote><ul><li>重力相似</li></ul><script type="math/tex; mode=display">Fr=\frac{v}{\sqrt{gh}}</script><blockquote><p>Fr 表示迁移惯性力与重力之比，反应重力对流体影响的相对重要性，是描述有自由液面的流体流动时最重要的参数</p></blockquote><ul><li>压力相似</li></ul><script type="math/tex; mode=display">Eu=\frac{\Delta p}{\rho v^2}</script><ul><li>外力相似</li></ul><script type="math/tex; mode=display">Ne=\frac{F}{\rho v^2l^2}</script><hr><p>Learning By Sharing，2018©Fu_Qingchen，Markdown，$\LaTeX$</p>]]></content>
    
    
    <categories>
      
      <category>液压相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>液压</tag>
      
      <tag>流体</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机械有限元分析笔记</title>
    <link href="/2018/12/09/WHUT/FiniteElementMethod/"/>
    <url>/2018/12/09/WHUT/FiniteElementMethod/</url>
    
    <content type="html"><![CDATA[<p>这玩意好难，对材料力学和线性代数的基础要求很高，而且APDL对新手来说也很不友好。这个在毕业设计的时候也涉及到了，不过用的是Workbench，方便很多。</p><span id="more"></span><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200822203910.png" alt="思维导图"></p><h1 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h1><h2 id="有限元分析步骤"><a href="#有限元分析步骤" class="headerlink" title="有限元分析步骤"></a>有限元分析步骤</h2><ul><li><p>离散化结构：把连续结构的力学模型转变为离散的力学模型</p></li><li><p>单元分析：求出表示各个单元力学特性的单元刚度矩阵</p></li><li>整体分析：将各单元刚度矩阵组集成整个结构的总刚矩阵，引入边界条件，求解</li></ul><h1 id="有限元概念"><a href="#有限元概念" class="headerlink" title="有限元概念"></a>有限元概念</h1><h2 id="设置节点的原则"><a href="#设置节点的原则" class="headerlink" title="设置节点的原则"></a>设置节点的原则</h2><ul><li>同一单元内，单元的各项特性数据和材料数据应该保持一致</li><li>在载荷突变处，集中载荷作用点要设置节点</li><li>欲知道单元应力状况、位移状况、内力状况的地方要设置节点</li></ul><h2 id="形函数及性质"><a href="#形函数及性质" class="headerlink" title="形函数及性质"></a>形函数及性质</h2><script type="math/tex; mode=display">N_i=\frac 1{2A}(a_i+b_ix+c_iy)</script><p>​    其中 $a_i=\left|<br>\begin{matrix}<br>x_j&amp;y_j\\<br>x_m&amp;y_m\\<br>\end{matrix}<br>\right|,b_i=-\left|<br>\begin{matrix}<br>1&amp;y_j\\<br>1&amp;y_m\\<br>\end{matrix}<br>\right|c_i=-\left|<br>\begin{matrix}<br>x_j&amp;1\\<br>x_m&amp;1\\<br>\end{matrix}<br>\right|$</p><ul><li><p>单元内任意一点的三个形函数之和恒等于1。$N_i+N_j+N_m=1$ </p></li><li><p>在 i,j,m 三个顶点处，有</p><ul><li><p>在 i 节点处：$N_i=1,N_j=N_m=0$ </p></li><li><p>在 j 节点处：$N_j=1,N_i=N_m=0$ </p></li><li><p>在 m 节点处：$N_m=1,N_j=N_i=0$ </p></li></ul></li></ul><h2 id="位移模式收敛性分析"><a href="#位移模式收敛性分析" class="headerlink" title="位移模式收敛性分析"></a>位移模式收敛性分析</h2><h3 id="完备性"><a href="#完备性" class="headerlink" title="完备性"></a>完备性</h3><blockquote><p>充分条件</p></blockquote><h4 id="位移模式需包括常应变状态"><a href="#位移模式需包括常应变状态" class="headerlink" title="位移模式需包括常应变状态"></a>位移模式需包括常应变状态</h4><p>即应变分量 $\{\varepsilon\}$ 与 x,y 无关</p><h4 id="位移模式需包括单元的刚体位移"><a href="#位移模式需包括单元的刚体位移" class="headerlink" title="位移模式需包括单元的刚体位移"></a>位移模式需包括单元的刚体位移</h4><p>即应变分量 $\{\varepsilon\}=0$ 时的位移方程，要和质点做刚体运动的方程对应</p><h3 id="协调性"><a href="#协调性" class="headerlink" title="协调性"></a>协调性</h3><blockquote><p>必要条件</p></blockquote><h4 id="位移模式必须反映位移的连续性"><a href="#位移模式必须反映位移的连续性" class="headerlink" title="位移模式必须反映位移的连续性"></a>位移模式必须反映位移的连续性</h4><p>各个单元在变形之后单元内、单元间保持连续，不撕裂，不侵入</p><h2 id="载荷的移置"><a href="#载荷的移置" class="headerlink" title="载荷的移置"></a>载荷的移置</h2><p>原则是原载荷在任何虚位移上做的虚功，与移置到各节点的力所做的虚功相等</p><p>对于三角形三节点单元：</p><ul><li>集中力的移置：$\{R\}=[N]^T{\{P\}}$ ，其中 $\{P\}$ 为集中力</li><li>面力的移置：$\{R\}=\int[N]^T\{p\}ds$ ，其中 $\{p\}$ 为面力密度</li><li>体力的移置：$\{R\}=\int[N]^T\{p\}tdxdy$ ，其中  $t$ 为厚度</li></ul><p>对于轴对称单元：</p><ul><li>集中力的移置：$\{R\}=2\pi r[N]^T{\{P\}}$ ，其中 $\{P\}$ 为集中力</li><li>面力的移置：$\{R\}=\int2\pi r[N]^T\{p\}ds$ ，其中 $\{p\}$ 为面力密度</li><li>体力的移置：$\{R\}=\int2\pi r[N]^T\{p\}drdz$ ，其中  $t$ 为厚度</li></ul><h2 id="总刚组集"><a href="#总刚组集" class="headerlink" title="总刚组集"></a>总刚组集</h2><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ol><li>变形后各节点任然协调的相互连接（连续性）</li><li>各节点满足静力平衡条件，节点力 = 外载荷</li></ol><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p><strong>扩大</strong>各单元矩阵，使之成为与总刚矩阵相同的阶数</p><blockquote><p>此处的阶数 = 位移分量个数 × 节点数</p></blockquote></li><li><p>按照总刚矩阵的编号，<strong>移动</strong>各单元矩阵的各个子块</p></li><li>将各个矩阵相加</li></ol><h2 id="总刚性质"><a href="#总刚性质" class="headerlink" title="总刚性质"></a>总刚性质</h2><ul><li><p>位置无关性（总刚与位置无关，只与材料特性、几何形状、尺寸大小有关）</p></li><li><p>对称性</p></li><li><p>奇异性（ $[K]$ 无逆矩阵，即在 $\{F\}=[K]\{\delta\}$ 只能由位移求力，不能由力求位移）</p></li><li><p>稀疏性（总刚中0多，非0少）</p></li><li><p>带状性（只有中间有数值，呈带状，两边都是0）</p><blockquote><p><strong>半带宽值 B = ( 相邻节点最大差值 + 1 ) × 单个节点自由度数</strong>（对平面问题，单个节点自由度数 = 2）</p><p>半带宽值与计算机处理性能有关，可越小越好</p></blockquote></li></ul><h3 id="总刚矩阵的内存压缩机制"><a href="#总刚矩阵的内存压缩机制" class="headerlink" title="总刚矩阵的内存压缩机制"></a>总刚矩阵的内存压缩机制</h3><p>总刚矩阵具有对称性，只需存入主对角线上半带或下半带的元素，就可以完成解方程的运算。此即为总刚矩阵的半带宽存储方法。 </p><p>假定取主对角线上半带元素存储，具体做法就是每行元素以主对角线上的元素开始，存储每行半带宽数值的元素个数。如此各元素的行号不变，改变的只是列号。新列号和原列号的关系式如下： </p><p><strong>新列号 = 原列号 - 行号 + 1</strong> </p><h2 id="总体边界条件的引入"><a href="#总体边界条件的引入" class="headerlink" title="总体边界条件的引入"></a>总体边界条件的引入</h2><h3 id="边界节点固定"><a href="#边界节点固定" class="headerlink" title="边界节点固定"></a>边界节点固定</h3><p>$u_{i}=u_{j}=0$</p><p>使用 <strong>置0-1法</strong> ：</p><p>即首先在总刚矩阵 $[K]$ 中与已知位移分量相对应的行和列元素改为 0，但主对角线上的元素改为 1 ，然后在节点载荷向量的列阵中，与已知对应元素的位移用代替，其余元素减去已知位移分别乘 $[K]$ 中相应元素。</p><h3 id="边界有特定位移值"><a href="#边界有特定位移值" class="headerlink" title="边界有特定位移值"></a>边界有特定位移值</h3><p>$u_{i}=C$ </p><p>使用 <strong>乘大数法</strong> ：</p><p>在总刚矩阵 $[K]$ 中，把与已知位移位移相对应的行与列主对角线上的元素乘一个很大的数 $10^{10}$ ，然后把载荷向量中的对应元素代以给定位移乘以相应主对角线上的元素，再同样乘以一个很大的数。 </p><h3 id="应力平滑处理"><a href="#应力平滑处理" class="headerlink" title="应力平滑处理"></a>应力平滑处理</h3><p>由于三角形单元求得的应力或应变是不连续的，为了使模拟更加准确，因此要平滑应力的突变。 </p><p>就是将绕某一节点的各单元形心应力加以平均，来表示该节点的应力。</p><h1 id="常见单元类型"><a href="#常见单元类型" class="headerlink" title="常见单元类型"></a>常见单元类型</h1><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200822203953.png" alt=""></p><h1 id="命令流"><a href="#命令流" class="headerlink" title="命令流"></a>命令流</h1><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200822204022.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python">/BATCH!批处理<br>/PREP7!输入该指令后开始建模<br>/*定义材料*/<br>ET,<span class="hljs-number">1</span>,BEAM188!单元类型：ElementType 序号,单元类型<br>KEYOPT,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>!对 BEAM188 的设置：ET1 的 (KEYOPT3) 的值为 <span class="hljs-number">3</span>,这里是选择了空间类型<br>MP,EX,<span class="hljs-number">1</span>,<span class="hljs-number">2.1E5</span>!设置材料属性，ET1 的弹性模量值为 <span class="hljs-number">2.1E5</span><br>MP,NUXY,<span class="hljs-number">1</span>,<span class="hljs-number">0.3</span>!设置材料属性，ET1 的柏松比值为 <span class="hljs-number">0.3</span><br>/*定义梁截面*/<br>SECTYPE,<span class="hljs-number">1</span>,BEAM,RECT!设置第一种梁截面为矩形<br>SECDATE,<span class="hljs-number">30</span>,<span class="hljs-number">10</span>!矩形高宽为 <span class="hljs-number">30</span>,<span class="hljs-number">10</span><br>SECTYPE,<span class="hljs-number">2</span>,BEAM,CSOLID!设置第二种截面为实心圆<br>SECDATE,<span class="hljs-number">10</span>!圆半径 <span class="hljs-number">10</span><br>/*设置节点*/<br>N,<span class="hljs-number">1</span>,-<span class="hljs-number">2000</span><br>N,<span class="hljs-number">2</span><br>N,<span class="hljs-number">3</span><br>N,<span class="hljs-number">4</span>,,<span class="hljs-number">2000</span><br>N,<span class="hljs-number">5</span>,<span class="hljs-number">2000</span><br>N,<span class="hljs-number">6</span>,-<span class="hljs-number">1000</span><br>N,<span class="hljs-number">7</span>,<span class="hljs-number">1000</span><br>/*设置单元*/<br>E,<span class="hljs-number">1</span>,<span class="hljs-number">6</span><br>E,<span class="hljs-number">6</span>,<span class="hljs-number">2</span><br>E,<span class="hljs-number">2</span>,<span class="hljs-number">7</span><br>E,<span class="hljs-number">7</span>,<span class="hljs-number">5</span><br>SECNUM,<span class="hljs-number">2</span><br>E,<span class="hljs-number">3</span>,<span class="hljs-number">4</span><br>/*创建耦合条件*/<br>CP,<span class="hljs-number">1</span>,UX,<span class="hljs-number">2</span>,<span class="hljs-number">3</span><br>CP,<span class="hljs-number">2</span>,UY,<span class="hljs-number">2</span>,<span class="hljs-number">3</span><br>CP,<span class="hljs-number">3</span>,UZ,<span class="hljs-number">2</span>,<span class="hljs-number">3</span><br>CP,<span class="hljs-number">4</span>,ROTX,<span class="hljs-number">2</span>,<span class="hljs-number">3</span><br>CP,<span class="hljs-number">5</span>,ROTY,<span class="hljs-number">2</span>,<span class="hljs-number">3</span><br>FINISH<br><br>/SOLV<br>/*添加约束和力*/<br>D,<span class="hljs-number">1</span>,ALL,<span class="hljs-number">1</span><br>D,<span class="hljs-number">2</span>,ALL,<span class="hljs-number">5</span><br>D,<span class="hljs-number">3</span>,UX,<span class="hljs-number">4</span><br>D,<span class="hljs-number">4</span>,UY,<span class="hljs-number">4</span><br>F,<span class="hljs-number">1</span>,FY,<span class="hljs-number">6</span>,-<span class="hljs-number">1000</span><br>F,<span class="hljs-number">2</span>,FY,<span class="hljs-number">7</span>,-<span class="hljs-number">1000</span><br>SOLV<br>FINISH<br></code></pre></td></tr></table></figure><hr><p>Learning By Sharing，2018©Fu_Qingchen，Markdown，$\LaTeX$</p>]]></content>
    
    
    <categories>
      
      <category>计算机相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>有限元</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单片机原理及接口技术笔记</title>
    <link href="/2018/12/09/WHUT/Microcontroller/"/>
    <url>/2018/12/09/WHUT/Microcontroller/</url>
    
    <content type="html"><![CDATA[<p>玩小电脑的一门课，还挺有意思的，可以接触到一些计算机底层的东西。这里放的是一些大作业</p><span id="more"></span><h1 id="电话键盘及拨号的模拟"><a href="#电话键盘及拨号的模拟" class="headerlink" title="电话键盘及拨号的模拟"></a>电话键盘及拨号的模拟</h1><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【单片机原理及接口技术】实验报告_Page_03.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【单片机原理及接口技术】实验报告_Page_04.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【单片机原理及接口技术】实验报告_Page_05.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【单片机原理及接口技术】实验报告_Page_06.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【单片机原理及接口技术】实验报告_Page_07.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【单片机原理及接口技术】实验报告_Page_08.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【单片机原理及接口技术】实验报告_Page_09.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【单片机原理及接口技术】实验报告_Page_10.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【单片机原理及接口技术】实验报告_Page_11.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【单片机原理及接口技术】实验报告_Page_12.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【单片机原理及接口技术】实验报告_Page_13.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【单片机原理及接口技术】实验报告_Page_14.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【单片机原理及接口技术】实验报告_Page_15.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【单片机原理及接口技术】实验报告_Page_16.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【单片机原理及接口技术】实验报告_Page_17.jpg" alt=""></p><h1 id="步进电机控制实验"><a href="#步进电机控制实验" class="headerlink" title="步进电机控制实验"></a>步进电机控制实验</h1><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【单片机原理及接口技术】实验报告_Page_18.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【单片机原理及接口技术】实验报告_Page_19.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【单片机原理及接口技术】实验报告_Page_20.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【单片机原理及接口技术】实验报告_Page_21.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【单片机原理及接口技术】实验报告_Page_22.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【单片机原理及接口技术】实验报告_Page_23.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【单片机原理及接口技术】实验报告_Page_24.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【单片机原理及接口技术】实验报告_Page_25.jpg" alt=""></p><hr><p>Learning By Sharing，2018©Fu_Qingchen，Markdown</p>]]></content>
    
    
    <categories>
      
      <category>计算机相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单片机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Machine Helper：机械设计辅助计算器</title>
    <link href="/2018/08/12/WHUT/MachineHelperAPP/"/>
    <url>/2018/08/12/WHUT/MachineHelperAPP/</url>
    
    <content type="html"><![CDATA[<p>经过一个月的设计制作，Machine Helper这个应用终于出锅了，现在正式推出这个应用的1.0-alpha版本</p><p><img src="https://gitee.com/fuqingchen/MachineHelper/raw/master/image/宣传图片.png" alt="img"></p><span id="more"></span><p>Machine Helper旨在简化机械设计计算过程，让您的工作更加轻松。内含齿轮的设计计算、平键的设计计算、轴承的寿命计算；线性插值，数值积分，数值微分，方程求解；国标指引总共8个功能。</p><p>后期打算加入自定义公式、公差查询等功能</p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="https://github.com/Fu-Qingchen/MachineHelper/releases/download/v1.0-alpha/MachineHelperv1.0-alpha.apk">https://github.com/Fu-Qingchen/MachineHelper/releases/download/v1.0-alpha/MachineHelperv1.0-alpha.apk</a></p><p>（点击后直接下载）</p><h1 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h1><p><img src="https://gitee.com/fuqingchen/MachineHelper/raw/master/image/%E8%AE%A1%E7%AE%97.png" alt="计算.png"></p><p>计算是该应用使用最广泛的功能，包含4个部分。</p><ul><li><p>线性插值</p><p>利用插值函数求解待求插值点处的函数值</p></li><li><p>数值积分</p><p>根据积分上下限与函数求解积分值</p></li><li><p>数值微分</p></li><li><p>方程求解</p><p>求一定范围内函数零点</p></li></ul><p>在后三个部分中，方程所包含的函数参见说明文档：<a href="https://github.com/Fu-Qingchen/MachineHelper/blob/master/README.md#%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E">https://github.com/Fu-Qingchen/MachineHelper/blob/master/README.md#%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E</a></p><p>线性插值将会在后期增加到多次插值，数值积分可能会增加至二重积分、三重积分。</p><blockquote><p>注：该部分计算结果有效数字为8位</p></blockquote><h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><p><img src="https://gitee.com/fuqingchen/MachineHelper/raw/master/image/%E8%AE%BE%E8%AE%A1.png" alt="设计.png"></p><p>设计与机械设计直接相关，包含4个部分。其中公差会在下个版本加入</p><ul><li><p>齿轮：对 <strong>钢制软齿面齿轮</strong> 的设计计算。</p><p>可以计算出齿轮的分度圆直径初定值、模数、齿轮的几何参数及弯曲疲劳强度</p></li><li><p>平键</p><p>可以计算出平键连接的轴毂几何尺寸及公差</p></li><li><p>轴承：对滚动轴承寿命的计算</p><p>这个目的只要是规范操作，实际意义较少</p></li></ul><h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><img src="https://gitee.com/fuqingchen/MachineHelper/raw/master/image/%E4%BF%A1%E6%81%AF.png" alt="信息.png"></p><p>信息主要是信息查询以及APP的相关信息</p><ul><li><p>国标</p><p>国家标准信息全文公开系统的检索，平时找标准太麻烦了，这里相当于是一个快捷方式，导航到这里来</p></li><li><p>关于</p><p>APP的相关信息，包括联系与反馈、开发相关和申明</p></li><li><p>支持</p><p>对开发者的一些支持啦~</p></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li>开源地址：<a href="https://github.com/Fu-Qingchen/MachineHelper">https://github.com/Fu-Qingchen/MachineHelper</a></li><li>该应用外观设计参考 Google I/O 2018</li><li>本应用为免费无广告应用</li></ul><hr><p>2018©Fu_Qingchen</p>]]></content>
    
    
    <categories>
      
      <category>计算机相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>Android，APP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>课程设计：双级圆柱斜齿轮减速器</title>
    <link href="/2018/07/13/WHUT/CourseDesignOfMechanismDesign/"/>
    <url>/2018/07/13/WHUT/CourseDesignOfMechanismDesign/</url>
    
    <content type="html"><![CDATA[<p>放在这留作纪念，不过为了放抄袭故意设置了一些<strong>明显错误</strong>。</p><span id="more"></span><h1 id="任务书"><a href="#任务书" class="headerlink" title="任务书"></a>任务书</h1><p>题目：双级圆柱斜齿轮减速器</p><p>初始条件：</p><ul><li>工件轻微震动，使用十年，双班制；每年300天，一天8小时；轴承寿命大于3年。</li><li>卷筒直径（mm）：340</li><li>传输带速度（m/s）：0.75</li><li>传输带扭矩（N·m）：450</li></ul><p>要求完成的主要任务：</p><ol><li>传动方案的确定</li><li>电机选型</li><li>传动装置一定、动力计算</li><li>轴系设计</li><li>联轴器选型</li><li>箱体及附件设计</li></ol><p>完成装配图一张（A1），零件图二张（A2或A3），计算说明书一份</p><h1 id="装配图"><a href="#装配图" class="headerlink" title="装配图"></a>装配图</h1><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/bcedc069gy1ft8k8wiuqfj21400qogsj.jpg" alt="装配图"></p><h1 id="零件图"><a href="#零件图" class="headerlink" title="零件图"></a>零件图</h1><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/bcedc069gy1ft8k8xd9bjj213y0qotcw.jpg" alt="低速级轴零件图"></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/bcedc069gy1ft8k8xzym3j21350qojwo.jpg" alt="斜齿圆柱齿轮零件图"></p><h1 id="设计说明书"><a href="#设计说明书" class="headerlink" title="设计说明书"></a>设计说明书</h1><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/机械设计 课程设计_4.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/机械设计 课程设计_5.jpg" alt=""></p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/机械设计 课程设计_6.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/机械设计 课程设计_7.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/机械设计 课程设计_8.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/机械设计 课程设计_9.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/机械设计 课程设计_10.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/机械设计 课程设计_11.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/机械设计 课程设计_12.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/机械设计 课程设计_13.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/机械设计 课程设计_14.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/机械设计 课程设计_15.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/机械设计 课程设计_16.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/机械设计 课程设计_17.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/机械设计 课程设计_18.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/机械设计 课程设计_19.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/机械设计 课程设计_20.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/机械设计 课程设计_21.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/机械设计 课程设计_22.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/机械设计 课程设计_23.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/机械设计 课程设计_24.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/机械设计 课程设计_25.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/机械设计 课程设计_26.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/机械设计 课程设计_27.jpg" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/机械设计 课程设计_28.jpg" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>机械相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机械设计</tag>
      
      <tag>课程设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>概率论与数理统计笔记</title>
    <link href="/2018/06/23/WHUT/ProbabilityTheoryMathStatistic/"/>
    <url>/2018/06/23/WHUT/ProbabilityTheoryMathStatistic/</url>
    
    <content type="html"><![CDATA[<p>学机器学习前就要弄懂的一门课。</p><p>基于《概率论与数理统计》（第三版），ISBN：978-7-04-044003-4。</p><span id="more"></span><h1 id="概率论部分"><a href="#概率论部分" class="headerlink" title="概率论部分"></a>概率论部分</h1><h2 id="事件的互斥、对立、独立关系"><a href="#事件的互斥、对立、独立关系" class="headerlink" title="事件的互斥、对立、独立关系"></a>事件的互斥、对立、独立关系</h2><ul><li><p>事件的互斥：$A\cap B=\varnothing$ ，就是 A、B 不能同时发生</p></li><li><p>事件的对立：$\overline{A}=\Omega-A$ ，就是这两个有且仅有一个发生</p></li><li><p>事件的独立：满足 $P(AB)=P(A)P(B)$ 的两个事件</p><ul><li><p>若$A,B$ 相互独立，那么 $\overline{A},\overline{B}$ 和 $A,B$ 之间也相互独立</p></li><li><p>若 $A_1,A_2…A_n$ 相互独立，则将任意 m 个事件换成对立事件，形成的新的 n 个事件依然相互独立</p></li><li><p>若 $A_1,A_2…A_n$ 相互独立，则 n 个事件中至少有 1 个发生的概率为</p></li></ul></li></ul><script type="math/tex; mode=display">P(\bigcup\limits_{i=1}^nA_i)=1-P(\prod\limits_{i=1}^{n}\overline{A_i})=1-\prod\limits_{i=1}^{n}[1-P(A_i)]</script><h2 id="事件概率的加法、减法、对偶律"><a href="#事件概率的加法、减法、对偶律" class="headerlink" title="事件概率的加法、减法、对偶律"></a>事件概率的加法、减法、对偶律</h2><ul><li>加法：$P(A\cup B)=P(A)+P(B)-P(AB)$</li><li>减法： $P(A\overline B)=P(A)-P(AB)$</li><li>对偶律：$\overline{AB}=\overline A\cup\overline B,\overline{A\cup B}=\overline A\cap\overline B$</li></ul><blockquote><p>概率性质：（1）非负性$P(A)\geq0$（2）规范性$P(\Omega)=1$（3）有限可加性</p></blockquote><h2 id="古典概型"><a href="#古典概型" class="headerlink" title="古典概型"></a>古典概型</h2><p>古典概型的两个特征：</p><ul><li>试验的样本空间只有有限个元素</li><li>试验中每个基本事件发生概率相同</li></ul><p>若事件 A 含有 k 个基本事件，样本空间有 n 个基本事件，则</p><script type="math/tex; mode=display">P(A)=\frac{k}n</script><blockquote><p>基本事件两两互斥</p></blockquote><p>【例题】将 n 个球放入 N 个盒子中 (n&lt;N)，设盒子的容量不限，求（1）每个盒子至多一球的概率（2）n  个盒子各放一球的概率</p><blockquote><p>（1）$P=\frac{N(N-1)…(N-n+1)}{N^n}$ （2）$P=\frac{C_N^nn!}{N^n}$</p></blockquote><h2 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h2><p>事件 A 在事件 B 的条件下发生的概率为条件概率，记为 $P(A|B)$ ，有</p><script type="math/tex; mode=display">P(A|B)=\frac{P(AB)}{P(B)}</script><p>化简可以得到乘法公式</p><script type="math/tex; mode=display">P(A|B)P(B)=P(AB)</script><h2 id="全概率公式、Bayes公式"><a href="#全概率公式、Bayes公式" class="headerlink" title="全概率公式、Bayes公式"></a>全概率公式、Bayes公式</h2><p>样本空间的划分：设 $\Omega$ 为样本空间，$B_i$ 为样本空间的事件，若有：</p><ul><li>$B_iB_j=\varnothing,i\neq j$</li><li>$\bigcup\limits_{i=1}^{n}B_i=\Omega$</li></ul><p>则称 $B_i$ 为样本空间的一个划分</p><p>全概率公式：</p><script type="math/tex; mode=display">P(A)=\sum\limits_{i=1}^n P(A|B_i)P(B_i)</script><p>Bayes公式：</p><script type="math/tex; mode=display">P(B_i|A)=\frac{P(AB_i)}{P(A)}=\frac{P(A|B_i)P(B_i)}{\sum\limits_{j=1}^nP(A|B_j)P(B_j)}</script><blockquote><p>一般来说：$A$ 为发生的事件，$B_i$ 未发生事件的各个原因</p><p><strong>使用这两个公式，必须有：$B_1B_2=\varnothing,B_1\cup B_2=\Omega$ 之类的条件</strong></p></blockquote><h2 id="分布函数的定义、性质"><a href="#分布函数的定义、性质" class="headerlink" title="分布函数的定义、性质"></a>分布函数的定义、性质</h2><p>随机变量 <em>X</em> 的分布函数为：$F(x)=P(X\leq x)$</p><p>具有以下性质：</p><ul><li>单调不减</li><li>右连续</li><li>$\lim\limits_{x\rightarrow-\infty}F(x)=0,\lim\limits_{x\rightarrow+\infty}F(x)=1$</li></ul><blockquote><p>$P(x_1\leq X\leq x_2)=F(x_2)-F(x_1-0)$</p></blockquote><h2 id="密度函数的定义、性质"><a href="#密度函数的定义、性质" class="headerlink" title="密度函数的定义、性质"></a>密度函数的定义、性质</h2><p>对于连续型随机变量 <em>X</em> ，若有 $F(x)=\int_{-\infty}^xf(t)dt$ ，则$f(x)$ 为概率密度函数</p><p>具有以下性质：</p><ul><li>$f(x)\geq0$</li><li>$\int_{-\infty}^{+\infty}f(x)dx=1$</li><li>$P(x_1\leq X\leq x_2)=\int_{x_1}^{x_2}f(x)dx$</li><li>若 <em>f(x)</em> 连续，则有 $F’(x)=f(x)$</li></ul><h2 id="一维常见的随机变量及其分布函数和分布律或密度函数，概率的计算"><a href="#一维常见的随机变量及其分布函数和分布律或密度函数，概率的计算" class="headerlink" title="一维常见的随机变量及其分布函数和分布律或密度函数，概率的计算"></a>一维常见的随机变量及其分布函数和分布律或密度函数，概率的计算</h2><h3 id="离散型随机变量"><a href="#离散型随机变量" class="headerlink" title="离散型随机变量"></a>离散型随机变量</h3><div class="table-container"><table><thead><tr><th>名称及记号</th><th>分布律</th><th>数学期望</th><th>方差</th><th>解释</th></tr></thead><tbody><tr><td>两点分布</td><td>$P(x=0)=1-p$ $P(x=1)=p$</td><td>$p$</td><td>$p(1-p)$</td><td>随机变量只能取0,1两个值</td></tr><tr><td>二项分布 X~b(n,p)</td><td>$P(x=k)=C_n^kp^k(1-p)^{n-k}$</td><td>$np$</td><td>$np(1-p)$</td><td>将 E 独立重复n次，事件A出现 k 次概率</td></tr><tr><td>泊松分布 X~π(λ)</td><td>$P(x=k)=\lambda^ke^{-\lambda}/k!$</td><td>$\lambda$</td><td>$\lambda$</td><td></td></tr><tr><td>几何分布 X~G(p)</td><td>$P(x=k)=(1-p)^{k-1}p$</td><td>$1/p$</td><td>$(1-p)/p^2$</td><td>成功的概率为p，求首次成功次数为 k 的概率</td></tr></tbody></table></div><blockquote><p><strong>泊松定理：$\lim\limits_{n\rightarrow\infty}C_n^kp^k(1-p)^{n-k}=\lambda^ke^{-\lambda}/k!$</strong>（二项分布的泊松近似）</p></blockquote><h3 id="连续性随机变量"><a href="#连续性随机变量" class="headerlink" title="连续性随机变量"></a>连续性随机变量</h3><div class="table-container"><table><thead><tr><th>名称及记号</th><th>密度函数</th><th>数学期望</th><th>方差</th><th>分布函数</th></tr></thead><tbody><tr><td>均匀分布 X~U(a,b)</td><td>$f(x)=1/(b-a),a\leq x\leq b$</td><td>$(a+b)/2$</td><td>$(b-a)^2/12$</td><td>$F(x)=\frac{(x-a)}{(b-a)},a\leq x\leq b$</td></tr><tr><td>指数分布 X~E(λ)</td><td>$f(x)=\lambda e^{-\lambda x},x&gt;0$</td><td>$1/\lambda$</td><td>$1/\lambda^2$</td><td>$F(x)=1-e^{-\lambda x},x&gt;0$</td></tr><tr><td>正态分布 X~N(μ,σ²)</td><td>$f(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}$</td><td>$\mu$</td><td>$\sigma^2$</td><td>-</td></tr></tbody></table></div><blockquote><p>对指数分布：$P(X&gt;x)=e^{-\lambda x}$</p><p>对正态分布：① 若 X~N(μ,σ²) ，则 Y=(X-μ)/σ~N(0,1) ②</p></blockquote><h2 id="一维随机变量函数的分布的计算"><a href="#一维随机变量函数的分布的计算" class="headerlink" title="一维随机变量函数的分布的计算"></a>一维随机变量函数的分布的计算</h2><blockquote><p><strong>注意取值范围，这是重难点</strong></p></blockquote><p>设随机变量 <em>X</em> 有概率密度 $f_X(x)$ ，函数 $g(x)$ 处处可导且恒有 $g’(x)&gt;0$ 或 小于0，则 $Y=g(X)$ 是连续型随机变量，其概率密度为：</p><script type="math/tex; mode=display">f_Y(y)=f_X[h(y)]|h'(y)|,\alpha<y<\beta</script><ul><li>$h(x)​$ 为 $g(x)​$ 反函数</li><li>$\alpha=\min(g(-\infty),g(+\infty)),\beta=\max(g(-\infty),g(+\infty))$ （其实 $\alpha&lt;y&lt;\beta$ 就是 $g(x)$ 值域）</li></ul><blockquote><p>这是单调的情况。对于非单调的情况，则需要进行分情况讨论，参考例题为课本P64例3</p></blockquote><h2 id="二维离散型随机变量"><a href="#二维离散型随机变量" class="headerlink" title="二维离散型随机变量"></a>二维离散型随机变量</h2><ul><li><p>联合分布函数 $F(x,y)=P(X\leq x,Y\leq y)=\sum\limits_{i=1}^{+\infty}\sum\limits_{j=1}^{+\infty}p_{ij}$</p><ul><li>$F(-\infty,-\infty)=F(-\infty,y)=F(x,-\infty)=0,F(+\infty,+\infty)=1$</li><li>右连续</li><li>对 x,y 单调不减</li></ul></li><li><p>联合分布律 $P(x=i,y=j)=p_{ij},i,j=1,2…$</p></li><li><p>边缘分布函数 $F_X(x)=F(x,+\infty)=\sum\limits_{x_i\leq x}\sum\limits_{j=1}^{+\infty}p_{ij}$ </p></li><li><p>边缘分布率 $p_{i\cdot}=\sum\limits_{j=1}^{+\infty}p_{ij}$</p></li><li><p>若 X,Y <strong>独立</strong>，有 $p_{ij}=p_{i\cdot}p_{\cdot j}$  </p></li><li><p>在 $Y=y_j$ 条件下随机变量 X 的条件分布律 $P(X\leq x|Y=y_j)=\frac{p_{ij}}{p_{\cdot j}}$</p></li></ul><h2 id="二维连续型随机变量的密度函数，边缘密度"><a href="#二维连续型随机变量的密度函数，边缘密度" class="headerlink" title="二维连续型随机变量的密度函数，边缘密度"></a>二维连续型随机变量的密度函数，边缘密度</h2><ul><li>联合分布函数 $F(x,y)=P(X\leq x,Y\leq y)=\int_{-\infty}^x\int_{-\infty}^yf(u,v)dudv$<ul><li>$\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}f(x,y)dxdy=1$</li><li>连续</li><li>对 x,y 单调不减</li><li>若 f(x,y) 在 (x,y) 处连续，有 $\frac{\partial^2F(x,y)}{\partial x\partial y}=f(x,y) $</li></ul></li><li>边缘分布函数 $F_X(x)=F(x,+\infty)=\int_{-\infty}^{x}\int_{-\infty}^{+\infty}f(u,v)dudv$</li><li>边缘分布率 $f_X(x)=\int\limits_Rf(x,y)dy$  </li><li>若 X,Y <strong>独立</strong>，有 $f(x,y)=f_X(x)f_Y(y)$  </li><li>在 $Y=y$ 条件下随机变量 X 的条件分布函数 $F_{X|Y}(x|y)=P(X\leq x|Y=y)=\int_{-\infty}^x\frac{f(x,y)}{f_Y(y)}dy$  ,概率密度 $f_{X|Y}(x|y)=f(x,y)/f_Y(y)$</li></ul><blockquote><p>对于独立，还有以下性质：假设 X,Y 独立 ,若 h(x),g(x) 连续，那么 h(X),g(Y) 也独立</p></blockquote><h2 id="二维正态分布（各参数的意义，边缘分布）"><a href="#二维正态分布（各参数的意义，边缘分布）" class="headerlink" title="二维正态分布（各参数的意义，边缘分布）"></a>二维正态分布（各参数的意义，边缘分布）</h2><p>$(X,Y)\sim(\mu_1,\mu_2,\sigma_1,\sigma_2,\rho)$</p><ul><li>$\rho$ 为 X,Y 的相关系数</li><li>边缘概率密度函数 $f_X=\int_Re^{-(x-\mu_1)^2/2\sigma_1^2}/(\sqrt{2\pi}\sigma_1)$ (也是正态分布)</li></ul><h2 id="简单的二维随机变量函数的分布"><a href="#简单的二维随机变量函数的分布" class="headerlink" title="简单的二维随机变量函数的分布"></a>简单的二维随机变量函数的分布</h2><h3 id="离散型"><a href="#离散型" class="headerlink" title="离散型"></a>离散型</h3><p>分布律为：</p><script type="math/tex; mode=display">P(Z=z_k)=\sum\limits_{g(x_i,y_j)=z_k}p_{ij}</script><p>表示对任何满足 $g(x_i,y_j)=z_k$ 的一切 $(x_i,y_j)$ 的 $p_{ij}$ 求和</p><p>特别的，当 <strong>Z=X+Y</strong> 时，有</p><script type="math/tex; mode=display">P(Z=z_k)=\sum\limits_{i}P(X=x_i,Y=z_k-x_i)</script><p>当 X,Y 独立时，有</p><script type="math/tex; mode=display">P(Z=z_k)=\sum\limits_{i}P(X=x_i)P(Y=z_k-x_i)</script><h3 id="连续型"><a href="#连续型" class="headerlink" title="连续型"></a>连续型</h3><p>分布律为：</p><script type="math/tex; mode=display">F_Z(z)=P(Z\leq z)=\int\limits_{g(x,y)\leq z}f(x,y)dxdy</script><p>表示对任何满足 $g(x_i,y_j)=z_k​$ 的一切 $(x_i,y_j)​$ 的 $p_{ij}​$ 求和</p><p>特别的，当 <strong>Z=X+Y</strong> 时，有</p><script type="math/tex; mode=display">f_Z(z)=\int\limits_{R}f(x,z-x)dx</script><p>当 X,Y 独立时，有</p><script type="math/tex; mode=display">f_Z(z)=\int\limits_{R}f_X(x)f_Y(z-x)dx</script><p>(上式为<strong>卷积公式</strong>)</p><blockquote><p>这里可以引出一个推论：<strong>有限个相互独立的正态分布的线性组合还是正态分布</strong></p></blockquote><h2 id="随机变量的数字特征"><a href="#随机变量的数字特征" class="headerlink" title="随机变量的数字特征"></a>随机变量的数字特征</h2><ul><li><strong>数学期望</strong>：$E=\sum\limits_{i=1}^nxp_{i},E=\int\limits_R xf(x)dx$<ul><li>$E(C)=C$</li><li>$E(\alpha X+\beta Y)=\alpha E(X)+\beta E(Y)$</li><li>若 X,Y 相互<strong>独立</strong>，则 $E(XY)=E(X)E(Y)$</li><li>随机变量函数的数学期望 $E[g(X)]=\sum\limits_{i=1}^ng(x_i)p_i=\int\limits_Rg(x)f(x)dx$ (课本上没有证明过程)，对二维的，也有 $E[g(X,Y)]=\sum\limits_{i=1}^\infty\sum\limits_{j=1}^\infty g(x_i,y_j)p_{ij}=\int\limits_R\int\limits_Rg(x,y)f(x,y)dx$</li></ul></li><li><strong>方差</strong>：$D(X)=Var(X)=E[X-E(X)]^2=\sum\limits_{i=1}^\infty [x_i-E(X)]^2p_{i}=\int\limits_R[x-E(X)]f(x)dx$<ul><li>$D(X)=E(X^2)-E^2(X)$</li><li>$D(C)=0$</li><li>$D(aX+Y)=a^2D(X)$</li><li>$D(X\pm Y)=D(X)+D(Y)+2E([X-E(X)][Y-E(Y)])$</li></ul></li><li><strong>协方差</strong>：$cov(X,Y)=E([X-E(X)][Y-E(Y)])$<ul><li>cov(X,Y) = E(XY) - E(X)E(Y)</li><li>cov(aX,bY) = abcov(X,Y)</li><li>cov(X,Y) = D(X±Y) - [D(X) + D(Y)]</li><li>若 X,Y 相互独立，则 cov(X,Y) = 0</li></ul></li><li><strong>相关系数</strong> $\rho_{XY}=cov(X,Y)/\sqrt{D(X)D(Y)}$<ul><li>$|\rho_{XY}|\leq1$</li></ul></li></ul><h2 id="不相关的几个等价条件"><a href="#不相关的几个等价条件" class="headerlink" title="不相关的几个等价条件"></a>不相关的几个等价条件</h2><blockquote><p><strong>独立 一定 不相关，不相关 不一定 独立</strong></p></blockquote><h2 id="切比雪夫不等式"><a href="#切比雪夫不等式" class="headerlink" title="切比雪夫不等式"></a>切比雪夫不等式</h2><script type="math/tex; mode=display">P(|X-\mu|\leq\varepsilon)>1-\frac{\sigma^2}{\varepsilon^2}</script><p>证明：</p><script type="math/tex; mode=display">P(|X-\mu|\geq\varepsilon)=\int\limits_{|x-\mu|\geq\varepsilon}f(x)dx\leq\int\limits_{|x-\mu|\geq\varepsilon}\frac{|x-\mu|^2}{\varepsilon^2}f(x)dx\leq\frac{1}{\varepsilon^2}\int\limits_R(x-\mu)^2f(x)dx=\frac{\sigma^2}{\varepsilon^2}</script><h2 id="大数定律样本矩收敛于相应的总体矩"><a href="#大数定律样本矩收敛于相应的总体矩" class="headerlink" title="大数定律样本矩收敛于相应的总体矩"></a>大数定律样本矩收敛于相应的总体矩</h2><p>若随机变量 Xi 的数学期望都存在，且满足 $\lim\limits_{n\rightarrow\infty}P(|\frac1n\sum\limits_{i=1}^nX_i-\frac1n\sum\limits_{i=1}^nE(X_i)|&lt;\varepsilon)=1$ 被称为满足大数定理</p><ul><li><p>伯努利大数定理：当 Xi~b(n,p) 时：</p><script type="math/tex; mode=display">\lim\limits_{n\rightarrow\infty}P(|\frac{n_A}n-p|<\varepsilon)=1</script></li><li><p>切比雪夫大数定理：</p></li></ul><script type="math/tex; mode=display">\lim\limits_{n\rightarrow\infty}P(|\overline X-\mu|<\varepsilon)=\lim\limits_{n\rightarrow\infty}P(|\frac1n\sum\limits_{i=1}^nX_i-\frac1n\sum\limits_{i=1}^nE(X_i)|<\varepsilon)=1</script><ul><li>辛勤大数定理：（独立同分布）</li></ul><script type="math/tex; mode=display">\lim\limits_{n\rightarrow\infty}P(|\frac1n\sum\limits_{i=1}^nX_i-\mu|<\varepsilon)=1</script><h2 id="中心极限定理"><a href="#中心极限定理" class="headerlink" title="中心极限定理"></a>中心极限定理</h2><ul><li>独立同分布的随机变量和的标准化当量当 n 足够大时，服从正态分布，即</li></ul><script type="math/tex; mode=display">\frac{\sum\limits_{i=0}^nX_i-n\mu}{\sqrt n\sigma}\sim N(0,1)</script><ul><li>棣莫弗-拉普拉斯中心极限定理</li></ul><script type="math/tex; mode=display">P(a<X<b)=P(\frac{a-np}{\sqrt{np(1-p)}}\leq\frac{X-np}{\sqrt{np(1-p)}}\leq\frac{b-np}{\sqrt{np(1-p)}})\\\approx\Phi(\frac{b-np}{\sqrt{np(1-p)}})-\Phi(\frac{a-np}{\sqrt{np(1-p)}})</script><h1 id="数理统计部分"><a href="#数理统计部分" class="headerlink" title="数理统计部分"></a>数理统计部分</h1><ul><li>t 分布、$\chi^2$分布、F分布的构造及性质；F分布的分位数性质；</li><li>估计量的评选标准：无偏性和有效性；</li><li>参数的矩估计和极大似然估计（离散型和连续型）；</li><li>参数的区间估计（一个正态总体 $\mu$ 和 $\sigma^2$，单侧和双侧）<ul><li>$\mu$ 已知：$(\overline X-u_{\alpha/2}\frac{\sigma}{\sqrt n},\overline X+u_{\alpha/2}\frac{\sigma}{\sqrt n})$</li><li>$\mu$ 未知：$(\overline X-t_{\alpha/2}(n-1)\frac{S}{\sqrt n},\overline X+t_{\alpha/2}(n-1)\frac{S}{\sqrt n})$</li></ul></li><li>假设检验的思想，做法（一个正态总体，单侧及双侧）</li></ul><hr><p>Learning By Sharing，2018©Fu_Qingchen，Markdown，LaTeX</p>]]></content>
    
    
    <categories>
      
      <category>机械相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概率论与数理统计</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>金属工艺学笔记</title>
    <link href="/2018/06/16/WHUT/MetalTechnology/"/>
    <url>/2018/06/16/WHUT/MetalTechnology/</url>
    
    <content type="html"><![CDATA[<p>这玩意全靠背诵记忆，期末捣鼓了好一阵子，当时靠写这玩意来复习了。</p><span id="more"></span><h1 id="金属材料的主要性能"><a href="#金属材料的主要性能" class="headerlink" title="金属材料的主要性能"></a>金属材料的主要性能</h1><h2 id="力学性能"><a href="#力学性能" class="headerlink" title="力学性能"></a>力学性能</h2><p>主要有5个力学性能：强度、塑性、硬度、冲击韧度、疲劳强度</p><h3 id="强度"><a href="#强度" class="headerlink" title="强度"></a>强度</h3><p>指材料在外力作用下抵抗 变形和断裂 的能力</p><p>在<code>静拉伸试验</code>中测定</p><ul><li>弹性极限 $\sigma_e$</li><li>屈服极限 $\sigma_s$ ：此时曲线比较平缓，无需增大外力即可产生变形</li><li>强度极限 $\sigma_b$ ：超过强度极限后，会发生紧缩现象，并断裂</li></ul><h3 id="塑性"><a href="#塑性" class="headerlink" title="塑性"></a>塑性</h3><p>指材料在外力作用下产生塑性变形而不破坏的能力</p><p>在<code>静拉伸试验</code>中测定</p><ul><li>伸长率 $\delta=\frac{\Delta l}{l_0}\times100\%$</li><li>断面伸缩率 $\Psi=\frac{A_0-A}{A_0}\times100\%$</li></ul><h3 id="硬度"><a href="#硬度" class="headerlink" title="硬度"></a>硬度</h3><p>金属材料受压时抵抗局部变形，特别是塑性变形、压痕的能力。即抵抗外力压入其中的能力。</p><ul><li>布氏硬度 $HBS=\frac {P}{\pi D(D-\sqrt{D^2-d^2})} $ （P：加载力；D：压头直径；d压痕直径）。其实就是 载荷/表面积<ul><li>测量方法：将一定质量的球体在一定载荷作用压入试验表面一段时间，测量压痕得出</li><li>优缺点：准确性高当对金属伤害大</li><li>取值为8~650HBW</li></ul></li><li>洛氏硬度 $HRC$<ul><li>测量方法：用120°锥角金刚石压头，先后施加预载荷和总载荷（预载荷+主载荷），随后撤去主载荷，测量压痕深度。</li><li>优缺点：简单方便，可用于成品，但精度不高</li><li>一般高速钢的硬度在62~66HRC</li></ul></li></ul><p>换算关系：$HRC = 52.76-\sqrt{(103500000-218600HB)/HB^2}$</p><h3 id="冲击韧度"><a href="#冲击韧度" class="headerlink" title="冲击韧度"></a>冲击韧度</h3><p>材料在冲击载荷作用下抵抗变形和断裂的能力</p><p>冲击韧度：$a_k$，数值越高，韧性越好</p><h3 id="疲劳强度"><a href="#疲劳强度" class="headerlink" title="疲劳强度"></a>疲劳强度</h3><p>材料在交变应力作用下，在远远小于强度极限下发生断裂，而且没有任何征兆</p><p>材料经过无数次应力循环测验而不发生疲劳破坏的最高应力值</p><h3 id="物理化学及工艺性能"><a href="#物理化学及工艺性能" class="headerlink" title="物理化学及工艺性能"></a>物理化学及工艺性能</h3><p>不重要，略</p><h2 id="MOOC-问答"><a href="#MOOC-问答" class="headerlink" title="[MOOC]问答"></a>[MOOC]问答</h2><ul><li>在做材料的拉伸试验时是否一定要做成标准试样？为什么？</li></ul><blockquote><p>需要做成标准试样。 要得到符合标准的强度、塑性指标，就一定要<strong>控制变量</strong>，即试样的长度，截面形状，直径等。不同规格材料受到试验机的拉伸作用，其受力状况不同，这样测出来的数据也就没有意义。</p></blockquote><ul><li>材料刚度与（   ）有关</li></ul><blockquote><p>弹性模量</p></blockquote><h1 id="铁碳合金"><a href="#铁碳合金" class="headerlink" title="铁碳合金"></a>铁碳合金</h1><h2 id="金属及合金的晶体结构"><a href="#金属及合金的晶体结构" class="headerlink" title="金属及合金的晶体结构"></a>金属及合金的晶体结构</h2><h3 id="晶体结构"><a href="#晶体结构" class="headerlink" title="晶体结构"></a>晶体结构</h3><p>金属主要有三种晶体结构</p><div class="table-container"><table><thead><tr><th>晶体类型</th><th>体心立方晶胞</th><th>面心立方晶胞</th><th>密排六方晶胞</th></tr></thead><tbody><tr><td>所含原子数</td><td>8×1/8+1 = 2</td><td>8×1/8+6×1/2 = 4</td><td>12×1/6+2×1/2+3 = 6</td></tr><tr><td>常见物质</td><td>$\alpha-Fe,\delta-Fe,Ti…$</td><td>$\beta-Fe,Cu,Ag,Au,Pt…$</td><td>$Mg,Zn…$</td></tr></tbody></table></div><p>其中，对应的晶胞示意图如下</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823213555.png" alt=""></p><h3 id="金属的结晶"><a href="#金属的结晶" class="headerlink" title="金属的结晶"></a>金属的结晶</h3><p>随着温度的降低，金属的结晶有以下几个过程：</p><p>原子团→形核（有自发的也有外来的）→晶核长大（变为树枝状）→小晶粒→晶粒</p><p><strong>固态向液态转变过程中，会放出结晶潜热，会使冷却曲线出现一段水平段</strong>，如下图（理论）<code>横坐标为时间，纵坐标为温度</code>。在实际上，由于金属有过冷度，因此曲线会下降一部分，如图（实际）。加入其它元素的合金，由于其他元素的影响将不会是直线，而是水平线，如图（合金）。然后可以看出 <strong>合金的结晶是在一个范围内完成的</strong></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823213634.png" alt=""></p><p>晶粒粗细对材料力学性能具有很大的影响：<strong>对同一金属，晶粒越细，其强度、硬度越高；同时塑性和韧性越好</strong></p><blockquote><p><strong>这是因为晶粒越小，晶界表面积越大，晶界越曲折，晶体的变形抗力也就越大，强度硬度也就越高。同时由于晶粒小，晶粒受力比较分散，每个单独的晶粒受力小，塑性变形也就越分散越均匀，因此塑性韧性高。</strong></p></blockquote><p>因此，在工程上，晶粒越小越好，下面有一些细化晶粒的措施：</p><ul><li><strong>提高冷却速度</strong>，增加过冷度，从而增加晶核数量</li><li>在金属浇筑之前，向金属液<strong>加入变质剂或孕育剂</strong>，引入外来晶核，增加晶核数量</li><li>在金属凝固过程中采用机械<strong>振动</strong>、超声波振动、电磁<strong>搅拌</strong>等将长大的树枝状晶核打断，变小</li><li><strong>热处理或塑性加工</strong>，使晶粒变小</li></ul><p>随着温度的降低，金属在 <strong>固态</strong> 下随着温度的变化，会有一种晶格转化为另一种晶格，这种现象就是<strong>同素异构转变</strong></p><p>对于纯铁来说，会有以下转变</p><script type="math/tex; mode=display">Fe(l)^{1538°}\Rightarrow\alpha-Fe^{1394°}\Rightarrow\gamma-Fe^{912°}\Rightarrow\delta-Fe</script><p><em>Fe</em> 会从<strong>体心立方晶胞</strong>变为<strong>面心立方晶胞</strong>最后再变为<strong>体心立方晶胞</strong>。晶体结构发生变化，与晶体的结晶比较类似，也会释放出潜热，在图上出现水平台阶，因此<strong>金属的同素异构体的转变</strong>也叫做<strong>重结晶、二次结晶</strong></p><h3 id="铁碳合金的晶体结构"><a href="#铁碳合金的晶体结构" class="headerlink" title="铁碳合金的晶体结构"></a>铁碳合金的晶体结构</h3><p>按照 Fe 与 C 的作用形式的不同，铁碳合金的组织可以分为<strong>固溶体、金属化合物、机械混合物</strong> 三种类型。</p><h4 id="固溶体"><a href="#固溶体" class="headerlink" title="固溶体"></a>固溶体</h4><p>合金组元通过溶解形成一种成分和性能均匀，且结构与组员之一相同的固相称为<strong>固溶体</strong>。根据溶质原子在溶剂晶格中的位置，可以分为 <strong>替换固溶体和间隙固溶体</strong> （原子半径相差小的就是替换固溶体…）。由于溶剂分子的加入，晶格会发生畸变，导致材料强度硬度升高。</p><h5 id="铁素体（F）"><a href="#铁素体（F）" class="headerlink" title="铁素体（F）"></a>铁素体（F）</h5><p>C 溶解在 $\alpha-Fe$ 中形成的 <strong>间隙固溶体</strong>，通常用符号 <strong>F</strong> 表示</p><p>F 溶 C 极少，固溶强化效果甚微，因此<strong>力学性能与纯铁相近</strong>，表现为：强度硬度低、塑性韧性好</p><h5 id="奥氏体（A）"><a href="#奥氏体（A）" class="headerlink" title="奥氏体（A）"></a>奥氏体（A）</h5><p>C 溶解在 $\gamma-Fe$ 中形成的 <strong>间隙固溶体</strong>，通常用符号 <strong>A</strong> 表示</p><p> $\gamma-Fe$ 的溶碳能力比 $\alpha-Fe$ 高，在1148℃溶解度最高为$W_C=2.11\%$，但是由于固溶体的一些性质， A 还是<strong>强度硬度不高，属性优良</strong> 。同时， <strong>A 为高温组织</strong></p><h4 id="金属化合物"><a href="#金属化合物" class="headerlink" title="金属化合物"></a>金属化合物</h4><p>金属化合物是合金组元互相作用形成的晶格类型和晶格特征<strong>不同于任一组元</strong>的新相</p><h5 id="渗碳体（-Fe-3C-）"><a href="#渗碳体（-Fe-3C-）" class="headerlink" title="渗碳体（${Fe}_3C$）"></a>渗碳体（${Fe}_3C$）</h5><p>Fe 与 C 形成的金属化合物，$W_C=6.69\%$，其 <strong>硬度高，脆性大，塑性差</strong>。渗碳体过多会导致机械性能变差，少量渗碳体会提高材料的强度和硬度。</p><h4 id="机械混合物"><a href="#机械混合物" class="headerlink" title="机械混合物"></a>机械混合物</h4><p>结晶过程中所形成的两相混合组织（前面两个是单相组织，这个直接是两相组织）</p><h5 id="珠光体（P）"><a href="#珠光体（P）" class="headerlink" title="珠光体（P）"></a>珠光体（P）</h5><p>由 F 和 $Fe_3C$ 组成的机械混合物，$W_C=0.77\%$，层片越往细密，强度越高。珠光体兼具两者的优点，即具有较高的硬度、强度和良好的塑性、韧性</p><h5 id="莱氏体（Ld）"><a href="#莱氏体（Ld）" class="headerlink" title="莱氏体（Ld）"></a>莱氏体（Ld）</h5><p>由 A或P 和 $Fe_3C$ 组成的机械混合物，$W_C=4.33\%$</p><h2 id="铁碳合金相图"><a href="#铁碳合金相图" class="headerlink" title="铁碳合金相图"></a>铁碳合金相图</h2><p>注图中1128应该改为1148，$Ld_H$为高温莱氏体，$Fe_3C_1$为一次渗碳体</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823213647.png" alt=""></p><h3 id="点的含义"><a href="#点的含义" class="headerlink" title="点的含义"></a>点的含义</h3><div class="table-container"><table><thead><tr><th style="text-align:center">代号</th><th style="text-align:center">温度(℃)</th><th style="text-align:center">含碳量(%)</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center">1538</td><td style="text-align:center">0</td><td style="text-align:center">铁的熔点</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">1148</td><td style="text-align:center">4.3</td><td style="text-align:center">共晶点，发生共晶反应，由液态直接变为固态，$L\Rightarrow Ld_H(A+Fe_3C)$</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">1127</td><td style="text-align:center">6.69</td><td style="text-align:center">渗碳体的熔点</td></tr><tr><td style="text-align:center">E</td><td style="text-align:center">1148</td><td style="text-align:center">2.21</td><td style="text-align:center">C在 $\gamma-Fe$ 的最大溶解度</td></tr><tr><td style="text-align:center">F</td><td style="text-align:center">1148</td><td style="text-align:center">6.69</td><td style="text-align:center">渗碳体的成分</td></tr><tr><td style="text-align:center">G</td><td style="text-align:center">912</td><td style="text-align:center">0</td><td style="text-align:center">$\gamma-Fe\Leftrightarrow\alpha-Fe$同素异构体转变点</td></tr><tr><td style="text-align:center">S</td><td style="text-align:center">727</td><td style="text-align:center">0.77</td><td style="text-align:center">共析点，发生共析反应，$A\Rightarrow P(F+Fe_3C)$</td></tr></tbody></table></div><p>注：</p><ul><li>共晶反应：由液态直接变为固态，$L\Rightarrow Ld_H(A+Fe_3C)$，只有与共晶点成分相同的才会发生共晶反应</li><li>共析反应：由一种固相变为另外一种固相，$A\Rightarrow P(F+Fe_3C)$，只有与共析点成分相同的才会发生共析反应</li></ul><blockquote><p>注意：各个点的符号要求记住</p></blockquote><h3 id="线的分析"><a href="#线的分析" class="headerlink" title="线的分析"></a>线的分析</h3><ul><li><p>ACD：液相线，ACD以上全是液体，冷却至ACD以下开始结晶。</p></li><li><p>AECF：固相线，AECF以下全为固体，加热至AECF以上开始熔化。</p></li><li><p>ECF：共晶线，发生共晶反应的区域，$W_C=2.11\%-6.69\%$可以发生共晶反应</p><blockquote><p>EC段会发生共晶反应的原因：在冷却过程中会析出 A ，而 A 的含碳量比较少，此时剩余部分的含碳量会增加，导致达到 C点，这样就可以发生共晶反应了。同理CF段也是这样。</p></blockquote></li><li><p>共析线：发生共析反应的区域，$W_C=0.02\%-6.69\%$可以发生共析反应，原因同上</p></li><li><p>GS：不同含碳量 A 冷却时析出 F 的线，<strong>也叫 $A_3$ 线</strong>。下面那条是 F 析出的终止线</p></li><li><p>ES：C在 A 中溶解度曲线，<strong>也叫 $A_{cm} $ 线</strong></p></li></ul><h3 id="相图中的铁碳合金分类"><a href="#相图中的铁碳合金分类" class="headerlink" title="相图中的铁碳合金分类"></a>相图中的铁碳合金分类</h3><div class="table-container"><table><thead><tr><th style="text-align:center">含碳量</th><th style="text-align:center">&lt;0.77%</th><th style="text-align:center">0.77%</th><th style="text-align:center">0.77%~2.11%</th><th style="text-align:center">2.11%~6.69%</th></tr></thead><tbody><tr><td style="text-align:center">类别</td><td style="text-align:center">亚共析钢</td><td style="text-align:center">共析钢</td><td style="text-align:center">过共析钢</td><td style="text-align:center">铸铁</td></tr><tr><td style="text-align:center">室温成分</td><td style="text-align:center">$F+P$</td><td style="text-align:center">$P$</td><td style="text-align:center">$P+Fe_3C$</td><td style="text-align:center">有$Ld$</td></tr></tbody></table></div><h3 id="碳对铁碳合金力学性能的影响"><a href="#碳对铁碳合金力学性能的影响" class="headerlink" title="碳对铁碳合金力学性能的影响"></a>碳对铁碳合金力学性能的影响</h3><p>如图，<strong>随着含碳量的增加，强度先升高后下降，硬度上升，塑性韧性下降</strong></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823213659.png" alt=""></p><p>注：在室温下，含碳0.8%的钢其强度比含碳1.2%的钢高。</p><blockquote><p>铁碳合金中渗碳体是强化相，对于以<strong>铁素体为基体</strong>的钢来说，渗碳体的数量愈多，分布愈均匀，其强度愈高。但随着含碳量的增加，<strong>Fe3C以网状分布于晶界上或呈粗大片状</strong>，尤其是作为基体时就使得铁碳合金的强度、塑性、韧性大大下降。</p></blockquote><h2 id="常见金属材料及选用"><a href="#常见金属材料及选用" class="headerlink" title="常见金属材料及选用"></a>常见金属材料及选用</h2><h3 id="金属杂质对钢性能的影响"><a href="#金属杂质对钢性能的影响" class="headerlink" title="金属杂质对钢性能的影响"></a>金属杂质对钢性能的影响</h3><h4 id="P、S"><a href="#P、S" class="headerlink" title="P、S"></a>P、S</h4><p><strong>有害元素，可以使材料的塑性韧性急速下降</strong></p><p>S会使 Fe 在1000~1200℃压力加工时，使晶粒脱开，发生 <strong>热脆</strong> 现象</p><p>P会使钢的塑性韧性急速下降，转化温度升高，发生 <strong>冷脆</strong> 现象</p><h4 id="Mn、Si"><a href="#Mn、Si" class="headerlink" title="Mn、Si"></a>Mn、Si</h4><p><strong>Mn 可以与 S 结合成 MnS，抵消 S 的有害作用</strong></p><p>Si 溶于 F 中，可以使铁素体强化</p><h3 id="碳素钢"><a href="#碳素钢" class="headerlink" title="碳素钢"></a>碳素钢</h3><h4 id="碳钢的分类"><a href="#碳钢的分类" class="headerlink" title="碳钢的分类"></a>碳钢的分类</h4><p>铁碳合金中，碳质量分数小于2.11%的合金称为钢，常用的碳钢 W(C) 一般都小于1.3%。</p><ul><li>按 W(C) 分<ul><li>低碳钢： W(C) ≤ 0.25%</li><li>中碳钢：0.25% ≤ W(C) ≤ 0.6%</li><li>高碳钢：0.6% ≤ W(C) ≤ 2.1%</li></ul></li><li>按 钢的质量 分<ul><li>普通碳素钢：w（S）≤0.055%； w（P）≤0.045%</li><li>优质碳素钢：w（S）≤0.040%； w（P）≤0.040%</li><li>高级优质碳素钢：w（S）≤0.030%； w（P）≤0.035%</li></ul></li><li>按 用途 分<ul><li>碳素结构钢</li><li>优质碳素结构钢</li><li>碳素工具钢</li></ul></li></ul><h4 id="碳素结构钢"><a href="#碳素结构钢" class="headerlink" title="碳素结构钢"></a>碳素结构钢</h4><p>碳素结构钢的含碳量wc&lt;0.38%，而以wc&lt;0.25%的最常见，即以<strong>低碳钢</strong>为主。</p><p>碳素结构钢的牌号用 <strong>Q+数字</strong> 表示，Q代表屈服点的“屈”字汉语拼音首字母，后面的三位数字表示该钢种厚度小于16mm时的<strong>最低屈服强度（MPa）</strong>。<code>如Q235表示屈服强度为235MPa的碳素结构钢</code>。在钢号尾部可用A、B、C、D表示钢的质量等级，<strong>A级钢含硫、磷含量最高，D级含硫、磷含量最低</strong>。若在牌号后面加注字母 <strong>“F”</strong> 则为<strong>沸腾钢</strong>，标注 <strong>“B”</strong> 为<strong>半镇静钢</strong>，<strong>不标注</strong>“F”或“B”者为<strong>镇静钢</strong>。</p><p><strong>碳素结构钢一般在供应状态下使用，不再进行热处理</strong>，常见的碳素结构钢有：Q195、Q215，Q235A、Q235B、Q255、Q275等</p><h4 id="优质碳素结构钢"><a href="#优质碳素结构钢" class="headerlink" title="优质碳素结构钢"></a>优质碳素结构钢</h4><p>其硫、磷含量较低（&lt;0.035%），供货时既保证化学成分，又保证力学性能，主要用于制造机器零件。</p><p>优质碳素结构钢的钢号用平均碳质量分数的 <strong>万分数</strong> 表示。<code>如20钢表示平均含碳量为0.20%的优质碳素结构钢</code>。若钢中<strong>锰含量较高</strong>，钢号后应加符号 <strong>“Mn”</strong>，<code>如15Mn，45Mn等</code>。</p><p><strong>优质碳素结构钢使用前一般都要经过热处理。</strong>08F——塑性好，可制造冷冲压零件。10、20钢——冷冲压性与焊接性能良好，可用作冲压件和焊接件，经热处理（<strong>渗碳+淬火+回火</strong>）可制造轴、销等零件（表面要求耐磨的）。35、40、45、50钢——属于中碳钢，因钢中珠光体含量增多，其强度、硬度有所提高，而<strong>淬火+低温回火</strong>后的硬度提高明显。60、65钢——属于高碳钢，经淬火、回火后，不仅强度、硬度显著提高，且弹性优良，常用于制造小弹簧、发条、钢丝绳、轧辊、凸轮等；此类钢的热处理方式：<strong>淬火+中温回火</strong>。</p><h4 id="碳素工具钢"><a href="#碳素工具钢" class="headerlink" title="碳素工具钢"></a>碳素工具钢</h4><p>碳素工具钢的碳质量分数在0.65%~1.35%之间</p><p>钢号用平均碳质量分数的<strong>千分数</strong>的数字表示，数字之前加 <strong>“T”</strong>（碳的拼音首字母）。<code>如：T9表示碳质量分数为0.9%（即千分之九）的碳素工具钢</code>。碳素工具钢均为优质钢，若硫、磷含量更低，为<strong>高级优质钢</strong>，则在钢号后面标注 <strong>“A”</strong> 字。<code>如：T12A表示碳质量分数为1.2%的高级优质碳素工具钢</code>。</p><p>碳素工具钢较合金工具钢便宜，但<strong>淬透性</strong>和<strong>热硬性</strong>差。<strong>碳素工具钢使用前都要经过热处理，如淬火+低温回火。</strong></p><h3 id="合金钢"><a href="#合金钢" class="headerlink" title="合金钢"></a>合金钢</h3><p>合金钢可以避免碳钢以下部分的不足：<strong>渗透性低、强度低、回火稳定性差、不能满足特殊性能要求</strong></p><p>合金钢按用途分（我国采用）：合金结构钢、合金工具钢、特殊性能钢</p><p>合金钢的编号：</p><ol><li><p>碳的质量分数：在牌号首部用数字标明碳质量分数。</p><ul><li><p>结构钢</p><p>以万分之一为单位的数字（两位数）表示平均碳质量分数。<code>40Cr 平均碳质量分数为0.40%;20CrMnTi 平均碳质量分数为0.20%</code></p></li><li><p>工具钢</p><p>以千分之一为单位的数字（一位数）表示平均碳质量分数。工具钢的<br>碳质量分数超过1%时，碳质量分数不标出。<code>5CrMnMo 平均碳质量分数为0.5%；Cr2 平均碳质量分数为1.0%</code></p></li><li><p>不锈钢和耐热钢</p><p>碳质量分数大于或等于0.04%时，以万分之一为单位的数字（两位数）表示；碳质量分数小于或等于0.03%时，以十万分之一为单位的数字（三位数）表示。<code>12Cr13 平均碳质量分数为0.12%;022Cr22Ni5Mo3N 平均碳质量分数为0.022%</code></p></li></ul></li><li><p>主要合金元素</p><p>用元素符号表明钢中主要合金元素，其后标明质量分数。质量分数少于1.5%时不标数字，质量分数为1.5%-2.49%、2.5%-3.49%…时，相应地标2、3…。<code>40Cr Cr的质量分数在1.5%以下;5CrMnMo Cr、Mn、Mo的质量分数均在1.5%以下;60Si2Mn Si的质量分数为1.5~2.0% ，Mn质量分数均为0.7~1.0%</code></p></li></ol><h4 id="低合金高强度结构钢"><a href="#低合金高强度结构钢" class="headerlink" title="低合金高强度结构钢"></a>低合金高强度结构钢</h4><p>高强度、高韧性、良好的焊接性能和冷成型性能、低的冷脆转变温度、良好的耐蚀性。</p><h5 id="成分特点"><a href="#成分特点" class="headerlink" title="成分特点"></a>成分特点</h5><ul><li>低碳：韧性、焊接性和冷成型性能要求高，碳质量分数不超过0.20%。</li><li>加入以锰为主的合金元素。锰可以产生较强的固溶强化效果（溶入F），还可以大大降低奥氏体分解温度，细化F晶粒，并使珠光体变细，消除晶界上粗大的片状碳化物，提高钢的强度和韧性。</li></ul><ul><li>加入铌、钛或钒等元素：形成细碳化物或氮化物，获得细小铁素体晶粒，提高钢的强度和韧性。</li><li>加入少量的铜（0.4%）和磷（0.1%左右），可提高抗腐蚀性能。</li><li>加入少量的稀土元素，可脱硫、去气，使钢材净化，改善韧性和工艺性能。</li></ul><h5 id="常用的低合金高强度结构钢"><a href="#常用的低合金高强度结构钢" class="headerlink" title="常用的低合金高强度结构钢"></a>常用的低合金高强度结构钢</h5><ul><li><strong>Q345（16Mn）</strong><ul><li>使用状态组织：细晶粒铁素体+索氏体。</li><li>强度比普通碳素结构钢Q235高约20%-30%，耐大气腐蚀性能高20-38%，用来制造结构件时，重量可减轻20~30%</li></ul></li></ul><ul><li><p><strong>Q420（15MnVN）</strong></p><p>强度较高。 加入V、N后，生产钒的氮化物，可细化晶粒，又有析出强化的作用，强度较高，韧性、焊接性及低温韧性较好。可制造桥梁、锅炉、船舶等大型结构。 </p></li></ul><h2 id="MOOC-问答-1"><a href="#MOOC-问答-1" class="headerlink" title="[MOOC]问答"></a>[MOOC]问答</h2><ul><li>对同一成分的金属，晶粒越细，其强度、硬度愈高，为什么塑性和韧性也越好。对一般的材料，强度、硬度增加，塑性、韧性会降低。</li></ul><blockquote><p>晶粒越细，晶界就越多，晶界处的晶格排列方向极不一致，犬牙交错、互相咬合，从而增加了塑性变形的抗力，提高了金属的强度。同时，金属的塑性和韧性也可得到提高。</p></blockquote><ul><li>根据Fe-C相图，解释以下现象<ol><li>在室温下，含碳0.8%的钢其强度比含碳1.2%的钢高。</li><li>在1100℃，含碳0.4%的钢能进行锻造，含碳4.0%的生铁不能锻造。</li></ol></li></ul><blockquote><p>(1)含碳量大于1.0%时，钢组织中析出的二次渗碳体在晶界形成连续的网络状，钢的脆性增加，强度下降。因此含碳0.8%的钢的强度高于含碳1.2%的钢。<br>(2)含碳量0.4%的钢在1100℃时处于A区，容易发生塑性变形。适于锻造。含碳量4%的生铁在1100℃时，组织是由Ld和Fe3C组成，硬度高硬，脆性大，塑性变形能力差，因而不能锻造。</p></blockquote><h1 id="金属材料热处理"><a href="#金属材料热处理" class="headerlink" title="金属材料热处理"></a>金属材料热处理</h1><p>热处理是将钢在固态下以一定的方式进行 <strong>加热</strong> 、 <strong>保温</strong> ，然后采取合适的方式 <strong>冷却</strong> ，让其获得所需要的组织结构和性能的工艺。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823213712.png" alt=""></p><h2 id="钢在加热时的组织转变"><a href="#钢在加热时的组织转变" class="headerlink" title="钢在加热时的组织转变"></a>钢在加热时的组织转变</h2><p>大多数热处理工艺（如淬火、正火等）都要将钢加热到临界温度以上，获得全部或部分奥氏体组织，即进行<strong>奥氏体化</strong>。</p><p>然后在实际的热处理过程中：铁碳合金相图和上面说的有所不同，上面的铁碳合金相图是充分反应状态下的情况，在实际过程中，<strong>处理的时间是有限的</strong>。因此实际上会有变化。<strong>加热到原来的组织需要更高的温度</strong>，因此加热的线比原来高（如红线），同理降温的线比原来低（如南线）。这个现象叫<strong>过热</strong>和<strong>过冷</strong> </p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823213724.png" alt=""></p><h3 id="影响-A-转变速度的因素"><a href="#影响-A-转变速度的因素" class="headerlink" title="影响 A 转变速度的因素"></a>影响 A 转变速度的因素</h3><ul><li><p>加热温度  $T\uparrow\Rightarrow v(A)\uparrow$</p></li><li><p>加热速度 $\Delta v_T\uparrow\Rightarrow v(A)\uparrow$</p></li><li><p>钢中碳质量分数 $W(C)\uparrow\Rightarrow S\uparrow\Rightarrow v(A)\uparrow$</p></li><li><p>原始组织 </p><p>原始组织中渗碳体为<strong>片状</strong>时，<strong>奥氏体形成速度快</strong>，因为它的<strong>相界面积较大</strong>；并且，渗碳体间距越小，相界面越大，同时奥氏体晶粒中碳浓度梯度也大，所以长大速度更快。</p></li></ul><h3 id="奥氏体的晶粒度及其影响因素"><a href="#奥氏体的晶粒度及其影响因素" class="headerlink" title="奥氏体的晶粒度及其影响因素"></a>奥氏体的晶粒度及其影响因素</h3><p>晶粒度就是晶粒大小。晶粒度越小，金属强度硬度韧性塑形越好。生产中一般采用标准晶粒度等级图，由比较的方法来<strong>测定钢的奥氏体晶粒大小</strong>。</p><p><strong>加热温度越高，保温时间越长，晶粒度越大，材料性能越差</strong>。奥氏体中碳的含量增高时，晶粒长大的倾向增多。若碳以未溶碳化物的形式存在，则它有阻碍晶粒长大的倾向。 </p><h3 id="钢在冷却时的组织转变"><a href="#钢在冷却时的组织转变" class="headerlink" title="钢在冷却时的组织转变"></a>钢在冷却时的组织转变</h3><p>从铁碳合金相图可知，当温度在A1以上时，奥氏体是稳定的，能长期存在。当温度降到A1以下时，奥氏体即处于过冷状态，这种奥氏体称为<strong>过冷奥氏体</strong>。过冷奥氏体是不稳定的，它会转变为其他组织，钢在冷却时的转变，实质上是过冷奥氏体的转变。</p><p>过冷奥氏体的等温转变过程和转变产物可用<strong>等温转变曲线</strong>（<strong>TTT曲线</strong>）:</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823213758.png" alt=""></p><p>奥氏体从过冷到转变开始这段时间称为<strong>孕育期</strong>，孕育期的长短反映了过冷奥氏体的稳定性大小。曲线的“鼻尖”处（约550℃）孕育期最短，过冷奥氏体的稳定性最小。</p><p>可以看到，等温转变曲线被分为三块：高温转变区（珠光体转变区）、中温转变区（贝氏体转变区）、低温转变区（马氏体转变区）</p><p>在高温转变区内，根据珠光体的形态，又分为：粗片状P; 15～22HRC、细片状P[ <strong>索氏体S</strong> ]; 22～27HRC、极细片状P[ <strong>屈氏体T</strong> ];27～43HRC。奥氏体向珠光体转变是一种<strong>扩散</strong>型的生核、长大过程，是通过碳、铁的扩散和晶体结构的重构来实现的。</p><p>贝氏体转变是介于珠光体和马氏体转变之间的一种转变，又称中温转变。转变产物为贝氏体（B）是<strong>含 C 过饱和的 F 和碳化物的机械混合物</strong>。由于温度降低， $\gamma-Fe$ 转变为了 $\alpha-Fe$ ，发生了重结晶，使C从F中析出。<strong>共析钢与过共析钢没有贝氏体转变区</strong>（因为没有 F ）。</p><p>马氏体型(M)转变( 230～-50℃ ): <strong>M 是一种 C 在 α–Fe 中的过饱和 间隙固溶体。</strong>有以下转变特点:①在一个温度范围内<strong>连续</strong>冷却完成;②转变<strong>速度极快</strong>,即瞬间形核与长大;③无扩散转变( Fe、C原子均不扩散 ), M与原A的成分相同,造成晶格畸变；④转变不完全性, 冷却到室温时仍残余奥氏体存在-50℃才转变完全。</p><h3 id="奥氏体连续冷却转变"><a href="#奥氏体连续冷却转变" class="headerlink" title="奥氏体连续冷却转变"></a>奥氏体连续冷却转变</h3><h4 id="CCT曲线"><a href="#CCT曲线" class="headerlink" title="CCT曲线"></a>CCT曲线</h4><p>这个曲线下面有，这里就不画了。与TTT曲线比较，CCT图中的所有曲线均向右下“漂移”；所有转变均呈现“滞后”现象。同时，CCT曲线中的 P 和 B 的“C”形曲线也只有上半部分。相变滞后现象可能导致贝氏体转变被抑制。</p><blockquote><p>这是因为 F 析出使 A 碳的质量分数升高，因而开始转变线线右端下降</p></blockquote><h4 id="连续冷却转变产物"><a href="#连续冷却转变产物" class="headerlink" title="连续冷却转变产物"></a>连续冷却转变产物</h4><p>由于共析钢在连续冷却时的转变测定较困难，生产中常利用TTT曲线分析估计连续冷却转变的结果，即按TTT与CCT曲线叠加后相交的大致位置，估计连续冷却后得到的组织。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823213813.png" alt=""></p><div class="table-container"><table><thead><tr><th style="text-align:center">冷速类型</th><th style="text-align:center">冷却方法</th><th style="text-align:center">转变产物</th><th style="text-align:center">硬度</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">$v_1$</td><td style="text-align:center">相当于炉冷</td><td style="text-align:center">P</td><td style="text-align:center">15-25HRC</td><td style="text-align:center">过冷A转变为P</td></tr><tr><td style="text-align:center">$v_2$</td><td style="text-align:center">相当于空冷</td><td style="text-align:center">S</td><td style="text-align:center">25-35HRC</td><td style="text-align:center">过冷A转变为S</td></tr><tr><td style="text-align:center">$v_3$</td><td style="text-align:center">相当于油冷</td><td style="text-align:center">T+M+A</td><td style="text-align:center">45-55HRC</td><td style="text-align:center">尽管穿过了贝氏体区，但因在CCT曲线中无B转变区，所以在连续冷却时不会得到B组织，而会转变为T、M和残余A的混合组织</td></tr><tr><td style="text-align:center">$v_k$</td><td style="text-align:center">相当于油冷或水冷</td><td style="text-align:center">M+A</td><td style="text-align:center">55-65HRC</td><td style="text-align:center">过冷奥氏体转变为M和残余A</td></tr><tr><td style="text-align:center">$v_4$</td><td style="text-align:center">相当于水冷</td><td style="text-align:center">M+A</td><td style="text-align:center">55-65HRC</td><td style="text-align:center">过冷奥氏体转变为M和残余A</td></tr></tbody></table></div><h2 id="热处理工艺方法"><a href="#热处理工艺方法" class="headerlink" title="热处理工艺方法"></a>热处理工艺方法</h2><p>分为整体热处理（退火、正火、淬火、回火）、表面热处理、化学热处理</p><h3 id="退火"><a href="#退火" class="headerlink" title="退火"></a>退火</h3><p>将钢加热至临界温度，保温一段时间，然后埋入导热性较差的物质，缓慢冷却，以得到平衡状态组织的热处理工艺</p><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><ul><li>降低硬度、提高塑性，以利于切削加工或继续冷变形加工</li><li>细化晶粒，提高钢的塑性和韧性</li><li>消除内应力，为淬火供需做好准备</li></ul><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823213828.png" alt=""></p><p><strong>注：图中完全退火冷却时的斜率搞反了</strong></p><h4 id="完全退火"><a href="#完全退火" class="headerlink" title="完全退火"></a>完全退火</h4><p>钢加热到Ac3线以上30～50℃，保温一定时间而获得完全的 A 组织，然后随炉冷却到500℃以下，再出炉并在空气中冷却，最终获得平衡组织 <strong>F+P</strong>。</p><p>作用是：提高塑性韧性，降低硬度，改善切削加工性能</p><p>主要应用与 <strong>亚共析钢</strong> ，过共析钢不宜使用。</p><blockquote><p>这是由于过共析钢缓冷时会析出二次网状渗碳体，大大降低材料的属性和韧性，可能在之后的加工中开裂</p></blockquote><h4 id="球化退火"><a href="#球化退火" class="headerlink" title="球化退火"></a>球化退火</h4><p>是将钢件加热到Acl线以上20～30℃，保温较长时间，然后以极其缓慢的速度冷却到600℃以下，再出炉空冷的热处理工艺。</p><p>保留较多的未溶碳化物粒子或使较大的奥氏体中碳浓度分布不均匀，促进球化物的生成，将 <strong>网状渗碳体</strong> 转化为 <strong>球状渗碳体</strong>。</p><p>主要应用于 <strong>过共析钢</strong>，用来降低硬度，改善切削加工性能，为淬火做准备</p><h4 id="再结晶退火"><a href="#再结晶退火" class="headerlink" title="再结晶退火"></a>再结晶退火</h4><p>再结晶退火(recrystallization annealing) 是将钢件加热到再结晶温度以上150～250℃，即650～750℃范围内，保温一定时间后<strong>随炉冷却</strong>，通过再结晶使钢材的<strong>塑性恢复</strong>到冷变形以前的状况。</p><p>低温再结晶退火可用于冷轧、冷拉、冷压等产生<strong>加工硬化</strong>的各种金属材料处理。</p><h4 id="去应力退火"><a href="#去应力退火" class="headerlink" title="去应力退火"></a>去应力退火</h4><p>去应力退火(stress relieving) 是将钢件<strong>随炉缓慢加热</strong>(100～150℃/h)至500～650℃，保温一定时间，然后<strong>随炉</strong>缓慢冷却(50～100℃/h)至300～200℃以下再出炉<strong>空冷</strong>。</p><p>目的是 <strong>消除</strong> 铸造、锻造、焊接等中的 <strong>内应力</strong> 。<strong>去应力退火不发生组织转变</strong> 。</p><h4 id="等温退火"><a href="#等温退火" class="headerlink" title="等温退火"></a>等温退火</h4><p>（课本上没有）</p><p>是将钢件加热到Ac3线以上(对亚共析钢)或Ac1线以上(对共析钢和过共析钢)，保温后较快冷却到稍低于Ac1线温度，即珠光体型转变温度范围内，一直等温保持到奥氏体<strong>全部转变为 珠光体</strong> 型组织为止，然后出炉置空气中冷却。</p><p>等温退火与完全退火目的、加热方法及保温时间基本相同，但可通过控制等温温度，更快获得所需的均匀组织和性能，退火效果较好，并可大大<strong>缩短</strong>约一半以上的退火<strong>时间</strong>，主要用于奥氏体较稳定的<strong>合金工具钢和高合金钢</strong>等</p><h3 id="正火"><a href="#正火" class="headerlink" title="正火"></a>正火</h3><p>正火是将钢件加热至Ac3(对亚共析钢)或Accm(对过共析钢)以上30～50℃，经保温后从炉中取出并在空气中冷却的热处理工艺。正火冷却速度稍快，过冷度较大，可获得较细的 <strong>珠光体型索氏体</strong> 组织。</p><h4 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h4><ul><li>对于普通碳素钢、低合金钢，正火可以细化晶粒，并使组织均匀化；</li><li>提高低碳钢工件的硬度和切削加工性能；</li><li><strong>消除过共析钢中的网状碳化物</strong>，为球化退火或淬火作准备；</li><li>消除切削加工后的硬化现象和去除内应力；</li></ul><blockquote><p>关于退火与正火的选择：退火比正火的生产周期短，耗能少，且操作简便，故在可能的条件下，应优先考虑以退火代替正火。 </p></blockquote><h3 id="淬火"><a href="#淬火" class="headerlink" title="淬火"></a>淬火</h3><p>淬火是将钢加热到Ac3(亚共析钢)或Ac1(共析或过共析钢)以上即30～50℃间，保温一定时间使其奥氏体化，然后在冷却介质中迅速冷却的热处理工艺。</p><p>淬火的目的：获得 M(马氏体) (个别情况下获得 B )组织，以提高钢的硬度和耐磨性，如各种工模具、量具、滚动轴承等均需通过淬火提高硬度和耐磨性。</p><blockquote><p>过饱和的碳造成了 <strong>M 晶格的严重畸变</strong>，使其变形抗力比较大，因此 M 具有较高的耐磨性和硬度。绝大多数要求高硬度和高耐磨性的中高碳钢都要进行淬火工艺</p></blockquote><p>淬火是一种复杂的热处理工艺，又是决定产品质量的关键工序之一，淬火后要<strong>得到小的马氏体组织</strong>又<strong>不致产生严重的变形和开裂</strong>，必须根据钢的成分、零件的大小、形状等，结合C曲线合理地确定淬火加热和冷却的方法。</p><h4 id="淬火加热温度的确定"><a href="#淬火加热温度的确定" class="headerlink" title="淬火加热温度的确定"></a>淬火加热温度的确定</h4><div class="table-container"><table><thead><tr><th style="text-align:center">钢种</th><th style="text-align:center">温度</th></tr></thead><tbody><tr><td style="text-align:center">亚共析钢</td><td style="text-align:center">$A_{c3}$ + (30-50) ℃</td></tr><tr><td style="text-align:center">共析钢、过共析钢</td><td style="text-align:center">$A_{c1}$ + (30-50) ℃</td></tr><tr><td style="text-align:center">一般合金钢</td><td style="text-align:center">$A_{c1}$ 或 $A_{c3}$ + (30-50) ℃</td></tr></tbody></table></div><h4 id="淬火冷却介质的选择"><a href="#淬火冷却介质的选择" class="headerlink" title="淬火冷却介质的选择"></a>淬火冷却介质的选择</h4><p>淬火介质的冷却速度又不能过快，在满足能获得马氏体的条件下，应使冷却速度尽可能低，以减少工件的开裂和变形。</p><blockquote><p><strong>冷却速度：盐水 &gt; 水 &gt; 盐浴 &gt; 油</strong></p></blockquote><h4 id="淬火方法的选择"><a href="#淬火方法的选择" class="headerlink" title="淬火方法的选择"></a>淬火方法的选择</h4><p>这里需要考虑到零件是有厚度的，零件内部各个地方温度不一样</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823213843.png" alt=""></p><ul><li><strong>单介质淬火</strong>是将奥氏体化后的工件放入一种淬火介质中连续冷却到室温的淬火方法，如碳钢在水中淬火，合金钢在油中淬火，操作简单，易于实现机械化与自动化，适用于形状简单的工件。</li><li><strong>双介质淬火</strong>是将奥氏体化工件先放入一种冷却能力较强的介质中，当工件冷到300℃左右时，再放到另外一种冷却能力较弱的介质中冷却。如先水冷后油冷、先水冷后空冷或先油冷后空冷等。双介质淬火法的马氏体转变是在冷却能力较低的介质中进行，故产生的内应力较小，可减小变形和开裂的可能性，常用于形状较复杂的工件，如碳素工具钢中的钻头、铰刀。</li><li><strong>分级淬火</strong>是将奥氏体化工件放入温度稍高于Ms点(约260℃)的冷却介质(盐浴或碱浴)中，停留2～5 min，使工件内外温度达到均匀后取出空冷，以获得马氏体组织，此法仅适用于截面尺寸较小(或厚度小于10mm)的工件。</li><li><strong>等温淬火</strong>是将奥氏体化工件放入温度稍高于Ms温度(260～400℃)的盐浴中等温一定时间，使过冷奥氏体转变为强度高、韧性好的<strong>下贝氏体</strong>，然后再用空气中冷却的淬火方法。此法只应用于尺寸要求精确、形状复杂、有较高强韧性的小型工件及工模具，如弹簧、小齿轮及丝锥等。</li></ul><h4 id="钢的淬透性"><a href="#钢的淬透性" class="headerlink" title="钢的淬透性"></a>钢的淬透性</h4><p>淬透性是指钢在淬火时 <strong>获得马氏体</strong> 的能力, 它是钢的固有属性，取决于钢的临界冷却速度、过冷奥氏体的稳定性。</p><h4 id="钢的淬硬性"><a href="#钢的淬硬性" class="headerlink" title="钢的淬硬性"></a>钢的淬硬性</h4><p>淬硬性是指钢淬火后形成的淬火态组织（M+Ar）所达到的 <strong>最高硬度</strong>，即钢在淬火时的硬化能力。钢的淬硬性取决于马氏体含碳量和残余奥氏体数量。</p><h3 id="回火"><a href="#回火" class="headerlink" title="回火"></a>回火</h3><p>回火是消除内应力并获得要求的组织和性能，淬硬后加热到AC1线以下的某一温度，保温一定时间，然后冷却到室温的热处理工艺。</p><p>回火的目的是：</p><ul><li>消除回火的残余应力，提高材料的塑形和韧性</li><li>使材料获得良好的综合力学性能</li><li>促进残余奥氏体向稳定的平衡组织转化，稳定工件尺寸，使其不变</li></ul><p>淬火钢不能直接使用，必须进行回火处理</p><blockquote><p>首先，淬火得到的 M 与残余 A 都是不稳定的组织，在工作中会向平衡组织转化，会导致零件尺寸的变化；其次，马氏体硬度高，脆性大，并存在很大的内应力，很容易造成工件的变形和断裂；最后，回火可以获得要求的塑性韧性。</p></blockquote><p>回火有以下规律：回火温度越高，材料强度硬度下降越大，塑性韧性升高越大。</p><h4 id="低温回火"><a href="#低温回火" class="headerlink" title="低温回火"></a>低温回火</h4><ul><li>温度：150-250℃</li><li>回火后组织：回火 M + 残余 A </li><li>目的：降低淬火应力，提高工件韧性、保证淬火后高硬度与高耐磨</li><li>应用：各种刃具、模具、滚动轴承</li></ul><h4 id="中温回火"><a href="#中温回火" class="headerlink" title="中温回火"></a>中温回火</h4><ul><li>温度：350-500℃</li><li>回火后组织：回火 T</li><li>目的：使工件获得较高的<strong>弹性</strong>和强度，适当的韧性和硬度</li><li>性能：35-50HRC，较高的弹性极限和屈服强度、冲击韧性</li></ul><blockquote><p>常常用于制作弹簧</p></blockquote><h4 id="高温回火"><a href="#高温回火" class="headerlink" title="高温回火"></a>高温回火</h4><ul><li>温度：500-650℃</li><li>回火后组织：回火 S（其中的渗碳体为颗粒）</li><li>目的：使工件获得强度、塑性和韧性都较好的综合力学性能。</li><li>性能：强度、塑性和韧性都比较好，硬度一般为25～35HRC。</li></ul><blockquote><p>通常将淬火 + 高温回火称为<strong>调质处理</strong>，简称调质。调质钢硬度高，而且塑形和韧性也比较高</p><p>二次硬化：在回火过程中发生<strong>残余 A 向 M 转变</strong>的二次淬火现象。这可使某些钢的硬度在回火后有所升高，形成二次硬化。</p></blockquote><h4 id="淬火钢回火后的力学性能"><a href="#淬火钢回火后的力学性能" class="headerlink" title="淬火钢回火后的力学性能"></a>淬火钢回火后的力学性能</h4><h5 id="第一类回火脆性"><a href="#第一类回火脆性" class="headerlink" title="第一类回火脆性"></a>第一类回火脆性</h5><p>淬火碳钢在250-400℃温度范围内回火，室温冲击韧度出现低谷，它几乎在所有钢中出现。 </p><p>防止方法：避免在脆化温度范围内回火；加热重新淬火</p><h5 id="第二类回火脆性"><a href="#第二类回火脆性" class="headerlink" title="第二类回火脆性"></a>第二类回火脆性</h5><p>某些合金钢在450-650℃范围内回火，或在稍高温度回火后缓慢冷却后出现的脆性，叫第二类回火脆性（或马氏体高温回火脆性）。</p><p>防止方法：重新回火，回火后快速冷却，可避免回火脆性发生；另外，在钢中加入W（1%）、Mo（0.5%）等合金元素，可有效地抑制这类回火脆性的产生。 </p><h3 id="表面淬火处理"><a href="#表面淬火处理" class="headerlink" title="表面淬火处理"></a>表面淬火处理</h3><p>用于获得高强度、高耐磨性的表面，而心部保持原来良好的韧性，常常用于齿轮、曲轴等的加工</p><h2 id="MOOC-问答-2"><a href="#MOOC-问答-2" class="headerlink" title="[MOOC]问答"></a>[MOOC]问答</h2><ul><li>为什么合金钢通常不在水中淬火？</li></ul><blockquote><p><strong>合金钢淬火稳定性高</strong>，在油中可以获得单一的马氏体组织，为了防止淬火<strong>变形和开裂</strong>，故合金钢一般在油中淬火而不在水中淬火。</p></blockquote><ul><li>柴油机凸轮轴，要求凸轮表面有高的硬度(HRC&gt;50)，而心部具有良好的韧性(Ak&gt;40J)，原来用含碳量为0.45%的碳钢调质，再在凸轮表面进行高频淬火，最后低温回火。现因库存钢材用完，拟用含碳量为0.15%的碳钢代替。试说明：原含碳量为0.45%钢的各热处理工序的作用。</li></ul><blockquote><p><strong>调质</strong>：得到回火索氏体，使工件具有良好的综合机械性能。<strong>表面高频淬火</strong>：表面获得良好的强度硬度，心部保持良好的塑性韧性。<strong>低温回火</strong>：降低淬火应力和脆性，提高工件韧性，保证淬火后的高强度与耐磨性</p></blockquote><ul><li>精加工后可安排的热处理有<strong>氮化处理</strong></li></ul><h1 id="铸造工艺基础"><a href="#铸造工艺基础" class="headerlink" title="铸造工艺基础"></a>铸造工艺基础</h1><p>铸造是指将<strong>熔炼</strong>好的液态金属浇筑到与零件相适应的<strong>铸型</strong>型腔中，待其冷却凝固后，获得<strong>毛坯或零件</strong>的方法。</p><p>优点：</p><ul><li>可以制造形状复杂的零件</li><li>适用范围广</li><li>铸造用零部件来源广泛、价格低廉</li><li>铸铁加工的唯一方式</li></ul><p>不足：</p><ul><li>工艺复杂，比较难控制</li><li>液态成形内部均匀性差、致密性差</li><li>零件容易出现<strong>缩孔</strong>、<strong>气孔</strong>、<strong>沙眼</strong>、<strong>夹杂</strong>、<strong>裂纹</strong>等缺陷，产品不稳定</li><li>内部晶粒粗大组织不均匀，力学性能差</li></ul><p>液态合金的工艺性能表征为液态合金的 <strong>铸造性能</strong>（包括 <strong>流动性、凝固特性、收缩性、吸气性及偏析</strong>等性能）</p><h2 id="液态合金的充型"><a href="#液态合金的充型" class="headerlink" title="液态合金的充型"></a>液态合金的充型</h2><p>液态金属 <strong>充满型腔并是铸件形态完整、轮廓清晰</strong> 的能力，称为合金的 <strong>充型能力</strong></p><p>充型能力不足可能会导致：<strong>浇不足、冷隔、气孔、夹砂、夹杂</strong> 等缺陷</p><blockquote><p>造成铸件产生浇不足的主要原因是充型能力不足。</p></blockquote><p>充型能力的决定因素为：<strong>合金的流动性</strong>、<strong>铸件性质</strong>、<strong>浇注条件</strong>、<strong>铸件结构</strong></p><blockquote><p>上方文字选填题预定</p></blockquote><h3 id="合金的流动性"><a href="#合金的流动性" class="headerlink" title="合金的流动性"></a>合金的流动性</h3><p>同种合金中成分不同的合金具有不同的结晶特点，流动性也不同。 </p><p>有以下特性：</p><ul><li><strong>两相区结晶，流动性较差</strong>（共晶点处流动性最好）（由于在两相区，结晶是在一个温度区间进行的，初生的树枝状会使已结晶的地方比较粗糙，使流动性变差）</li></ul><ul><li><strong>恒温下结晶，流动性较好</strong>（恒温下，金属结晶有表层逐层向内，已结晶的金属比较光滑）</li></ul><blockquote><p>含碳量为4.3%的铁有良好的可铸性</p></blockquote><h3 id="浇注条件"><a href="#浇注条件" class="headerlink" title="浇注条件"></a>浇注条件</h3><div class="table-container"><table><thead><tr><th style="text-align:center">浇注条件</th><th style="text-align:center">解释</th><th style="text-align:center">结论</th></tr></thead><tbody><tr><td style="text-align:center">浇注温度</td><td style="text-align:center">浇注温度越高，液态金属含热量高、粘度小，保持液体时间长，充型能力强</td><td style="text-align:center">T↑ → ↑</td></tr><tr><td style="text-align:center">充型压力</td><td style="text-align:center">这个不用解释。。。</td><td style="text-align:center">P↑ → ↑</td></tr><tr><td style="text-align:center">浇注系统</td><td style="text-align:center">结构越复杂，阻力越大，充型能力越差</td><td style="text-align:center">复杂↑ → ↓</td></tr></tbody></table></div><h3 id="铸型性质"><a href="#铸型性质" class="headerlink" title="铸型性质"></a>铸型性质</h3><ul><li>铸型温度↑ → 充型能力↑</li><li>蓄热能力↑ → 充型能力↑</li><li>铸型中气体↑ → 内部压力↑ → 充型能力↑</li></ul><h3 id="提高流动性"><a href="#提高流动性" class="headerlink" title="提高流动性"></a>提高流动性</h3><ol><li>选用共晶成分的材料，或结晶温度范围窄的材料</li><li>提高浇注温度、充型压力</li><li>提高合金液体质量，减少气体、杂质</li><li>合理设置浇注系统，改进铸件结构</li></ol><h2 id="铸造合金的凝固与收缩"><a href="#铸造合金的凝固与收缩" class="headerlink" title="铸造合金的凝固与收缩"></a>铸造合金的凝固与收缩</h2><h3 id="液态金属的凝固"><a href="#液态金属的凝固" class="headerlink" title="液态金属的凝固"></a>液态金属的凝固</h3><p>在铸件的凝固过程中，截面一般存在三个区域，即液相区、凝固区、固相区。<strong>对铸件质量影响较大的主要是液固并存的凝固区的宽窄</strong>。铸件的凝固方式就是依据凝固区的宽窄来划分的。 </p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823213901.png" alt=""></p><p>一般来说逐层凝固，合金的充型能力强，便于防止缩松和缩孔等缺陷</p><h4 id="影响凝固方式的因素"><a href="#影响凝固方式的因素" class="headerlink" title="影响凝固方式的因素"></a>影响凝固方式的因素</h4><p>主要是合金的 <strong>结晶温度范围</strong> 和 <strong>铸件的温度梯度</strong>（就是温度变化的斜率）（铸型蓄热能力↑、铸型温度↑ → 温度梯度↑ → 凝固区域窄）</p><blockquote><p>填空题预定</p></blockquote><h3 id="铸造合金的收缩"><a href="#铸造合金的收缩" class="headerlink" title="铸造合金的收缩"></a>铸造合金的收缩</h3><p>铸件在<strong>液态、凝固态和固态</strong>冷却过程中所发生的体积减小的现象，称为收缩。 收缩是多种铸造缺陷（如缩孔、缩松、裂纹、变形等）产生的根源。 </p><p>有两种：<strong>体收缩</strong>（液态收缩、凝固收缩）和 <strong>线收缩</strong>（固态收缩）</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">收缩类型</th><th style="text-align:center">铸造缺陷</th></tr></thead><tbody><tr><td style="text-align:center">线收缩</td><td style="text-align:center">固态收缩</td><td style="text-align:center">应力、变形、裂纹</td></tr><tr><td style="text-align:center">体收缩</td><td style="text-align:center">液态收缩、凝固收缩</td><td style="text-align:center">缩松、缩孔</td></tr></tbody></table></div><h4 id="影响因素"><a href="#影响因素" class="headerlink" title="影响因素"></a>影响因素</h4><ul><li>化学成分（<strong>石墨</strong>的析出产生的体积膨胀，会抵消部分凝固收缩）</li><li>浇注温度（温度越高，过热度越大，收缩量越大）（<strong>在满足流动性要求的前提下，尽可能降低浇注温度</strong>）</li><li>铸件结构与铸型条件</li></ul><h3 id="缩松与缩孔"><a href="#缩松与缩孔" class="headerlink" title="缩松与缩孔"></a>缩松与缩孔</h3><h4 id="缩孔"><a href="#缩孔" class="headerlink" title="缩孔"></a>缩孔</h4><p><strong>纯金属、共晶成分和凝固温度范围窄的合金</strong>（条件①），浇注后在型腔内是由表及里的<strong>逐层凝固</strong>（条件②）。在凝固过程中，如得不到合金液的补充，在铸件最后凝固的地方就会产生<strong>缩孔</strong>.</p><p>产生原因：合金的液态收缩和凝固收缩值大于固态收缩值，且得不到补偿。</p><p>缩孔产生的部位在铸件<strong>最后凝固区域</strong>，如壁较厚大的上部或铸件两壁相交处，这些地方称为热节。</p><p><strong>合金的液态收缩和凝固收缩愈大、浇注温度愈高、铸件愈厚，缩孔的体积愈大。</strong></p><h4 id="缩松"><a href="#缩松" class="headerlink" title="缩松"></a>缩松</h4><p>非共晶成分的合金或有较宽结晶温度的合金成 <strong>糊状凝固</strong> 。</p><p><strong>缩松形成的条件</strong>：铸件主要呈糊状凝固方式凝固，成分为非共晶成分或有较宽结晶温度范围的合金。 </p><h4 id="影响因素-1"><a href="#影响因素-1" class="headerlink" title="影响因素"></a>影响因素</h4><ul><li><p>合金成分</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823213914.png" alt=""></p><p><strong>结晶范围小的合金，产生缩孔的倾向大；结晶范围大的合金，产生缩松的倾向大</strong></p></li><li><p>浇注条件</p><p><strong>浇注温度越高，缩松缩孔倾向越大</strong></p></li><li><p>铸型材料</p></li><li><p>铸件结构</p></li></ul><h4 id="防止方法"><a href="#防止方法" class="headerlink" title="防止方法"></a>防止方法</h4><ul><li><p>控制铸件的凝固过程</p><p>使铸件 <strong>顺序凝固</strong> 或 <strong>同时凝固</strong> 。</p><ul><li><p>顺序凝固：让铸件远离冒口的地方先凝固，靠近冒口的地方后凝固。最后才是冒口本身凝固。适用于收缩大，或壁厚大的合金铸件</p><p>冒口补缩作用好，但是容易产生铸造应力、变形及裂纹等等</p><blockquote><p>为保证铸件质量，通常同时凝固适合于 <strong>缩孔</strong> 倾向大的铸造合金</p></blockquote></li><li><p>同时凝固：采取必要的措施，使得部件各个部分的冷却速度相同，几乎同时凝固完全。（添加冷铁、将浇注口设置在壁厚较小的地方）</p><p>不用设置冒口，使工艺简化，提高了良品率</p><blockquote><p>为保证铸件质量，通常同时凝固适合于 <strong>变形和裂纹</strong> 倾向大的铸造合金</p></blockquote></li></ul></li><li><p>合理应用冒口、冷铁等工艺措施</p><ul><li><p>冒口一般设置在热节处，这样防止变形和裂纹的效果最好，同时冒口应该保证比铸件凝固晚，然后有足够的金属液</p><blockquote><p>不要将冒口设置在铸件重要的或受力较大的部位，以防组织粗大，降低该处强度。 </p></blockquote></li><li><p>冷铁用来加大某一部分的冷却速度</p></li></ul></li></ul><h2 id="铸件的内应力、变形与裂纹"><a href="#铸件的内应力、变形与裂纹" class="headerlink" title="铸件的内应力、变形与裂纹"></a>铸件的内应力、变形与裂纹</h2><div class="table-container"><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">热应力</td><td style="text-align:left">由于铸件<strong>厚薄不一致</strong>，各部分 <strong>冷却速度</strong> 也不相同，使在同一时间内，各部分 <strong>收缩不一致</strong> 而造成的内应力</td></tr><tr><td style="text-align:left">机械应力</td><td style="text-align:left">铸件在收缩过程中 <strong>受到铸件或型芯阻扰</strong> 造成的应力</td></tr><tr><td style="text-align:left">变形</td><td style="text-align:left"><strong>残余热应力</strong> 的存在，使得铸件存在于一种非稳定的状态中，铸件将 <strong>自发的通过变形来减缓热应力</strong>，来达到平衡的状态</td></tr><tr><td style="text-align:left">裂纹</td><td style="text-align:left">当铸件应力超过金属的材料极限是，铸件产生裂纹</td></tr></tbody></table></div><h3 id="热应力"><a href="#热应力" class="headerlink" title="热应力"></a>热应力</h3><p>由于铸件<strong>厚薄不一致</strong>，各部分 <strong>冷却速度</strong> 也不相同，使在同一时间内，各部分 <strong>收缩不一致</strong> 而造成的内应力。下面说说热应力的形成</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823213927.png" alt=""></p><p>温度在 $t_K$ 以上，金属处于塑形阶段；在 $t_K$ 以下，金属处于弹性阶段。</p><p>这样的话热应力的形成就可以分为三个部分：</p><ul><li>$\tau_0-\tau_1$：金属<strong>都处于塑性变形阶段</strong>，收缩引起的热应力会通过塑形变形消除。此时 <strong>无应力产生</strong></li><li>$\tau_1-\tau_2$：<strong>厚壁金属</strong>由于比较厚因此冷却的比较慢，还<strong>处于塑形变形阶段</strong>，<strong>薄壁部分处于弹性变形阶段</strong>。薄壁金属短收到压应力，厚壁金属收到压应力。但由于还是有塑形变形，因此依然<strong>无应力产生</strong></li><li>$\tau_2-\tau_3$：两者<strong>都进入弹性变形阶段</strong>。不过薄壁的变形变完了，厚壁部分还有一些要变形的部分，因此此时厚壁部分收缩量大于薄壁部分。厚壁部分收到拉应力，薄壁部分受到压应力。</li></ul><blockquote><p>消除铸件中残余热应力的方法是 <strong>时效处理</strong></p></blockquote><h3 id="机械应力"><a href="#机械应力" class="headerlink" title="机械应力"></a>机械应力</h3><p>铸件在收缩过程中 <strong>受到铸件或型芯阻扰</strong> 造成的应力</p><p>防止措施</p><ul><li>工艺上：采用合理的铸造工艺，使其 <strong>同时凝固</strong> 原则</li><li>造型上：采取措施较小铸造应力（合理设置冒口等）</li><li>结构上：尽量避免牵制到收缩的结构（是结构尽量对称，壁厚尽量均匀）</li><li>去应力退火</li></ul><blockquote><p>消除铸件中残余热应力的方法是 <strong>及时落砂</strong></p></blockquote><h3 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h3><p>具有残余应力的铸件是不稳定的，它将自发地通过变形来减缓其内应力，以便趋于稳定状态。</p><p>原来受拉伸部分产生压缩变形、受压缩部分产生拉伸变形，才能使残余内应力减小或消除。 </p><p><strong>厚部、心部受拉应力，出现内凹变形；薄部、表面受压应力，出现外凸变形</strong></p><p>例如下图：</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823213937.png" alt=""></p><div class="table-container"><table><thead><tr><th style="text-align:center">代号</th><th style="text-align:center">加工方式</th><th style="text-align:center">结论</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">b</td><td style="text-align:center">去除外表面</td><td style="text-align:center">铸件变短</td><td style="text-align:center">由外表面引起的心部拉应力减少，铸件变短</td></tr><tr><td style="text-align:center">c</td><td style="text-align:center">去除心部</td><td style="text-align:center">铸件变长</td><td style="text-align:center">由心部引起的外表面压应力减少，铸件变长</td></tr><tr><td style="text-align:center">d</td><td style="text-align:center">从侧面切一层</td><td style="text-align:center">铸件变弯</td><td style="text-align:center">中间厚两边薄，中间受到拉应力，两边受到压应力，铸件要恢复因此中间往回缩，两边往外开，就变弯了</td></tr></tbody></table></div><blockquote><p>一定要掌握的</p></blockquote><h2 id="MOOC-问答-3"><a href="#MOOC-问答-3" class="headerlink" title="[MOOC]问答"></a>[MOOC]问答</h2><ul><li>某厂采用树脂砂砂型铸造生产新能源铝合金电机壳体，生产中发现铸件上部出现气孔缺陷，为消除此类缺陷，可以采取的措施有哪些？</li></ul><blockquote><p>铸件上部出现气孔缺陷，说明这是 <strong>侵入气孔 。</strong></p><p>预防侵入气孔的方法有：<strong>降低型砂的发气量</strong>和<strong>增加铸型的排气能力</strong></p></blockquote><h1 id="常用合金铸件的生产"><a href="#常用合金铸件的生产" class="headerlink" title="常用合金铸件的生产"></a>常用合金铸件的生产</h1><h2 id="铸铁件的生产"><a href="#铸铁件的生产" class="headerlink" title="铸铁件的生产"></a>铸铁件的生产</h2><p>C 在 铸铁中主要以两种形式存在： <strong>$Fe_3C$ (渗碳体)和 石墨(游离碳)</strong></p><p>有以下分类：</p><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">主要成分</th><th style="text-align:center">力学性能</th><th style="text-align:center">牌号</th></tr></thead><tbody><tr><td style="text-align:center">白口铸铁</td><td style="text-align:center">$Fe_3C$</td><td style="text-align:center">硬而脆，很差</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">麻口铸铁</td><td style="text-align:center">一部分$ Fe_3C$，一部分石墨</td><td style="text-align:center">介于上下之间</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">普通灰口铸铁</td><td style="text-align:center">片状石墨</td><td style="text-align:center">硬度低塑性差，但铸造性能好</td><td style="text-align:center">ZT</td></tr><tr><td style="text-align:center">可锻铸铁</td><td style="text-align:center">团絮状石墨</td><td style="text-align:center">韧性塑形好</td><td style="text-align:center">KTH、KTZ</td></tr><tr><td style="text-align:center">球墨铸铁</td><td style="text-align:center">球状石墨</td><td style="text-align:center">强度塑性比可锻铸铁高</td><td style="text-align:center">QT</td></tr><tr><td style="text-align:center">蠕墨铸铁</td><td style="text-align:center">蠕虫状石墨</td><td style="text-align:center">同时有普通灰口铸铁和球墨铸铁的性质</td><td style="text-align:center">-</td></tr></tbody></table></div><p>由于有了石墨，铸铁有很多铸钢没有的性质：</p><ul><li>良好的铸造性能，流动性大，收缩小</li><li>良好的切削加工性能</li><li>耐磨性好</li><li>良好的吸振缓冲性能</li><li>低的缺口敏感性</li></ul><blockquote><p>PPT中标红</p></blockquote><h3 id="石墨化"><a href="#石墨化" class="headerlink" title="石墨化"></a>石墨化</h3><p>石墨化：石墨析出的过程。</p><p>从上面可以看出，石墨对铸铁件的力学性能影响很大，石墨的形态与数量是关键</p><p>由于 C 在铸铁中由 石墨 和 $Fe_3C$ 构成，因此根据 $Fe_3C$ 的不同，可以将灰口铸铁分为：铁素体灰铸铁（全部为石墨）、铁素体-珠光体灰铸铁（化合碳&lt;0.8%）、珠光体灰铸铁（化合碳0.8%）</p><p>影响石墨化的因素：</p><ul><li><p>化学成分</p><p>C 和 Si 的含量对石墨化影响是其决定性的。C是形成石墨化的元素，Si 是强烈促进石墨化的元素。含 C 、Si 量越多，石墨越粗大，基体 F 增加，P 减少。</p><p>P 也会促进石墨化，但是一旦多了就会出现冷脆性</p><p>S 会抑制石墨化，属于有害元素</p></li><li><p>冷却速度</p><p>冷却速度减缓，会促进石墨化</p><blockquote><p>当其他条件一定时，壁厚越大，金属冷却速度越大，石墨化倾向大，会形成粗大的铁素体和石墨，导致铸铁强度，硬度的下降。不过当壁厚小到一定程度时，·无法进行，会形成白口组织</p></blockquote></li></ul><h3 id="灰口铸铁"><a href="#灰口铸铁" class="headerlink" title="灰口铸铁"></a>灰口铸铁</h3><p>灰口铸铁的性能不仅取决于化学性能，还取决于铸件的壁厚，因此牌号用 <strong>力学性能</strong> 来表示。用 <strong>HT×××</strong> 表示，后面的三位数字表示其抗拉强度。铸件设计时，应该根据铸件的平均壁厚选择。</p><blockquote><p>灰口铸铁力学性能较差，几乎没有塑性，抗拉能力较差，但是抗压能力还可以；有着良好的铸造性和切削加工性能（石墨润滑）；良好的耐磨性、减震性，缺口敏感性好。</p></blockquote><h4 id="孕育处理"><a href="#孕育处理" class="headerlink" title="孕育处理"></a>孕育处理</h4><p>普通灰铸铁的主要缺点是<strong>粗大的石墨片</strong>严重地割裂金属基体，致使铸铁<strong>强度低</strong>。 实践证明，提高灰铸铁抗拉强度最有效的途径是：对出炉铁液进行<strong>孕育处理</strong>再行浇注。</p><p>孕育处理是向含C、Si量少的 Fe 中加入孕育剂（促进石墨化）。常用的孕育剂为：<strong>含 Si 量为75%的硅铁合金</strong>。硅铁加入量为铁水质量的0.25%-0.60%。</p><p>孕育处理后的金属组织特点为：细小的 P 晶粒上附着着细小的石墨片。相比于普通的灰口铸铁，孕育处理后的铸铁[孕育铸铁]，强度硬度耐磨性好，但是铸造性能下降</p><h3 id="可锻铸铁"><a href="#可锻铸铁" class="headerlink" title="可锻铸铁"></a>可锻铸铁</h3><p>（不可锻造）<strong>可锻铸铁是将白口铸铁经过长时间高温退火得到的一种高塑形和高韧性的铸铁</strong>。根据退火工艺不同，可分为三种。</p><ul><li><p>黑心可锻铸铁（KYH×××-××）</p><p>$Fe_3C$ 全部分解为团絮状石墨，基体为铁素体</p></li><li><p>珠光体可锻铸铁（KYZ×××-××）</p><p>退火时速度比较快，共析渗碳体未完全石墨化，组织为珠光体基体附着团絮状石墨</p></li><li><p>白心可锻铸铁</p><p>白口坯件在氧化氛围脱碳退火得到，组织与钢相近心部为铁素体+团絮状石墨</p></li></ul><p>注：牌号后面第一组数孖表示最小抗拉强度值，第二组数孖表示最小延伸率值。球墨铸铁同</p><blockquote><p>制造自来水管的弯头、接头、三通应选用 <strong>可锻铸铁</strong></p></blockquote><h3 id="球墨铸铁"><a href="#球墨铸铁" class="headerlink" title="球墨铸铁"></a>球墨铸铁</h3><p>球墨铸铁是通过浇注前向铁水加入一定量<strong>球化剂</strong>和<strong>孕育剂</strong>，以促进碳呈球状石墨结合，从而获得一种高强度和良好塑形的铸铁。</p><h4 id="生产特点"><a href="#生产特点" class="headerlink" title="生产特点"></a>生产特点</h4><ul><li>严格控制化学成分 （C、Si 高；S、P 低）</li><li>较高的出铁温度</li><li>进行球化处理（作用是使石墨呈球状析出）</li><li>进行孕育处理（作用是促进石墨化）</li></ul><blockquote><p>球墨铸铁保留了灰口铸铁的优良特性而且焊接性能和热处理性能也比其他灰口铸铁好。不过铸造性能比灰口铸铁差</p></blockquote><h4 id="热处理"><a href="#热处理" class="headerlink" title="热处理"></a>热处理</h4><ul><li><strong>退火</strong>（可以得到铁素体球墨铸铁）</li><li><strong>正火</strong>（可以得到珠光体球墨铸铁）</li></ul><h3 id="蠕墨铸铁"><a href="#蠕墨铸铁" class="headerlink" title="蠕墨铸铁"></a>蠕墨铸铁</h3><p>有灰口铸铁和球墨铸铁的一系列优点，而且热疲劳性能好（&gt;&gt;球墨），壁厚敏感性好（&gt;&gt;灰口）</p><h2 id="铸钢"><a href="#铸钢" class="headerlink" title="铸钢"></a>铸钢</h2><p>优点是：力学性能高（塑性韧性高），焊接性能优良</p><p>缺点是：铸造性能、减震性和切口敏感性比铸铁差</p><h2 id="有色金属"><a href="#有色金属" class="headerlink" title="有色金属"></a>有色金属</h2><p>略</p><h1 id="砂型铸造"><a href="#砂型铸造" class="headerlink" title="砂型铸造"></a>砂型铸造</h1><h2 id="造型方法的选择"><a href="#造型方法的选择" class="headerlink" title="造型方法的选择"></a>造型方法的选择</h2><p>在砂型铸造中，造型和造芯是最基本的工序。根据造型生产方法的特点，通常分为 <strong>手工造型</strong> 和 <strong>机器造型</strong> 两大类。</p><h3 id="手工造型"><a href="#手工造型" class="headerlink" title="手工造型"></a>手工造型</h3><ul><li>按砂箱特征分类</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">造型方法</th><th style="text-align:center">分型面</th></tr></thead><tbody><tr><td style="text-align:center">两箱造型</td><td style="text-align:center">各类模样，可机器造型</td></tr><tr><td style="text-align:center">多箱造型</td><td style="text-align:center">一般用于铸件中间截面较两端小的情况</td></tr></tbody></table></div><ul><li><p>按模样特征分</p><p>课件上的比较好，这里就不说了</p></li></ul><h2 id="浇注位置的选择"><a href="#浇注位置的选择" class="headerlink" title="浇注位置的选择"></a>浇注位置的选择</h2><ul><li>铸件的重要工作面、主要加工面应该朝下或侧立放置 <code>气孔、缩孔容易出现在铸件的上方</code></li><li>铸件的大平面应朝下，以免形成夹渣和夹砂等缺陷。</li><li>应将铸件薄而大的平面放在下部、侧面或倾斜位置，以利于合金液填充铸型。</li><li>铸件厚大部分应该放在上面或侧面，方便安放冒口</li></ul><blockquote><p>核心重点</p></blockquote><h2 id="分型面的选择"><a href="#分型面的选择" class="headerlink" title="分型面的选择"></a>分型面的选择</h2><ul><li>应保证模样能顺利从铸型中取出。 </li><li>应尽量减少分型面的数量。</li><li>应尽量使分型面是一个平直的面。</li><li>应尽量使型芯和活块的数量减少。</li><li>应使全部或大部分铸件，或加工基准面与重要的加工面处于同一半型内，以防止错型。</li></ul><blockquote><p>核心重点</p></blockquote><ul><li><p>例题</p><p>试对下图所示轴座铸件选择两个可能的分型方案，用符号表示在图上，并比较其优缺点，然后按你认为最好的分型面用符号表示出浇注位置、加工余量、拔模斜度和型芯的轮廓，并指出造型方法。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823213952.png" alt=""></p><p>答案：</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823214003.png" alt=""></p></li></ul><h2 id="铸造工艺参数的选择"><a href="#铸造工艺参数的选择" class="headerlink" title="铸造工艺参数的选择"></a>铸造工艺参数的选择</h2><h3 id="机械加工余量和铸孔"><a href="#机械加工余量和铸孔" class="headerlink" title="机械加工余量和铸孔"></a>机械加工余量和铸孔</h3><p>设计铸造工艺图时，为铸件预先增加要切去的金属层厚度，称为机械加工余量。</p><p>机械加工余量与以下内容有关：</p><ul><li><p>合金种类</p><p>铸钢件的表面粗糙，加工余量应该更大；有色合金价格昂贵，表面光洁，其加工余量较小</p></li><li><p>铸件尺寸</p><p>铸件尺寸越大，机械加工余量越大</p></li><li><p>加工面位置</p><p>注浇时朝上的表面缺陷多，其加工余量比底面和侧面大</p></li></ul><p>铸孔：铸件上的孔、槽是否需要铸出，不仅要考虑工艺上的可能性，尤其应结合 <strong>铸件的批量分析其必要性</strong>。（一般大孔铸出，小孔不铸）</p><h3 id="铸造收缩率"><a href="#铸造收缩率" class="headerlink" title="铸造收缩率"></a>铸造收缩率</h3><p>由于合金在冷却过程中要发生 <strong>固态收缩(线收缩)</strong>，这将使铸件各部分尺寸小于模样原来的尺寸，因此，为了使铸件冷却后的尺寸与铸件图示尺寸一致，则需要在模样或芯盒上加上其收缩的尺寸。</p><script type="math/tex; mode=display">K=\frac{L_0-L}{L_0}\times100\%</script><p>其中，<em>L0</em> 为模样尺寸，<em>L</em> 为铸件尺寸</p><h3 id="拔模斜度"><a href="#拔模斜度" class="headerlink" title="拔模斜度"></a>拔模斜度</h3><p>为了在造型和制芯时便于起模而不致损坏砂型和砂芯，凡垂直于分型面的立壁，在<strong>制造模型</strong>时，必须留出一定的倾斜度，此斜度称为<strong>拨模斜度</strong>。（不是设计）（<strong>垂直壁越高，斜度越小</strong>）</p><h3 id="铸造圆角"><a href="#铸造圆角" class="headerlink" title="铸造圆角"></a>铸造圆角</h3><p>制造模型和设计铸件时，壁的连接和转角处都要做成圆弧过渡，称为铸造圆角。</p><p>有时零件上并不需要圆角，为了铸造工艺的需要，也要做成圆角，但铸型分型面处则不宜做成圆角。</p><h3 id="冒口与冷铁"><a href="#冒口与冷铁" class="headerlink" title="冒口与冷铁"></a>冒口与冷铁</h3><p>冒口的作用：</p><ul><li>在凝固期间进行补缩</li><li>调节冷却速度</li></ul><p>冷铁的作用：</p><ul><li>调节冷却速度，改变凝固顺序</li><li>减少冒口数量，增加金属利用率</li><li>在无法安放冒口的地方起到同样的作用</li><li>消除局部热应力</li></ul><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823214028.png" alt=""></p><h2 id="铸件的结构设计"><a href="#铸件的结构设计" class="headerlink" title="铸件的结构设计"></a>铸件的结构设计</h2><ul><li>避免外部侧凹</li><li>肋板、凸台设计考虑起模方便</li><li>尽量避免或减少型腔</li><li>应该避免封闭内腔</li><li>铸件要有结构斜度（<strong>斜度值较大</strong>）</li><li>应该合理设计壁厚</li><li>铸件连接处应该有圆角</li><li>铸件厚薄不一致时，力求平缓过渡</li><li>减少交叉和锐角</li><li>避免大的平面（不利于金属液的填充，易发生浇不足、冷隔等现象）</li></ul><blockquote><p>例题</p></blockquote><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823214040.png" alt=""></p><p>答案：</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823214050.png" alt=""></p><ul><li>a：壁厚相差太大</li><li>b：凸台和筋条结构应便于起模。</li><li>c：①分型面处不应该设置圆角②凸台应便于起模</li><li>d：凸台应便于起模</li></ul><h2 id="MOOC-问答-4"><a href="#MOOC-问答-4" class="headerlink" title="[MOOC]问答"></a>[MOOC]问答</h2><ul><li>某工厂用T10钢制造的钻头给一批铸铁件钻10mm深孔，钻几个孔以后钻头很快就磨损，经检验，钻头的材质、热处理工艺、金相组织、硬度均合格，试问失败原因，并请提出解决办法。</li></ul><blockquote><p>失败原因：①铸件产生麻口或白口组织，硬度过高，使钻头磨损 ②铸件表面有粘砂</p><p>解决办法：①退火处理，消除铸件麻口或白口组织 ②将铸件表面磨一下，去除表面粘砂</p></blockquote><h1 id="特种铸造"><a href="#特种铸造" class="headerlink" title="特种铸造"></a>特种铸造</h1><h2 id="MOOC-问答-5"><a href="#MOOC-问答-5" class="headerlink" title="[MOOC]问答"></a>[MOOC]问答</h2><ul><li><p><strong>挤压铸造</strong> 生产铝连杆铸件，铸件晶粒最小</p></li><li><p><strong>砂型铸造</strong> 可以用来生产大型铸件</p></li><li><p>热烈倾向大的合金 <strong>不适用</strong> 于金属型铸造。</p></li><li><p>压铸件<strong>不能</strong>进行热处理或在高温下工作。</p></li><li><p>如铸件有致密度要求，如用压力铸造方法生产能否满足要求？什么是真空压铸？</p><blockquote><p><strong>不能</strong>，因为铸件内部组织疏松，而且内部存在气孔，缩孔和缩松等缺陷。</p><p>真空压铸是通过在压铸过程中 <strong>抽除压铸模具型腔内的气体</strong> 而消除或显著减少压铸件内的气孔和溶解气体，从而提高压铸件力学性能和表面质量的先进压铸工艺。（百度百科）</p></blockquote></li></ul><h1 id="金属压力加工基础"><a href="#金属压力加工基础" class="headerlink" title="金属压力加工基础"></a>金属压力加工基础</h1><p><strong>固态金属</strong>在外力作用下产生<strong>塑形变形</strong>，获得一定形状、尺寸和力学性能的零件等的生产方法</p><p>良好是塑形是金属压力加工的必要条件（要求断面收缩率大、延伸率大）</p><h2 id="金属塑形变形的实质"><a href="#金属塑形变形的实质" class="headerlink" title="金属塑形变形的实质"></a>金属塑形变形的实质</h2><p>金属塑形变形的实质可以用 <strong>晶粒内部、晶粒间产生滑移和晶粒发生转动</strong> 来解释</p><p>金属收到外力作用→内部产生应力→原子离开平衡位置→弹性变形→塑形变形</p><h3 id="单晶体变形"><a href="#单晶体变形" class="headerlink" title="单晶体变形"></a>单晶体变形</h3><ul><li><p>滑移</p><p>近代物理学证明，实际晶体内部存在大量缺陷，其中以 <strong>位错</strong> 对金属塑性变形的影响最为明显。</p></li><li><p>孪生</p></li></ul><h3 id="多晶体变形"><a href="#多晶体变形" class="headerlink" title="多晶体变形"></a>多晶体变形</h3><p>机械制造中大多数是多晶体，其中多晶体是由很多单晶体构成的，因此多晶体变形分为两类：<strong>晶内变形、晶间变形</strong>（滑动转动）</p><ul><li>一般来说，同一成分的金属，晶粒越细，其强度、硬度越高，而且塑性和韧性也越好。</li></ul><blockquote><p>晶粒细小→晶界强化区大→变形受阻→强度硬度高→变形分散度大→每一个变形大→塑性韧性高</p></blockquote><h2 id="塑形变形对金属组织和性能的影响"><a href="#塑形变形对金属组织和性能的影响" class="headerlink" title="塑形变形对金属组织和性能的影响"></a>塑形变形对金属组织和性能的影响</h2><p>金属在常温下塑形加工过后，内部组织将发生如下变化</p><ul><li>晶粒向最大变形的方向延展</li><li>晶格与晶粒发生扭曲，产生内应力</li><li>晶粒间产生碎晶</li></ul><p>宏观上表现为：硬度增加，塑性下降。这种现象被称为 <strong>加工硬化</strong></p><blockquote><p>单晶体内发生滑移，产生内应力，滑动阻力增大；晶粒间产生碎粒，滑动阻力增大。进一步变形会比较困难，表现为强度硬度上升，塑形下降。</p><p>加工硬化的主要原因是：<strong>位错密度增加</strong></p></blockquote><p>加工硬化是一种不稳定的现象，会自发的恢复。当温度升高时，原子热运动加剧，原子的排列会恢复到之前的状态，从而消除晶格扭曲，得到 <strong>部分消除</strong>（<strong>回复</strong>现象）</p><p>这时的温度被称为 <strong>回复温度</strong> ，其中：<strong>T回=(0.25-0.3)T熔</strong>。不过此时晶体形状没有变化。</p><p>当温度继续升高，金属原子获得更多的热能，开始以某些碎晶或杂质为核心，按变形前的晶格结构结晶成新的晶粒，这一过程称为<strong>再结晶</strong>。 此时加工硬化现象可以<strong>完全消除</strong></p><p>这时的温度叫做 <strong>再结晶温度</strong>，其中 <strong>T再=0.4T熔</strong>。</p><blockquote><p>再结晶退火就是这个原理</p></blockquote><h3 id="冷变形与热变形"><a href="#冷变形与热变形" class="headerlink" title="冷变形与热变形"></a>冷变形与热变形</h3><ul><li><p>在结晶温度<strong>以下</strong>发生的塑形变形是冷变形，<strong>会</strong>产生加工硬化现象。</p></li><li><p>在结晶温度<strong>以上</strong>发生的塑形变形是热变形，<strong>不会</strong>产生加工硬化现象。</p><blockquote><p>加工硬化与再结晶现象同时发生，加工硬化会被再结晶消除</p></blockquote></li></ul><div class="table-container"><table><thead><tr><th>温度</th><th></th><th></th></tr></thead><tbody><tr><td>熔化温度</td><td>T熔</td><td>熔化</td></tr><tr><td>再结晶温度</td><td>T再 = 0.4 T熔</td><td>热变形，加工硬化可完全恢复（再结晶现象）</td></tr><tr><td>回复温度</td><td>T再 = (0.25-0.3) T熔</td><td>冷变形，加工硬化部分恢复（回复现象）</td></tr></tbody></table></div><h3 id="纤维组织变化"><a href="#纤维组织变化" class="headerlink" title="纤维组织变化"></a>纤维组织变化</h3><p>铸锭在压力加工中产生塑性变形时，基体金属的晶粒形状和沿晶界分布的杂质形状都发生了变形，它们都将沿着 <strong>变形方向</strong> 被拉长，呈纤维形状。这种结构叫纤维组织。（要记）</p><p>变形后纤维组织纤维组织使金属在性能上具有了<strong>方向性</strong> 。纤维组织越明显，金属在纵向(平行纤维方向)上塑性和韧性提高，而在横向(垂直纤维方向)上塑性和韧性降低。</p><p><strong>变形程度越大，纤维组织越明显。</strong>压力加工过程中，常用锻造比(y)来表示变形程度。</p><blockquote><p> 纤维组织的稳定性很高，<strong>不能用热处理方法加以消除</strong>，只有经过 <strong>压力加工</strong> 使金属变形，才能变其方向和形状。 （判断题）</p></blockquote><p>纤维组织的利用原则：</p><ul><li><p>使纤维分布与零件的轮廓相符合而不被切断</p><blockquote><p>局部镦粗的螺钉比切削加工的螺钉承载能力强</p></blockquote></li><li><p>零件所受的最大拉应力与纤维方向一致，最大切应力与纤维方向垂直。 </p></li></ul><h2 id="金属的可锻性"><a href="#金属的可锻性" class="headerlink" title="金属的可锻性"></a>金属的可锻性</h2><p>受到塑形变形而不开裂的能力</p><p>可锻性常用金属的 <strong>塑性和变形抗力</strong> 来综合衡量。塑性越好，变形抗力越小，则金属的可锻性好。反之则差。</p><p>金属的可锻性取决于<strong>金属的本质</strong>（内因）和<strong>加工条件</strong>（外因）。</p><h3 id="金属的本质（内因）"><a href="#金属的本质（内因）" class="headerlink" title="金属的本质（内因）"></a>金属的本质（内因）</h3><ol><li><p>化学成分</p><p>合金元素含量越多，合金成分越复杂，其塑性越差，变形抗力越大。</p></li><li><p>金属组织</p><p>纯金属及单一固溶体组成的合金（如奥氏体）的可锻性好；碳化物（如渗碳体）的可锻性差。</p></li></ol><h3 id="加工条件（外因）"><a href="#加工条件（外因）" class="headerlink" title="加工条件（外因）"></a>加工条件（外因）</h3><h4 id="变形温度"><a href="#变形温度" class="headerlink" title="变形温度"></a>变形温度</h4><p>在一定的变形温度范围内，随着温度升高，原子动能升高，从而塑性提高，变形抗力减小，有效改善了可锻性。</p><p>但是温度过高会出现各种缺陷</p><div class="table-container"><table><thead><tr><th>名称</th><th>原因</th></tr></thead><tbody><tr><td>过热</td><td>T大→晶粒大→金属力学性能下降</td></tr><tr><td>过烧</td><td>接近熔点→晶界氧化→塑性丧失→工件报废</td></tr></tbody></table></div><p>因此控制温度就很重要了。于是乎就有 <strong>始锻温度</strong> 和 <strong>终锻温度</strong></p><h4 id="变形速度"><a href="#变形速度" class="headerlink" title="变形速度"></a>变形速度</h4><ul><li>v增大 → 再结晶来不及 → 不能及时克服加工硬化 → 可锻性差</li><li>v增大 → 热效应明显 → 塑性韧性好（一般压力加工不明显）</li></ul><h4 id="应力状态"><a href="#应力状态" class="headerlink" title="应力状态"></a>应力状态</h4><p>对于本质塑性较好的金属，变形时出现拉应力是有利的。对于本质塑性较差的金属，则应尽量在三向压应力下变形，以免产生裂纹。</p><blockquote><p>实践证明：三个方向的应力中，<strong>压应力的数目越多，则金属的塑性越好</strong>；拉应力的数目越多，则金属的塑性越差。但压应力使金属内部摩擦阻力增大，变形抗力亦随之增大，所以拉拔加工比挤压加工省力。（了解）</p><p>某种铁合金塑性较差，但又要用压力加工方法成型，此时，以选用 <strong>挤压</strong> 方法的成型效果最好。</p></blockquote><h1 id="常用的锻造方法"><a href="#常用的锻造方法" class="headerlink" title="常用的锻造方法"></a>常用的锻造方法</h1><p>锻造是使加热好的金属坯料，在外力的作用下发生塑性变形，通过控制金属的流动，使其成形为所需形状、尺寸和组织的方法。</p><h2 id="自由锻"><a href="#自由锻" class="headerlink" title="自由锻"></a>自由锻</h2><p>只用简单的通用性工具，或在锻造设备的上、下砧间直接使坯料变形而获得所需的锻件，这种方法称为自由锻。 </p><blockquote><p><strong>自由锻是大型件唯一的锻造方法。</strong></p></blockquote><p>自由锻工序可分为<strong>基本工序</strong>（使金属坯料实现主要的变形要求，达到或基本达到锻件所需形状和尺寸的工序。）、<strong>辅助工序</strong>和<strong>修整工序</strong>三大类。</p><p>基本工序主要有：</p><ul><li>墩粗：是坯料高度减小、横截面积增大的锻造工序</li><li>拔长：使坯料横断面积减小、长度增加的锻造工序 （有反复翻转和螺旋式翻转两种）</li><li>冲孔：在坯料上冲出通孔或盲孔的锻造工序称为冲<br>孔</li><li>弯曲</li><li>扭转</li><li>切割</li></ul><h3 id="自由锻结构设计要求"><a href="#自由锻结构设计要求" class="headerlink" title="自由锻结构设计要求"></a>自由锻结构设计要求</h3><ul><li>避免窄的凹槽、圆锥面等结构</li><li>不允许有小的肋板、小凸台和相贯线等异形结构</li><li>.自由锻件的横截面若有急剧变化或形状较复杂时，应设计成由几个简单件构成的几何体。</li></ul><h2 id="模锻"><a href="#模锻" class="headerlink" title="模锻"></a>模锻</h2><p>利用锻模使坯料变形而获得锻件的锻造方法称为<strong>模锻</strong>。 </p><p>模锻分<strong>胎模锻</strong>和<strong>固定模锻</strong>两类。</p><h3 id="胎模锻"><a href="#胎模锻" class="headerlink" title="胎模锻"></a>胎模锻</h3><p>胎模锻是在<strong>自由锻设备上</strong>使用<strong>可移动模具</strong>生产模锻件的一种方法。</p><p>胎模不固定在锤头或砧座上，只是在使用时才放上去，它介于自由锻和模锻之间。</p><h3 id="固定模锻"><a href="#固定模锻" class="headerlink" title="固定模锻"></a>固定模锻</h3><p>固定模锻根据所用设备不同可分为<strong>锤上模锻</strong>和<strong>压力机上模锻</strong>。</p><p><strong>锤上模锻</strong>是我国当前模锻生产的基本方法。</p><p>模锻生产的工艺规程制定包括：<strong>模锻锻件图制定、锻模模膛设计</strong>、毛坯计算、工序确定、设备选择、毛坯加热、锻模及模锻件的修正工序等。</p><h4 id="锻件图的制定"><a href="#锻件图的制定" class="headerlink" title="锻件图的制定"></a>锻件图的制定</h4><ul><li><p>分模面</p><ul><li><p>保证锻件能从模膛取出（a）</p></li><li><p>使模膛深度最浅（b）</p></li><li><p>分模面上下模锻外形一致（c）</p></li><li><p>使所需辅料最少</p></li><li><p>平面</p><p><img src="http://jpkc.hhuc.edu.cn/clcxjs/web/picture/2-3.ht3.gif" alt=""></p></li></ul></li></ul><ul><li><p>余料、公差和敷料</p><p>为了简化锻件形状，不予锻出添加的那部分金属称为敷料。</p><blockquote><p>孔的中间留有冲孔连皮（由于模锻无法直接锻出透孔，需在该处留有较薄的金属，称为冲孔连皮）</p></blockquote></li><li><p>模锻斜度</p><p>为了使锻件易于从模膛中取出，锻件与模膛侧壁接触部分需带一定斜度，锻件上的这一斜度称为模锻斜度</p></li></ul><h4 id="锻模模膛"><a href="#锻模模膛" class="headerlink" title="锻模模膛"></a>锻模模膛</h4><p>根据模膛的功能，锻模的模腔分为<strong>模锻模膛</strong>和<strong>制坯模膛</strong>两大类。</p><h5 id="模锻模膛"><a href="#模锻模膛" class="headerlink" title="模锻模膛"></a>模锻模膛</h5><ul><li><p>预锻模膛</p><p>使坯料变形接近锻件要求的形状和尺寸，这样在终锻模膛是，金属更容易填充模膛，从而减少模膛的磨损，延长寿命</p><blockquote><p><strong>预锻模膛的圆角和斜度要比终锻模膛要大，而且没有飞边槽</strong></p></blockquote></li><li><p>终锻模膛</p><p>终锻模膛的作用是使毛坯最后变形到锻件所要求的形状和尺寸，因此，它的形状应和锻件的<strong>形状相同</strong>，但因锻件冷却时要收缩，故终锻模膛的尺寸应比锻件<strong>尺寸放大一个收缩量</strong>。</p><p>沿模膛四周有飞边槽</p><blockquote><p>飞边槽的作用：①增加金属从模膛流出的阻力，使金属充满模膛②容纳多余的金属</p></blockquote></li></ul><h5 id="制坯模膛"><a href="#制坯模膛" class="headerlink" title="制坯模膛"></a>制坯模膛</h5><p>对于形状复杂的锻件，为了使毛坯形状基本符合锻件形状，以便使金属能合理分布和很好地充满模膛，就必须预先在制坯模膛内制坯。</p><ul><li>拔长模膛</li><li>滚压模膛</li><li>弯曲模膛</li><li>切断模膛</li></ul><h4 id="模锻工序的确定"><a href="#模锻工序的确定" class="headerlink" title="模锻工序的确定"></a>模锻工序的确定</h4><ul><li>长轴：常选用拔长、滚压、弯曲、预锻和终锻等工序</li><li>短轴（齿轮）：常选用镦粗、预锻和终锻等工序</li></ul><h4 id="修整工序"><a href="#修整工序" class="headerlink" title="修整工序"></a>修整工序</h4><ul><li>切边和冲孔</li><li>矫正</li></ul><h3 id="模锻将结构工艺性"><a href="#模锻将结构工艺性" class="headerlink" title="模锻将结构工艺性"></a>模锻将结构工艺性</h3><p>由于模锻件在锻模模膛中的成型条件比自由锻更加优越，因此模锻件形状比自由锻复杂</p><p>设计时应该遵循：</p><ul><li>必须保证锻件从模膛取出</li><li>模锻件形状应该简单（最小截面与最大截面之比如果小于0.5，那么锻件不易锻出）</li><li>模锻件尺寸精度高，表面粗糙度低。因此只有与其他机件配合才需要进行机械加工，零件上与锤击方向平行的应该设计出斜度，非加工表面形成的角应该为圆角</li><li>避免深孔、多孔结构</li><li>采用组合工艺</li></ul><h1 id="板料冲压"><a href="#板料冲压" class="headerlink" title="板料冲压"></a>板料冲压</h1><p>使板料经分离或成型而制件的工艺称为冲压</p><p>板料厚度＜4mm 时的金属板在常温下进行冲压，因此称为 <strong>冷冲压</strong>。只有当板料厚度超过 8-10mm 才采用 <strong>热冲压</strong></p><p>优点：</p><ul><li>便于自动化生产，生产率高</li><li>节省原材料，节省能源</li><li>产品重量轻，强度高，刚性好</li><li>产品尺寸稳定，互换性好，可加工形状复杂的零件</li></ul><h2 id="板料冲压基本工序"><a href="#板料冲压基本工序" class="headerlink" title="板料冲压基本工序"></a>板料冲压基本工序</h2><p>板料冲压的基本工序可以分为 <strong>分离工序</strong> 和 <strong>变形工序</strong> 两大类</p><h3 id="分离工序"><a href="#分离工序" class="headerlink" title="分离工序"></a>分离工序</h3><p>落料和冲孔统称<strong>冲裁</strong></p><p>落料是为了制取工件的外形，故冲下的部分为工件，带孔的为废料。</p><p>冲孔则相反，是要制取工件的内孔，故冲下的部分为废料，带孔的部分为工件。</p><h4 id="冲裁变形和分离过程"><a href="#冲裁变形和分离过程" class="headerlink" title="冲裁变形和分离过程"></a>冲裁变形和分离过程</h4><blockquote><p>记过程</p></blockquote><p>此过程分为<strong>弹性变形、塑形变形、断裂分离</strong>三个阶段</p><h4 id="冲裁件断面质量及其影响因素"><a href="#冲裁件断面质量及其影响因素" class="headerlink" title="冲裁件断面质量及其影响因素"></a>冲裁件断面质量及其影响因素</h4><p>冲裁面由 <strong>圆角带（a）、光亮带（b）、断裂带（c）和毛刺（d）</strong>组成</p><ul><li>圆角带a：冲裁过程中刃口附近材料被牵连拉入变形</li><li>光亮带b：人口切入金属板料后，板料与模具侧面挤压而形成的光亮而垂直的断面</li><li>断裂带c：刃口处微裂纹扩展形成</li><li>毛刺d：刃口附近侧面材料出现微裂纹</li></ul><p><strong>提高冲裁件质量，就是要增大光亮带高度，缩小圆角带和毛刺的高度，并较少从裁剪翘曲</strong></p><h4 id="凸凹模间隙"><a href="#凸凹模间隙" class="headerlink" title="凸凹模间隙"></a>凸凹模间隙</h4><p>凹凸模的间隙不仅严重影响冲裁件的断面质量，也影响模具寿命、卸料力、推件力和冲裁件的尺寸精度</p><div class="table-container"><table><thead><tr><th>类型</th><th>效果</th></tr></thead><tbody><tr><td>间隙过小</td><td>光亮面宽度增加，毛刺与圆角宽度减小，工件质量高，但是刀具寿命会减小，然后也会出现二次光带</td></tr><tr><td>间隙合适</td><td>光面占板厚的1/2-1/3，切断面的毛刺圆角和斜度均比较小，完全满足使用要求</td></tr><tr><td>间隙过大</td><td>断面光面减小，圆角与斜度增大，容易形成后而大的拉长毛刺，而且难以去除</td></tr></tbody></table></div><h4 id="凸凹模刃口尺寸的确定"><a href="#凸凹模刃口尺寸的确定" class="headerlink" title="凸凹模刃口尺寸的确定"></a>凸凹模刃口尺寸的确定</h4><p>确定原则如下：</p><ul><li>落料时，落料件的尺寸是由 <strong>凹模刃口</strong> 尺寸决定的，因此，应该以<strong>落料凹模</strong>为设计基准，考虑到凹模磨损后会使落料件尺寸增大，为提高刀具寿命，凹模刃口基本尺寸应该是落料件的<strong>最小极限尺寸</strong>。凸模尺寸 = 凹模尺寸 - 最小间隙值。</li><li>冲孔时，冲孔件的尺寸是由 <strong>凸模刃口</strong> 尺寸所确定的，因此应该以 <strong>冲孔凸模</strong> 为基准。考虑到凸模磨损会变小，因此，凸模刃口是冲孔件的 <strong>最大极限尺寸</strong>。凹模尺寸 = 凸模尺寸 + 最小间隙值</li></ul><h4 id="冲裁力计算"><a href="#冲裁力计算" class="headerlink" title="冲裁力计算"></a>冲裁力计算</h4><p>冲裁时材料对凸模的最大抗力称为冲裁力。</p><p>其大小与<strong>材质、料厚及冲裁件周边长度</strong>有关。</p><h4 id="修整"><a href="#修整" class="headerlink" title="修整"></a>修整</h4><p>修整是利用修整模沿冲裁件外缘或内孔刮削一薄层金属，以切掉普通冲裁时在冲裁件断面上存留的剪裂带和毛刺，从而提高冲裁件的尺寸精度和降低表面粗糙度。 </p><h4 id="切断"><a href="#切断" class="headerlink" title="切断"></a>切断</h4><p>切断是指用剪刃或冲模将板料沿不封闭轮廓进行分离的工序。</p><h3 id="变形工序"><a href="#变形工序" class="headerlink" title="变形工序"></a>变形工序</h3><ul><li><p>弯曲：将板料在弯矩作用下完成具有一定曲率和角度的制件的成型方法</p><p>弯曲时还应尽可能使<strong>弯曲线与坯料纤维方向垂直</strong>。若弯曲线与纤维方向一致，则容易产生破裂。</p><p><strong>回弹现象</strong>：由于材料的弹性形变的恢复，坯料会稍微弹回一点（凸凹模小一回转角）</p><p>工程中常用最小相对弯曲半径（$r_{\min}/\delta$，$\delta$为工件厚度）来限制弯曲变形的程度</p></li><li><p>拉深：变形区一拉一压的作用下，是平板成为<strong>开口的中心件</strong>而厚度不变的加工方法。</p><p>当拉深系数 $m=d/D$；一般来说，有$0.5\leq m\leq 0.8$。</p><p>当筒形件直径d与坯料直径D相差较大时，不能一次拉深至产品尺寸，而应进行多次拉深，并在中间穿插进行<strong>再结晶退火处理</strong>，以消除前几次拉深变形所产生的<strong>加工硬化现象</strong>。</p><p>拉深缺陷：</p><ul><li><p>拉裂（拉应力超过强度极限）</p></li><li><p>折皱（凸缘和凸模圆角部位变形最大，凸缘部分在圆周切线方向受压应力，压应力过大时，会发生折皱,坯料厚度愈小，拉深深度H愈大，愈容易产生折皱）</p><blockquote><p>可以使用有压板拉深来避免这个现象</p></blockquote></li></ul><p>防止措施</p><ul><li>凸凹模圆角半径应该合适 </li><li>凸凹模间隙应合适</li><li>合理控制拉深系数 m</li></ul></li><li><p>起伏</p></li><li><p>翻边</p></li><li><p>胀形</p></li></ul><h2 id="冲压件结构设计要求"><a href="#冲压件结构设计要求" class="headerlink" title="冲压件结构设计要求"></a>冲压件结构设计要求</h2><h3 id="对冲裁件要求"><a href="#对冲裁件要求" class="headerlink" title="对冲裁件要求"></a>对冲裁件要求</h3><ol><li>对冲裁剪力求结构简单、对称，尽可能使用圆形矩形等规则形状，应避免窄而长的形状</li><li>避免尖角，以圆弧过渡，以避免应力集中</li><li>冲裁件尺寸应考虑到厚度</li></ol><h3 id="对弯曲件要求"><a href="#对弯曲件要求" class="headerlink" title="对弯曲件要求"></a>对弯曲件要求</h3><ol><li>弯曲件应尽量对称，弯曲半径不能小于材料允许的最小弯曲半径，并考虑材料纤维方向</li><li>弯曲边过短不易成型</li><li>弯曲件带孔时，为了避免孔的变形，孔的边缘距弯曲中心应该有一段距离</li></ol><h3 id="对拉深件要求"><a href="#对拉深件要求" class="headerlink" title="对拉深件要求"></a>对拉深件要求</h3><ol><li>拉深件的结构应该简单、对称、且不宜太高</li><li>拉深件的圆角半径有要求</li><li>拉深件的壁厚变薄量一般要求不超过拉伸工艺壁厚变化的规律</li></ol><h2 id="冲压模具"><a href="#冲压模具" class="headerlink" title="冲压模具"></a>冲压模具</h2><p>一般可分为<strong>简单模、连续模和复合模</strong>三类。</p><h3 id="简单模"><a href="#简单模" class="headerlink" title="简单模"></a>简单模</h3><p>在压力机的一次行程中，只完成一道冲压工序的模具，称为简单模。 </p><h3 id="连续模"><a href="#连续模" class="headerlink" title="连续模"></a>连续模</h3><p>压力机的一次行程中，在模具的不同部位上同时完成数道冲<br>压工序的模具，称为连续模。</p><h3 id="复合模"><a href="#复合模" class="headerlink" title="复合模"></a>复合模</h3><p>利用压力机的一次行程，在模具的同一位置完成两道或两道以上工序的模具，称为复合模</p><h1 id="焊接工艺基础"><a href="#焊接工艺基础" class="headerlink" title="焊接工艺基础"></a>焊接工艺基础</h1><p>焊接是一种永久性连接金属材料的工艺方法，焊接过程的实质是利用加热或加压等手段，借助金属原子的结合与扩散作用，是金属材料牢固的连接起来。</p><p>焊接的方法可以分为3类：<strong>熔焊、压焊、钎焊</strong></p><div class="table-container"><table><thead><tr><th>名称</th><th>定义</th><th>细分</th></tr></thead><tbody><tr><td>熔焊</td><td>将焊接接头加热至熔化状态，不加压力的焊接方法</td><td>手工电弧焊、埋弧焊、氩弧焊CO2焊、电渣焊、等离子弧焊</td></tr><tr><td>压力焊</td><td>焊接过程中必须对工件施加压力，已完成焊接的方法</td><td>电阻焊（点焊、缝焊）等</td></tr><tr><td>钎焊</td><td>采用比母材熔点低的金属材料做钎焊，将焊件和钎料加热到高于钎料熔点，低于母材熔点的温度，利用液体钎料润湿母材</td><td>硬钎焊、软钎焊</td></tr></tbody></table></div><h2 id="电弧焊工艺基础"><a href="#电弧焊工艺基础" class="headerlink" title="电弧焊工艺基础"></a>电弧焊工艺基础</h2><h3 id="焊接电弧"><a href="#焊接电弧" class="headerlink" title="焊接电弧"></a>焊接电弧</h3><p>焊接电弧是在具有一定电压的电极和工件之间的气体介质中长时间放电现象，即在局部气体介质中有大量电子流过的导电现象</p><div class="table-container"><table><thead><tr><th>接法</th><th>解释</th><th>适用范围</th></tr></thead><tbody><tr><td>正接</td><td>焊件接正极，焊条接负极</td><td>厚板、酸性焊条</td></tr><tr><td>反接</td><td>焊件接负极，焊条接正极</td><td>薄板、碱性焊条</td></tr></tbody></table></div><h3 id="熔化焊冶金特点"><a href="#熔化焊冶金特点" class="headerlink" title="熔化焊冶金特点"></a>熔化焊冶金特点</h3><ul><li>熔化焊的本质是金属在焊接条件下的再次熔炼，是金属熔化结晶的过程</li><li>熔池存在时间少，温度高，冶金过程不充分，氧化严重，热影响区大</li><li>冷却速度快，结晶后易产生粗大的柱状晶</li></ul><h4 id="电弧焊冶金特点"><a href="#电弧焊冶金特点" class="headerlink" title="电弧焊冶金特点"></a>电弧焊冶金特点</h4><ul><li>电弧和熔池温度高于一般冶炼温度，是金属强烈蒸发，导致金属<strong>烧损</strong>或形成<strong>有害杂质</strong></li><li>熔池体积小，导致化学成分不均匀，容易产生<strong>气孔或夹杂</strong>等缺陷</li><li>熔池不断更新，有害物质不断进入形成<strong>氧化物、气孔、杂质</strong>等缺陷</li></ul><h3 id="熔化焊三要素"><a href="#熔化焊三要素" class="headerlink" title="熔化焊三要素"></a>熔化焊三要素</h3><ul><li><p><strong>热源</strong>：热量要集中，温度要高，以保证金属快速熔化，减小热影响区</p></li><li><p><strong>熔池的保护</strong>：渣保护、气保护、渣气保护</p><ul><li>形成熔融的液态焊剂薄膜，使熔池与空气隔绝，大大减少含气量，提高韧性</li><li>延长熔池时间，加强冶金反应，有利于气孔夹渣的析出</li></ul><blockquote><p>如焊条的药皮及二氧化碳加药芯是渣气联合保护</p></blockquote></li><li><p><strong>填充金属</strong>：保证焊缝填满及给焊缝带入有益的合金元素，并达到力学性能和其它性能的要求，主要有焊芯和焊丝</p></li></ul><h3 id="焊条"><a href="#焊条" class="headerlink" title="焊条"></a>焊条</h3><h4 id="焊条的型号"><a href="#焊条的型号" class="headerlink" title="焊条的型号"></a>焊条的型号</h4><ul><li>“E”代表焊条</li><li>前两位数字表示熔敷金属抗拉强度的最小值，单位为Mpa</li><li>第三位数字表示焊条的焊接位置</li><li>第三位和第四位数字组合时表示焊接电流种类及药皮类型</li></ul><div class="table-container"><table><thead><tr><th>类型</th><th>焊接工艺性</th><th>焊件性能</th><th>使用注意</th></tr></thead><tbody><tr><td>酸性焊条</td><td>好，适用于各种电源，操作性好，电弧稳定，成本低</td><td>焊缝强度低，渗合金作用弱</td><td>不宜用于承受重载和高强度要求的重要结构件</td></tr><tr><td>碱性焊条</td><td>差，一般要求采用直流电源，操作性差，电弧不稳定，成本高</td><td>焊缝强度高，渗合金作用强</td><td>只适合焊接重要结构件，易产生有毒物质，注意通风</td></tr></tbody></table></div><h4 id="选用原则"><a href="#选用原则" class="headerlink" title="选用原则"></a>选用原则</h4><ul><li><strong>等强度原则</strong></li><li>考虑<strong>焊接件的结构形状、钢板厚度、载荷性质和抗裂能力</strong></li><li><strong>低碳钢</strong>与<strong>低合金钢结构钢</strong>焊接，按<strong>强度较小</strong>的定</li><li>铸钢一般用碱性焊条</li></ul><h2 id="焊接接头组织与性能"><a href="#焊接接头组织与性能" class="headerlink" title="焊接接头组织与性能"></a>焊接接头组织与性能</h2><p>由于各点与焊缝中心位置距离不同，所受温度不同，相当于对焊接接头区域进行了一次不同规范的热处理，因此会有不同的结构与性能</p><p>整个焊接接头由<strong>焊缝区、熔合区、热影响区</strong>构成。</p><h3 id="焊缝区"><a href="#焊缝区" class="headerlink" title="焊缝区"></a>焊缝区</h3><p>在焊接接头横截面上的的金属。焊缝的结晶从熔池底壁开始向中心成长。由<strong>铁素体和少量珠光体</strong>所组成。因结晶是从熔池底部的半熔化区开始逐次进行的，低熔点的硫磷杂质和氧化铁等易偏析物集中在焊缝中心区，将影响焊缝的力学性能。</p><h3 id="熔合区"><a href="#熔合区" class="headerlink" title="熔合区"></a>熔合区</h3><p>加热温度在固液两相区之间，有明显的化学不均匀性。<strong>组织为少量的铸态组织和粗大的过热组织</strong>。塑性差，强度低，脆性大，易产生焊缝裂纹和脆性断裂、<strong>决定了焊接接头的性能</strong>。</p><h3 id="热影响区"><a href="#热影响区" class="headerlink" title="热影响区"></a>热影响区</h3><p>热影响区可分为<strong>过热区、正火区和部分相变区</strong>等。</p><p> 过热区——加热温度在Ac3 以上100~200℃至固相线温度区间。由于该区域内奥氏体晶粒急剧长大，形成过热组织，故塑性及韧性降低。 也是一个薄弱环节。</p><p>焊接热影响区的大小和组织性能变化的程度，决定于<strong>焊接方法、焊接参数、接头形式和焊接后冷却速度</strong>等因素。</p><p>在保证焊接质量的条件下，增加<strong>焊接速度或减少焊接电流</strong>都能减小焊接热影响区。</p><h2 id="焊缝应力与变形"><a href="#焊缝应力与变形" class="headerlink" title="焊缝应力与变形"></a>焊缝应力与变形</h2><h3 id="应力的产生"><a href="#应力的产生" class="headerlink" title="应力的产生"></a>应力的产生</h3><p>本质就是被焊结构件有不均匀的加热和冷却</p><p>当焊缝及相邻区金属处于加热阶段时都会膨胀，但受到焊件冷金属的阻碍，不能自由伸长而受压，<strong>形成压应力</strong>，该压应力使处于塑性状态的金属产生压缩变形。</p><p>随后再冷却到室温时，其收缩又受到周边冷金属的阻碍，不能缩到自由收缩所达到的位置，因而<strong>产生残余拉应力（焊接应力）</strong> </p><h3 id="变形的基本形式"><a href="#变形的基本形式" class="headerlink" title="变形的基本形式"></a>变形的基本形式</h3><ul><li>收缩变形：工件整体的变小，包括焊缝的纵向和横向收缩</li><li>角变形：焊缝截面上下不对称，焊缝收缩横向不均匀</li><li>弯曲变形：发生在焊缝在结构上不对称的情况下，纵向收缩不对称，导致工件向一侧弯曲</li><li>波浪边形：发生在焊接薄板时</li><li>扭曲变形：发生多对焊缝和长焊缝结构</li></ul><h3 id="防止措施（重点）"><a href="#防止措施（重点）" class="headerlink" title="防止措施（重点）"></a>防止措施（重点）</h3><p>等MOOC答案</p><h1 id="常见的焊接方法"><a href="#常见的焊接方法" class="headerlink" title="常见的焊接方法"></a>常见的焊接方法</h1><div class="table-container"><table><thead><tr><th>名称</th><th>特点</th><th>适用范围</th></tr></thead><tbody><tr><td>手工电弧焊</td><td>有结构简单、应用灵活方便、可焊各种金属等优点</td><td></td></tr><tr><td>埋弧焊</td><td>加工效率高；节约能源和材料；焊缝质量高；劳动条件好；使用位置，厚度受限制；对坡口加工要求高</td><td>长直焊缝和环焊缝</td></tr><tr><td>氩弧焊</td><td>焊缝小，能量集中；熔池保护好；可以全位置焊接；贵</td><td>易氧化的Fe合金等</td></tr><tr><td>CO2焊</td><td>成本低；生产效率高；合金元素烧损严重；易飞溅</td><td>黑色金属</td></tr><tr><td>电渣焊</td><td>生产效率高；焊后要进行热处理；焊接质量好；热影响区宽</td><td>厚板</td></tr><tr><td>压力焊</td><td>速度快；变形小；效率高；耗电；对接头形式有要求</td><td>-</td></tr></tbody></table></div><h2 id="手工电弧焊"><a href="#手工电弧焊" class="headerlink" title="手工电弧焊"></a>手工电弧焊</h2><p>焊芯与工件的熔化金属形成<strong>焊缝金属</strong>，焊条药皮产生的气体和熔渣<strong>保护熔池、稳定电弧、渗入合金</strong></p><p>有<strong>结构简单、应用灵活方便、可焊各种金属</strong>等优点</p><h2 id="埋弧焊"><a href="#埋弧焊" class="headerlink" title="埋弧焊"></a>埋弧焊</h2><blockquote><p>课堂上展开讲解了</p></blockquote><p>埋弧焊是一种电弧在焊剂层下燃烧并进行焊接的电弧焊</p><p>在焊接<strong>长直焊缝和环焊缝</strong>中与有明显的优点</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>焊接生产率高</li><li>节省焊接材料、电能</li><li>焊缝质量好（隔绝空气效果好，焊剂层保护效果好）</li><li>劳动条件好</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>焊接使用位置受限制</li><li>焊接厚度受限制</li><li>对坡口加工要求精度高，装配要求高</li></ul><h2 id="氩弧焊"><a href="#氩弧焊" class="headerlink" title="氩弧焊"></a>氩弧焊</h2><p>可以分为<strong>熔化氩弧焊和钨极氩弧焊</strong> </p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>氩弧焊电弧直径小，能量集中，电弧稳定</li><li>气体保护效果好，可以实现自动全位置焊接</li><li>适用于各种金属的焊接，可以实现单面焊双面成型</li><li>氩气贵</li></ul><h2 id="CO2焊"><a href="#CO2焊" class="headerlink" title="CO2焊"></a>CO2焊</h2><p>全位置焊接</p><h3 id="防飞溅措施"><a href="#防飞溅措施" class="headerlink" title="防飞溅措施"></a>防飞溅措施</h3><ul><li><strong>直流反接</strong></li><li>用含Si、Mn、Ti、Al 焊丝</li><li>采用药芯焊丝</li></ul><h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><ul><li>CO2氧化性强，焊缝金属烧损严重</li><li>只适用于黑色金属的焊接（低碳钢、低碳合金钢）</li></ul><h2 id="电渣焊"><a href="#电渣焊" class="headerlink" title="电渣焊"></a>电渣焊</h2><ul><li>最适合焊接厚大金属，可一次焊成，成本低</li><li>焊接材料和电能消耗少，焊接成本低（不需要预热）</li><li>焊缝液态金属停留时间长，焊缝质量好</li><li>热影响区宽，结晶晶粒粗大，焊后必须进行热处理（焊接能量大，加热冷却速度慢，高温停留时间长）</li></ul><h1 id="常用金属材料的焊接"><a href="#常用金属材料的焊接" class="headerlink" title="常用金属材料的焊接"></a>常用金属材料的焊接</h1><h2 id="金属焊接性"><a href="#金属焊接性" class="headerlink" title="金属焊接性"></a>金属焊接性</h2><p>用来评价金属焊接加工的难易程度。其内容包括两个方面：金属在焊接是对缺陷的敏感性（<strong>工艺焊接性</strong>）；焊接接头在使用过程中的可靠性，包括力学性能、耐热耐腐蚀等（<strong>使用焊接性</strong>）</p><h3 id="评定方法"><a href="#评定方法" class="headerlink" title="评定方法"></a>评定方法</h3><ul><li><p>实验法</p></li><li><p>碳当量法</p><p><strong>将合金元素的含量对焊接性能的影响程度转化为C的含量</strong>，其总和为碳当量</p><script type="math/tex; mode=display">W_{CE}=(W_C+\frac{W_{Mn}}{6}+\frac{W_{V}+W_{Cr}+W_{Mo}}{5}+\frac{W_{Ni}+W_{Cu}}{15})\times100\%</script><p>当 $W_{CE}\leq0.4\%$ 时，焊接性能优良（但是对板厚较大或在低温下应考虑预热）</p><p>当 $0.4\%\leq W_{CE}\leq 0.6\%$ 时，焊接性能较差。应考虑预热、缓冷、焊后热处理等工艺措施</p><p>当 $0.6\%\leq W_{CE}$ 时，焊接性能差，需要更高的温度和更严格的工艺措施防止焊接应力</p></li></ul><div class="table-container"><table><thead><tr><th>金属材料</th><th>焊条电弧焊</th><th>埋弧焊</th><th>氩弧焊</th><th>CO2焊</th><th>电渣焊</th><th>气焊</th><th>点焊</th><th>钎焊</th></tr></thead><tbody><tr><td>铸铁</td><td>A</td><td>C</td><td>B</td><td>B</td><td>B</td><td>A</td><td>D</td><td>C</td></tr><tr><td>铸钢</td><td>A</td><td>A</td><td>A</td><td>A</td><td>A</td><td>A</td><td>D</td><td>B</td></tr><tr><td>低碳钢</td><td>A</td><td>A</td><td>A</td><td>A</td><td>A</td><td>A</td><td>A</td><td>A</td></tr><tr><td>高碳钢</td><td>A</td><td>B</td><td>B</td><td>B</td><td>B</td><td>A</td><td>B</td><td>C</td></tr><tr><td>低合金钢</td><td>A</td><td>A</td><td>A</td><td>A</td><td>A</td><td>B</td><td>A</td><td>A</td></tr></tbody></table></div><h2 id="碳钢的焊接"><a href="#碳钢的焊接" class="headerlink" title="碳钢的焊接"></a>碳钢的焊接</h2><h3 id="低碳钢"><a href="#低碳钢" class="headerlink" title="低碳钢"></a>低碳钢</h3><p><strong>焊接性能最好</strong>，一般不需要采取特殊的工艺措施。</p><ul><li>在零度以下的低温环境中需要预热</li><li>在焊厚板时要焊后热处理（去应力退火）</li></ul><h3 id="中碳钢"><a href="#中碳钢" class="headerlink" title="中碳钢"></a>中碳钢</h3><ul><li>焊缝容易产生热裂纹</li><li>热影响区容易产生淬硬组织和冷裂纹</li></ul><p>需要采取以下措施：</p><ul><li><strong>焊前必须预热</strong>（使焊接时工件各部分的温差减小，以减小焊接应力，同时减慢热影响区的冷却速度，避免产生淬硬组织 ）</li><li>开坡口分层焊</li></ul><h3 id="高碳钢"><a href="#高碳钢" class="headerlink" title="高碳钢"></a>高碳钢</h3><p>焊接特点与中碳钢基本相似，进行焊接时，应采用更高的预热温度、更严格的工艺措施。</p><h3 id="低合金钢"><a href="#低合金钢" class="headerlink" title="低合金钢"></a>低合金钢</h3><ul><li>热影响区有淬硬倾向（合金元素越多，倾向越明显）</li><li>焊接接头有裂纹倾向</li></ul><blockquote><p>Q345(16Mn)与低碳钢差不多；Q420(15MnVN)焊前要高于150℃预热，焊后要热处理，要用抗裂性好的焊条</p></blockquote><h2 id="铸铁的补焊"><a href="#铸铁的补焊" class="headerlink" title="铸铁的补焊"></a>铸铁的补焊</h2><p>铸铁含碳量高，组织不均匀塑形低，<strong>焊接性能差</strong>，不应用铸铁设计和制造焊接结构件</p><h3 id="焊接特点"><a href="#焊接特点" class="headerlink" title="焊接特点"></a>焊接特点</h3><ul><li>熔合区易产生白口组织</li><li>易产生裂纹</li><li>易产生气孔</li><li>流动性好，因此只能用于平焊</li></ul><p>根据铸铁的焊接特点，易采用<strong>气焊和焊条电弧焊</strong></p><h3 id="焊接方法"><a href="#焊接方法" class="headerlink" title="焊接方法"></a>焊接方法</h3><h4 id="热焊法"><a href="#热焊法" class="headerlink" title="热焊法"></a>热焊法</h4><p>是焊前将工件整体或局部预热到600～700℃，焊补后缓慢冷却。 </p><p>热焊法能防止工件产生白口组织和裂纹，焊补质量较好，焊后可进行机械加工。</p><p>但<strong>热焊法成本较高，生产率低，焊工劳动条件差，尽量少用</strong>。 一般用于焊补形状复杂焊后需要加工的重要铸件，如床头箱、汽缸体等。</p><h4 id="冷焊法"><a href="#冷焊法" class="headerlink" title="冷焊法"></a>冷焊法</h4><p>补焊前工件不预热或只进行400℃以下的低温预热。</p><p>主要依靠焊条来调整焊缝化学成分，以防止或减少白口组织和避免裂缝。</p><p><strong>冷焊法方便灵活生产率高、成本低、劳动条件好，应用广泛</strong>。但焊接处切削加工性能较差。生产中多用于焊补要求不高的铸件以及怕高温预热引起变形的工件。</p><h3 id="防止白口组织"><a href="#防止白口组织" class="headerlink" title="防止白口组织"></a>防止白口组织</h3><ul><li>减缓冷却速度</li><li>增加有利于石墨化元素的含量</li><li>用异质材料焊接</li></ul><h2 id="焊接缺陷与检验"><a href="#焊接缺陷与检验" class="headerlink" title="焊接缺陷与检验"></a>焊接缺陷与检验</h2><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823214129.png" alt=""></p><div class="table-container"><table><thead><tr><th>序号</th><th>缺陷</th><th>原因</th></tr></thead><tbody><tr><td>a</td><td>焊瘤</td><td>焊条熔化速度过快，电弧过长，电流过大，焊速过慢，运条不当</td></tr><tr><td>b</td><td>裂纹</td><td>焊接结构不合理，焊缝冷却速度过快，含有 C、S、P 等元素</td></tr><tr><td>c</td><td>夹渣</td><td>未搅拌熔池，焊件不洁，电流过小，分层焊时未除焊渣</td></tr><tr><td>d</td><td>气孔</td><td>焊件不洁、焊条潮湿、电弧过长、电流过大，焊件含 C 高</td></tr><tr><td>e</td><td>咬边</td><td>电流过大，运条不当，电弧过长、焊接角度不对</td></tr><tr><td>f</td><td>未焊透</td><td>电流过大、焊速过快、运条不当</td></tr></tbody></table></div><p>外观检验</p><ul><li>着色检验</li><li>荧光检验</li><li>磁粉检验</li></ul><p>无损探伤</p><ul><li>声发射探伤</li><li>超声波探伤</li><li>激光全息探伤</li></ul><h2 id="有色合金的焊接"><a href="#有色合金的焊接" class="headerlink" title="有色合金的焊接"></a>有色合金的焊接</h2><p>使用氩弧焊、气焊、钎焊</p><h1 id="焊接结构设计"><a href="#焊接结构设计" class="headerlink" title="焊接结构设计"></a>焊接结构设计</h1><h2 id="焊接方法选择"><a href="#焊接方法选择" class="headerlink" title="焊接方法选择"></a>焊接方法选择</h2><ul><li><p>小批量钢结构件</p><ul><li>板厚 &lt; 3mm ，焊缝较短 ：<strong>CO2焊</strong></li><li>板厚 3-10mm，焊缝较短，强度较低：<strong>手工电弧焊</strong></li><li>板厚 &gt;10mm，焊缝为长直焊缝或环焊缝：<strong>埋弧焊</strong></li></ul></li><li><p>大批量钢结构件</p><ul><li>板厚 &lt;3mm，无密封要求：<strong>点焊</strong>；有密封要求：<strong>缝焊</strong></li><li>板厚 3-10mm，长直焊缝或环焊缝：<strong>CO2自动焊</strong></li><li>板厚 &gt;10mm，长直焊缝或环焊缝：<strong>埋弧焊</strong></li></ul></li><li><p>不锈钢、铝合金、铜合金</p><p>板厚 &lt;3mm，<strong>钨极氩弧焊</strong></p><p>板厚 3-10mm，长直焊缝或环焊缝：<strong>熔化极电弧焊</strong></p></li></ul><h2 id="焊接结构件的选择"><a href="#焊接结构件的选择" class="headerlink" title="焊接结构件的选择"></a>焊接结构件的选择</h2><ul><li><p>在满足性能的前提下，尽量选择焊接性能好的材料</p><blockquote><p>碳含量小的低合金钢比较好</p></blockquote></li><li><p>异种材料的焊接，特别需要注意焊接性能，尽量选择化学成分、物理性质相似的材料</p></li><li><p>减少焊缝数量，简化焊接工艺，增加焊件的强度与刚度</p></li><li><p>合理焊接结构件供应时的尺寸等</p></li></ul><h2 id="焊接件接头工艺的选择"><a href="#焊接件接头工艺的选择" class="headerlink" title="焊接件接头工艺的选择"></a>焊接件接头工艺的选择</h2><h3 id="接头形式的选择"><a href="#接头形式的选择" class="headerlink" title="接头形式的选择"></a>接头形式的选择</h3><p>焊接接头的基本形式有：对接、角接、搭接、T形接</p><ul><li>对接：受力均匀，应力集中较小，易保证焊缝质量，静载和疲劳强度比较高；对下料尺寸精度要求较高</li><li>搭接：两工件不在同一平面，受力复杂，容易产生附加弯矩；对下料尺寸精度要求不高，不需要坡口</li><li>角接和T形接：受力复杂，和搭接一样容易产生缺陷</li></ul><blockquote><p>接口形式与焊接方法的关系比较大。例如，<strong>手工电弧焊he埋弧焊可以用对接、角接、搭接、T形接；电渣焊可以用对接、角接、T形接；点焊和缝焊只能搭接；钎焊常用搭接</strong></p></blockquote><h3 id="坡口的选择"><a href="#坡口的选择" class="headerlink" title="坡口的选择"></a>坡口的选择</h3><ul><li>采用对接接头时，当 厚度 &lt; 6mm 时，常常使用 <code>I形坡口</code> （对接处留适当间隙）</li><li><code>V形坡口</code> 和 <code>U形坡口</code>，可以单向焊接，焊接性较好，但是角变形大，消耗焊条多</li><li><code>双V形坡口</code> 和 <code>双U形坡口</code>，需要两面施焊，受热均匀，变形小，消耗焊条少，不过结构受限制</li></ul><h3 id="焊缝的合理布置"><a href="#焊缝的合理布置" class="headerlink" title="焊缝的合理布置"></a>焊缝的合理布置</h3><ul><li><p>尽可能使焊缝分散布置</p><p>焊缝过于密集会使金属过热，使接头组织粗大</p></li><li><p>尽可能使焊缝对称分布</p><p>焊缝对称布置可减小焊接变形</p></li><li><p>使焊缝避开应力集中处</p></li><li><p>使焊缝避开机械加工表面</p></li><li><p>使焊缝处于便于操作的地方</p></li></ul><h1 id="金属切削加工"><a href="#金属切削加工" class="headerlink" title="金属切削加工"></a>金属切削加工</h1><h2 id="切削三要素"><a href="#切削三要素" class="headerlink" title="切削三要素"></a>切削三要素</h2><p>切削速度、进给量、切削深度</p><blockquote><p>不考</p></blockquote><h2 id="刀具材料"><a href="#刀具材料" class="headerlink" title="刀具材料"></a>刀具材料</h2><h3 id="对刀具材料的基本要求"><a href="#对刀具材料的基本要求" class="headerlink" title="对刀具材料的基本要求"></a>对刀具材料的基本要求</h3><ul><li>高的硬度和耐磨性</li><li>高的耐热性和化学稳定性</li><li>足够的强度和韧性</li><li>良好的工艺性</li><li>经济性</li></ul><h3 id="常用刀具材料"><a href="#常用刀具材料" class="headerlink" title="常用刀具材料"></a>常用刀具材料</h3><ul><li><p>高速钢</p><p>耐热性、硬度、耐磨性低于硬质合金；强度韧性工艺性优于硬质合金；价格比硬质合金便宜</p><blockquote><p>只能用于 <strong>中速切削</strong> </p></blockquote></li><li><p>硬质合金</p><p>以高熔点、高硬度的金属化合物做基体，以 Co 为黏合剂，用粉末冶金制成</p><p>有两大类： WC 与 Co 组成的 钨钴类（TG类，塑性好）；WC、Ti、Co 组成的（YT类，硬度高）</p><blockquote><p>塑性好的刀具适合切削脆性材料（且塑性好的材料容易磨损）；硬度高的刀具适合切削塑性材料（切塑性差的材料容易受到脆性冲击，崩刃）</p></blockquote></li><li><p>陶瓷材料</p><p>硬度高，耐磨性好，耐热性好，怕脆性冲击，容易崩刃</p></li></ul><h2 id="刀具的几何参数"><a href="#刀具的几何参数" class="headerlink" title="刀具的几何参数"></a>刀具的几何参数</h2><div class="table-container"><table><thead><tr><th>名称</th><th>定义</th></tr></thead><tbody><tr><td>前刀面</td><td>刀具上切削流过表面</td></tr><tr><td>主后刀面</td><td>刀具上与工件被切削面相对应的表面</td></tr><tr><td>副后刀面</td><td>刀具上与工件已加工表面相对应的表面</td></tr><tr><td>基面 $p_r$</td><td>过切削刃上某点，垂直于改点主运动方向的面</td></tr><tr><td>切削平面 $p_s$</td><td>过切削刃上某点，与切削刃相切并垂直于 $p_r$ 的面</td></tr><tr><td>正交平面 $p_o$</td><td>过切削刃上某点，同时垂直于 $p_r$ 和 $p_s$ 的面</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>名称</th><th>定义</th><th>影响</th></tr></thead><tbody><tr><td>主偏角 $\kappa_r$</td><td>在 $p_r$ 投影面内，主切削刃与进给运动方向夹角</td><td>①影响刀具寿命（角越小寿命越长）②影响切削分力大小（角越小，径向分力越大，容易出现变形和振动）</td></tr><tr><td>副偏角 $\kappa_r^{‘}$</td><td>在 $p_r$ 投影面内，副切削刃与进给运动反方向夹角</td><td>影响已加工表面粗糙度（角越小，粗糙度越小）（过小会使已加工表面与刀具接触摩擦，产生振动和噪音）</td></tr><tr><td>前角 $\gamma_o$</td><td>在 $p_o$ 投影面内，前刀面与基面夹角</td><td>①影响切屑的变形程度（角大，减小切屑变形，使切削其轻快，降低切削温度，减小磨损）②影响刀刃强度（角大，强度低，散热面积小）（精加工、韧性好材料，增大前角）</td></tr><tr><td>后角 $\alpha_o$</td><td>在 $p_o$ 投影面内，后刀面与基面夹角</td><td>①增大后角，减少摩擦，工件质量高②刀具强度低，散热体积减小，刀具寿命减小</td></tr><tr><td>刃倾角 $\lambda_s$</td><td>在 $p_s$ 投影面内，主切削刃与基面投影（下凹为正）</td><td>①影响刀具强度（正的容易损坏，为了保护已加工表面，精加工去0值或正值；负的增强刀头，但可能引起震动，用于粗加工）②影响切削流出方向（正：流向待加工表面；0：沿着与主切削刃垂直的方向；负：流向已加工表面）</td></tr></tbody></table></div><h2 id="金属切削过程"><a href="#金属切削过程" class="headerlink" title="金属切削过程"></a>金属切削过程</h2><h3 id="切削的形成过程"><a href="#切削的形成过程" class="headerlink" title="切削的形成过程"></a>切削的形成过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs flow">st=&gt;start: 切削层金属<br>op1=&gt;operation: 弹性变形<br>op2=&gt;operation: 塑形变形<br>op3=&gt;operation: 挤裂<br>op4=&gt;operation: 切离<br>end=&gt;end: 切屑<br><br>st-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;end<br></code></pre></td></tr></table></figure><h3 id="切屑的种类"><a href="#切屑的种类" class="headerlink" title="切屑的种类"></a>切屑的种类</h3><ul><li><p>带状切屑</p><p>用大前角的刀具、较高的切削速度和较小的进给量切削<strong>塑性材料</strong>时，容易得到带状切屑。</p><p>切削力平稳，加工面光洁，但是为了保护已加工表面需要进行断屑处理</p></li><li><p>节状切屑</p><p>用较低的切削速度、较大的进给量切削粗加工<strong>中等硬度</strong>的材料时得到的。工件表面比较粗糙。</p></li><li><p>崩碎切屑</p><p>在切削<strong>脆性材料</strong>时，产生的。刀尖容易磨损，振动，影响表面质量。</p></li></ul><blockquote><p>加大前角、提高切削速度、减小进给量 可以将节状切屑转化为带状切屑，试加工表面光滑</p></blockquote><h3 id="积屑瘤"><a href="#积屑瘤" class="headerlink" title="积屑瘤"></a>积屑瘤</h3><h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><p>当切屑沿着刀具的前刀面流出时，在一定的温度和压力作用下，与前刀面接触的切屑底层受到很大的切削阻力，导致这一层的流出速度减慢，逐渐形成了滞留层。当前刀面对滞留层的摩擦阻力超过金属材料内部结合力时，就会有一部分金属粘附在切削刃附近，形成<strong>积屑瘤</strong></p><h4 id="对加工影响"><a href="#对加工影响" class="headerlink" title="对加工影响"></a>对加工影响</h4><ul><li>起到了保护切削刃的作用，同时相当于增大了 $\gamma_o$ ，是切削轻快。<strong>粗加工</strong> 希望出现积屑瘤</li><li>积屑瘤不断的形成与脱落，影响了尺寸精度，使表面粗糙。<strong>精加工</strong> 不希望出现</li></ul><h4 id="控制措施"><a href="#控制措施" class="headerlink" title="控制措施"></a>控制措施</h4><ul><li><p><strong>塑形</strong>越大，越容易产生积屑瘤</p></li><li><p><strong>中温中速</strong>切削加工，最容易产生积屑瘤</p><blockquote><p>低速摩擦阻力小，不易产生积屑瘤；高速温高，摩擦阻力也小，不易产生</p></blockquote></li></ul><blockquote><p>改变切削速度是控制积屑瘤最有效的方法，此外加入切削液、增大前角可以抑制积屑瘤的形成</p></blockquote><h3 id="切削温度"><a href="#切削温度" class="headerlink" title="切削温度"></a>切削温度</h3><p>切削摩擦产生的热量分为了3块</p><div class="table-container"><table><thead><tr><th>名称</th><th>效果</th></tr></thead><tbody><tr><td>传入切屑</td><td>对加工有利</td></tr><tr><td>传入刀具</td><td>加速刀具磨损</td></tr><tr><td>传入工件</td><td>产生形状尺寸误差</td></tr></tbody></table></div><p>其主要影响因素为：</p><ul><li>切削速度</li><li>工件强度</li></ul><p>此外，导热性好的金属材料，可以降低切削温度</p><h3 id="刀具的磨损与耐用度"><a href="#刀具的磨损与耐用度" class="headerlink" title="刀具的磨损与耐用度"></a>刀具的磨损与耐用度</h3><ul><li>磨损分为三个阶段：初期磨损阶段、正常磨损阶段、急剧磨损阶段</li><li>耐用度是刃磨后的刀具自切削开始到磨损量达到磨钝标准所经历的切削时间</li></ul><h1 id="零件的结构工艺性"><a href="#零件的结构工艺性" class="headerlink" title="零件的结构工艺性"></a>零件的结构工艺性</h1><ul><li>尽量采用标准化参数</li><li>要便于装夹<ul><li>设置工艺凸台</li><li>设置凸缘或装夹孔</li></ul></li><li>要便与加工<ul><li>刀具不与工件干涉</li><li>留出退到空间</li><li>尽量采用标准刀具加工</li><li>孔轴线与端面垂直</li><li>配合表面尽量避免箱体外表面</li><li>增加工艺孔</li><li>增加加强肋</li><li>适当的采用零件的组合</li></ul></li><li>要便于提高生产效率<ul><li>加工面应该等高</li><li>同类结构要素要统一</li><li>减少装夹次数</li><li>键槽应该在同一侧</li><li>要减少加工面积</li></ul></li><li>要便于测量</li><li>要便于装配<ul><li>在配合要求的地方应该有倒角</li><li>圆柱销与盲孔配合要有出气孔</li><li>要留出扳手空间</li><li>同一方向应该只有一对配合表面</li></ul></li><li>要便于拆卸</li></ul><hr><p>Learning By Sharing，2018©Fu_Qingchen，Markdown，LaTeX</p>]]></content>
    
    
    <categories>
      
      <category>机械相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>金属工艺学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机械设计笔记</title>
    <link href="/2018/06/15/WHUT/MechanismDesign/"/>
    <url>/2018/06/15/WHUT/MechanismDesign/</url>
    
    <content type="html"><![CDATA[<p>主要讲了一些机械零件的选型计算。老师上复习课的时候说了下要记忆的公式，然后考了90%……</p><p>注：基于武汉理工大学MOOC、《机械原理与机械设计》（ISBN：9787040402827）</p><span id="more"></span><h1 id="机械设计需要记忆的公式汇总"><a href="#机械设计需要记忆的公式汇总" class="headerlink" title="机械设计需要记忆的公式汇总"></a>机械设计需要记忆的公式汇总</h1><hr><p><code>机械设计基础</code></p><script type="math/tex; mode=display">\psi_\sigma=\frac{2\sigma_{-1}-\sigma_0}{\sigma_0}</script><ul><li>$\psi_\sigma$ <strong>材料受循环正应力时的材料特性系数</strong></li><li>$\sigma_{-1},\sigma_0$ 循环特征值 r 为 -1、0 时的极限应力<blockquote><p>上面的式子可以通过 在极限应力图中AD段方程求解化简 得到</p></blockquote></li></ul><hr><p><code>机械设计基础</code></p><script type="math/tex; mode=display">S_\sigma=\frac{\sigma_{\max}^{'}}{\sigma_{\max}}=\frac{\sigma_{-1}}{(K_{\sigma})_D\sigma_a+\psi_\sigma\sigma_m}</script><ul><li>$S_\sigma$ <strong>稳定变应力状态下正应力安全系数</strong></li><li>$\sigma_\max^{‘}$ 极限应力</li><li>$\sigma_\max$ 危险界面上的最大应力</li><li>$(K_\sigma)_D$ 考虑到 <strong>应力集中、表面情况和绝对尺寸</strong> 而添加的系数<blockquote><p>其实 $\sigma_\max=(K_\sigma)_D\sigma_a+\psi_\sigma\sigma_m$ 是极限应力图中线段AD的方程（没错，又是它）</p></blockquote></li></ul><hr><p><code>机械设计基础</code></p><script type="math/tex; mode=display">S=\frac{S_\sigma S_\tau}{\sqrt{S_\sigma^2+S_\tau^2}}</script><ul><li>$S_\sigma,S_\tau$ 正应力、切应力安全系数</li></ul><hr><p><code>齿轮传动设计</code></p><script type="math/tex; mode=display">\sigma_F=Y_{Fa}Y_{Sa}Y_\epsilon\frac{KF_{t1}}{bm}</script><ul><li>$\sigma_F$ <strong>齿轮齿根弯曲疲劳应力</strong></li><li>$F_{t1}(N)$ 为小轮上圆周力 $F_{t1}=2000T_1(N\cdot m)/d_1(mm)$</li><li>$Y_{Fa},Y_{Sa},Y_\epsilon$ 齿形系数、应力修正系数、重合度系数；前两个乘起来又叫做复合系数</li><li>$K=K_AK_vK_\beta K_\alpha$</li><li>$b,m(mm)$ 轮齿齿宽、模数</li></ul><hr><p><code>齿轮传动设计</code></p><script type="math/tex; mode=display">\sigma_H=Z_EZ_HZ_\epsilon\sqrt{\frac{F_{t1}}{bd_1}\frac{u\pm1}{u}}</script><ul><li>$\sigma_H$ <strong>齿面接触疲劳应力</strong></li><li>$Z_E,Z_H,Z_\epsilon$ 弹性系数、节点区域系数、重合度系数（没错，又叫这个名字）</li><li>$u={z_2}/{z_1}$ <strong>其中1代表小齿轮，而非主动轮</strong></li><li>外啮合取为正，内啮合取负值</li><li>$b,d_1(mm)$ 轮齿齿宽，小齿轮直径</li></ul><hr><p><code>带传动设计</code></p><script type="math/tex; mode=display">L=2a\cos\beta+(\pi-2\beta)\frac{d_1}{2}+(\pi+2\beta)\frac{d_2}{2}\approx2a+\frac{\pi}{2}(d_1+d_2)+\frac{(d_2-d_1)^2}{4a}</script><script type="math/tex; mode=display">\alpha_1=\pi-2\beta\approx\pi-\frac{d_2-d_1}{a}</script><ul><li>$L$ <strong>带轮长度</strong></li><li>$d_1,d_2,a$ 小带轮直径、大袋轮直径、中心距</li></ul><blockquote><p>它用了一个代换式 $\beta\approx\sin\beta= (d_2-d_1)/2a$</p><p>这个看起来很难背，其实很容易忘，话说这玩意会考？emmmmmm</p></blockquote><hr><p><code>带传动设计</code></p><script type="math/tex; mode=display">\frac{F_1}{F_2}=e^{f_v\alpha}</script><ul><li>$F_1,F_2,f_v,\alpha$ 紧边拉力，松边拉力，当量摩擦系数，包角</li></ul><blockquote><p>著名的 <strong>欧拉公式</strong></p></blockquote><hr><p><code>螺纹连接</code></p><script type="math/tex; mode=display">F^{'}=\frac{K_fF_R}{fm}</script><ul><li>$F^{‘}$ <strong>预紧力</strong></li><li><strong>适用于轴向不受工作载荷的紧螺栓连接</strong></li><li>$K_f,F_R,f,m$ 可靠性系数，横向工作载荷，摩擦系数，<strong>结合面数量</strong></li></ul><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823214528.png" alt=""></p><blockquote><p>波波说要知道这个式子的物理意义。</p><p>这个式子是为了<strong>防止被连接件之间发生相对滑动，结合面之间的摩擦必须大于横向载荷</strong>得来的。</p><p>当收到<strong>轴向载荷</strong>时，上式的 <strong>F‘</strong> 应该为 <strong>F’’</strong></p></blockquote><hr><p><code>螺纹连接</code></p><script type="math/tex; mode=display">F_0=F^{''}+F=F^{'}+\frac{C_1}{C_1+C_2}F</script><ul><li>$F_0,F,F^{‘},F^{‘’}$ 总拉力、轴向工作载荷、预紧力、剩余预紧力</li><li><strong>适用于轴向受工作载荷的紧螺纹连接</strong></li><li>详细解释见下图，其中$C_1=\tan\theta_1,C_2=\tan\theta_2$</li></ul><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823214547.png" alt=""></p><hr><p><code>螺纹连接</code></p><script type="math/tex; mode=display">\sigma_a=\frac{\frac{1}{2}\frac{C_1}{C_1+C_2}F}{1{\pi d_1^2}/4}=\frac{C_1}{C_1+C_2}\frac{2F}{\pi d_1^2}\leq[\sigma_a]</script><ul><li>$\sigma_a$ <strong>受轴向变载荷螺栓的应力幅</strong></li><li>相关参数在前面</li><li>$\frac{C_1}{C_1+C_2}$ 是<strong>螺栓的相对刚度</strong>，为了提高螺栓的承载能力，应该使这个值尽可能<strong>小</strong></li><li>$\frac{C_2}{C_1+C_2}$ 是<strong>被连接件的相对刚度</strong>，为了提高螺栓的承载能力，应该使这个值尽可能<strong>大</strong></li></ul><hr><p><code>螺纹连接</code></p><script type="math/tex; mode=display">\sigma_{ca}=1.3\sigma=\frac{1.3F^{'}}{\pi d_1^2/4}\leq[\sigma]</script><ul><li>无论受不受轴向载荷，对受拉轴承都适用</li><li>$\sigma_{ca}$ 为复合拉应力</li><li>$d_1(mm)$ 为螺纹小径</li></ul><blockquote><p>$1.3$：在用 <strong>第四强度理论</strong> 对 大量螺栓 进行 <strong>统计分析</strong> 时发现，其复合拉应力的计算只需要将拉伸应力 $\sigma$ 扩大30%来考虑扭矩的影响（就是说，切应力懒得算了，直接把正应力扩大30%，得到的效果和算切应力是一样的）</p><p>波波让我们背的是这个：$d_1\geq\sqrt{\frac{4\times1.3F^{‘}}{\pi[\sigma]}}$ 这个和上面那个是一样的</p></blockquote><hr><p><code>轴的设计</code></p><script type="math/tex; mode=display">d\geq\sqrt[3]{\frac{9.55\times10^6}{0.2[\tau_T]}}\sqrt[3]{\frac{P}{n}}=C\sqrt[3]{\frac{P}{n}}</script><ul><li>$[\tau_T]$(MPa) 许用扭转应力</li><li>$P(kW),n(r/\min)$ 轴所传递的功率，轴的转速</li></ul><blockquote><p>波波说注意是 <strong>三次根号</strong> ，很多人搞错了</p></blockquote><hr><p><code>滑动轴承设计</code></p><script type="math/tex; mode=display">p=\frac{F}{Bd}\leq[p]\\v=\frac{n\pi d}{60\times1000}\leq[v]\\pv=\frac{F}{Bd}\frac{n\pi d}{60\times1000}\leq[pv]</script><ul><li>上式为<strong>径向滑动轴承的设计计算</strong></li><li>$F(N),B(mm),d(mm),n(r/\min),p(MPa),v(m/s)$ 径向载荷，工作宽度、轴颈直径、转速、轴承平均压强，滑动速度</li></ul><blockquote><p>验证 $pv$ 是为了限制摩擦功耗与温升</p></blockquote><hr><p><code>滑动轴承设计</code></p><script type="math/tex; mode=display">\frac{\partial p}{\partial x}=6\eta v\frac{h-h_0}{h^3}</script><ul><li>计算流体动压润滑轴承的基本方程</li><li>$\eta$ 流体粘度</li><li>$v$ 流体速度</li><li>$h$ 任意处油膜厚度</li><li>$h_0$ 当 $p=p_\max$ 时的油膜厚度</li></ul><blockquote><p>这。。。这玩意会考？×2</p></blockquote><hr><p><code>滑动轴承设计</code></p><script type="math/tex; mode=display">F=\frac{2\eta vB}{\psi^2}C_p</script><ul><li>$F$ <strong>液体摩擦径向滑动轴承所能承受的径向载荷</strong></li><li>$C_p$ 承载量系数，与长径比 B/d 有关</li><li>$\psi=(R-r)/r$ 相对间隙。相对间隙大，轴的承载能力小。设计时根据载荷和速度选取（$v\uparrow,F\downarrow\Rightarrow\psi\uparrow$）</li><li>$B$ 工作宽度</li></ul><hr><p><code>滚动轴承及其装置设计</code></p><script type="math/tex; mode=display">P=f_P(XF_R+YF_A)</script><ul><li>$P$ <strong>滚动轴承当量动载荷</strong></li><li>$X,Y$ 径向动载荷系数，轴向动载荷系数</li><li>$f_P$ 冲击载荷系数</li></ul><hr><p><code>滚动轴承及其装置设计</code></p><script type="math/tex; mode=display">L_h=\frac{10^6}{60n}(\frac{Cf_t}{P})^\varepsilon</script><ul><li>$L_h(h)$ 轴承寿命</li><li>$C$ 基本额定动载荷</li><li>$f_t$ 温度系数</li><li>$\varepsilon$ 寿命系数，球轴承 $\varepsilon=3$ ，滚子轴承 $\varepsilon=10/3$</li><li>$n(r/\min)$ 转速</li><li>$P(N)$ 当量动载荷</li></ul><hr><p>轴向力判断方法</p><ol><li>判明轴上全部轴向力（包括外载荷 $F_A$ 和内部轴向力 $F_S$），合力指向，确定 <code>压紧端</code> 和 <code>放松端</code></li><li><code>压紧端</code> <strong>轴向力 = ∑所有轴向力</strong>（<strong>除自身内部轴向力外</strong>）</li><li><code>放松端</code> <strong>轴向力 = 自身轴向力</strong></li></ol><ul><li><p>内部轴向力</p><ul><li><p>方向：使内外圈脱离的方向，即由小口指向大口</p></li><li><p>大小：</p></li></ul></li></ul><div class="table-container"><table><thead><tr><th>轴承类型</th><th>角接触球轴承C</th><th>角接触球轴承AC</th><th>角接触球轴承B</th><th>圆锥滚子轴承</th></tr></thead><tbody><tr><td><strong>$F_S$</strong></td><td>$0.5F_r$</td><td>$0.7F_r$</td><td>$1.1F_r$</td><td>$F_r/(2Y)$</td></tr></tbody></table></div><hr><p>2018©Fu_Qingchen</p><p>[参考资料]：冯雪梅,李波,韩少军.机械原理与机械设计.北京高等教育出版社.2014</p><p>[图片来源]：冯雪梅,李波,韩少军.机械原理与机械设计.北京高等教育出版社.2014[拍摄]</p><hr><div class="table-container"><table><thead><tr><th>名称</th><th>主要参数</th><th>选用参数</th><th>主要破坏形式</th><th>计算准则</th></tr></thead><tbody><tr><td>软齿面齿轮</td><td>m,z</td><td>m,z</td><td>齿面点蚀</td><td>按齿面接触疲劳强度计算；按齿根弯曲疲劳强度校核</td></tr><tr><td>硬齿面齿轮</td><td>m,z</td><td>m,z</td><td>轮齿折断</td><td>按齿根弯曲疲劳强度计算；按齿面接触疲劳强度校核</td></tr><tr><td>蜗杆</td><td>$m,\alpha,z,d,q,\gamma$</td><td>m,d1,q</td><td>胶合、点蚀、磨损</td><td>只按齿面接触疲劳强度计算；常常需要计算效率、验算热平衡</td></tr><tr><td><code>标准件</code>带</td><td>$a,d,L,\alpha$</td><td>P,n</td><td>打滑、疲劳破坏</td><td>保证带传动不打滑的前提下，充分发挥带的传动能力（算有效拉力极限值）</td></tr><tr><td><code>标准件</code>链</td><td>链节距p</td><td>？</td><td>铰链磨损、疲劳破坏</td><td>高速按功率曲线计算；低速按静强度计算；</td></tr><tr><td><code>标准件</code>键</td><td>l,b,h</td><td>轴径、轮毂长</td><td>压溃、磨损</td><td>强度校核</td></tr><tr><td>螺纹</td><td>比较多</td><td>？</td><td>断裂、压溃或剪断</td><td>受拉螺栓为静力或疲劳拉力计算</td></tr></tbody></table></div><h1 id="机械设计基础"><a href="#机械设计基础" class="headerlink" title="机械设计基础"></a>机械设计基础</h1><p>机械设计研究内容：<strong>机械零件的工作原理、选用、设计和计算</strong>。</p><p>本章<strong>是重点</strong>，本章的重点有：安全系数法求疲劳极限</p><h2 id="机械零件的工作能力及失效"><a href="#机械零件的工作能力及失效" class="headerlink" title="机械零件的工作能力及失效"></a>机械零件的工作能力及失效</h2><h3 id="机械零件的工作能力"><a href="#机械零件的工作能力" class="headerlink" title="机械零件的工作能力"></a>机械零件的工作能力</h3><p>在一定的运动、载荷和环境情况下，在预定的使用期限内，不发生失效的安全工作限度</p><p>表现在强度、刚度、耐磨性、振动稳定性等方面</p><h3 id="机械零件的失效"><a href="#机械零件的失效" class="headerlink" title="机械零件的失效"></a>机械零件的失效</h3><p>零件失去了工作能力</p><ul><li><strong>断裂</strong>：分为过载断裂（工作应力超过材料的强度极限）、疲劳断裂（工作一段时间之后，交变应力超过疲劳极限引起无征兆的断裂）</li><li><strong>变形</strong>：分为塑性变形、过大的弹性变形<code>机床上加工零件的主轴就有这方面的要求</code></li><li><strong>表面失效</strong>：压溃、过度磨损「表面的压应力过大，使表面变形」，表面疲劳损坏「表面接触应力过大」，胶合「工作温度 过高引起」、腐蚀</li></ul><h2 id="机械零件的计算准则"><a href="#机械零件的计算准则" class="headerlink" title="机械零件的计算准则"></a>机械零件的计算准则</h2><p>用于计算并确定零件的<strong>基本尺寸</strong>的主要依据</p><h3 id="强度准则"><a href="#强度准则" class="headerlink" title="强度准则"></a>强度准则</h3><p>针对零件断裂、塑形变形或表面疲劳、损坏失效。基本上每个零件都涉及到。</p><p>计算准则为：</p><p>$\sigma\leq[\sigma]$，$\tau\leq[\tau]$，$\sigma_H\leq[\sigma_H]$（表面疲劳损坏）</p><p>其中对于线接触的情况，接触应力可以由以下公式计算：</p><script type="math/tex; mode=display">\sigma_H=\sqrt{\frac{F_n}{\pi L}\frac{(\frac{1}{\rho_1}\pm\frac{1}{\rho_2})}{(\frac{1-\mu_1^2}{E_1}+\frac{1-\mu_2^2}{E_2})}}</script><p>这个公式在 <strong>齿轮</strong> 部分会再次出现，这里就不解释了</p><h3 id="刚度准则性"><a href="#刚度准则性" class="headerlink" title="刚度准则性"></a>刚度准则性</h3><p><code>非重点</code>针对大弹性变形</p><p>计算准则为：</p><p>$y\leq[y],\theta\leq[\theta],\phi\leq[\phi]$（分别为挠度、偏转角、扭转角）</p><h3 id="耐磨性准则"><a href="#耐磨性准则" class="headerlink" title="耐磨性准则"></a>耐磨性准则</h3><p><code>非重点</code>针对过度磨损，验算式子为：$p\leq[p]$</p><h3 id="振动和噪音准则"><a href="#振动和噪音准则" class="headerlink" title="振动和噪音准则"></a>振动和噪音准则</h3><p><code>非重点</code>针对高速机械的振动失稳（共振），防止共振条件为：$f_p\leq0.87f$ 或 $f_p\geq1.18f$（f为零件固有频率，fp为零件收振源作用引起的被迫振动频率）</p><h3 id="可靠性准则"><a href="#可靠性准则" class="headerlink" title="可靠性准则"></a>可靠性准则</h3><h2 id="变应力及表达"><a href="#变应力及表达" class="headerlink" title="变应力及表达"></a>变应力及表达</h2><p>载荷和应力的类型是按照是否变化而分类的，因此，有两种。</p><ul><li>静载荷（大小与方向<strong>都</strong>不随时间变化的载荷）与变载荷（大小<strong>或</strong>方向随时间变化的载荷）</li><li>静应力（大小与方向<strong>都</strong>不随时间变化的载荷<strong>或极其缓慢</strong>）与变应力（大小<strong>或</strong>方向随时间变化的量）</li></ul><p>机械零件一般都是变应力。。。</p><p>为了描述变应力这里有一些参数</p><h3 id="变应力参数"><a href="#变应力参数" class="headerlink" title="变应力参数"></a>变应力参数</h3><p>一般来说变应力是正弦变化的，因此我们可以把应力这样画出来：</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823214606.png" alt=""></p><p>可以发现有一些关键的数据：</p><p>最大应力 $\sigma_{max}$、最小应力 $\sigma_{min}$</p><p>平均应力$\sigma_{m}=\frac{\sigma_{max}+\sigma_{min}}{2}$、应力$\sigma_{a}=\frac{\sigma_{max}-\sigma_{min}}{2}$</p><p>循环特征 $r = \frac{\sigma_{min}}{\sigma_{max}}$（易得，$-1\leq r\leq1$）</p><p>然后呢有一些比较有名的特例，在后面也比较常见。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823214634.png" alt=""></p><h2 id="机械零件的疲劳极限"><a href="#机械零件的疲劳极限" class="headerlink" title="机械零件的疲劳极限"></a>机械零件的疲劳极限</h2><p><strong>【本章重点】</strong>满足强度要求是机械最基本的要求，然后强度又分为静应力强度和变应力强度，然后机械中最常见的又是变应力。。。</p><h3 id="疲劳损坏机理"><a href="#疲劳损坏机理" class="headerlink" title="疲劳损坏机理"></a>疲劳损坏机理</h3><p>先来研究一下这个，看看疲劳极限有什么东西有关：</p><p>变应力作用下的疲劳断裂有一下过程：零件表面应力超过极限值→微裂纹→扩展→裂纹</p><p>根据以往的经验，疲劳极限除了与 <strong>材料</strong> 有关，还与 <strong>循环特征 r</strong>、<strong>应力循环次数 N</strong>、应力集中、绝对尺寸及表面状态有关。</p><h3 id="疲劳极限"><a href="#疲劳极限" class="headerlink" title="疲劳极限"></a>疲劳极限</h3><p>知道了疲劳极限与什么有关之后就要开始求了。根据应力疲劳试验有以下图形：</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823214713.png" alt=""></p><p>对上图，一般取一个 <strong>规定</strong> 的 $N_0$，有一个对应的 $\sigma_r$，这个值就是材料的疲劳极限（也就是无限寿命疲劳极限）。</p><p>研究无限寿命区的疲劳极限没有意义（都无限寿命了就没极限了），有限寿命区的疲劳极限由图形可以得到：</p><script type="math/tex; mode=display">\sigma_{rN}=\sigma_r\sqrt[m]{N_0/N}</script><p>然而这个只能得到一种循环特征 r下的疲劳极限，而且应力疲劳试验做起来成本比较高。对每个 r 都做试验然后得到上面的式子显然不实际。<strong>极限应力图</strong> 解决了这个问题，工程上也常常用这个图来近似代替。</p><h3 id="极限应力图"><a href="#极限应力图" class="headerlink" title="极限应力图"></a>极限应力图</h3><p>以 $\sigma_a$ 为纵坐标，$\sigma_m$ 为横坐标，即可做出任意材料的极限应力图。工程上一般先测出 <em>对称循环</em> 和 <em>脉动循环</em> 的疲劳极限为 $\sigma_{-1},\sigma_{0}$，此时可以在图上画出3个点（静力点 $(\sigma_s,0)$、对称循环 $(0,\sigma_{-1})$、脉动循环 $(\sigma_0/2,\sigma_0/2)$）。根据这三个点，按照下图，即可画出由两条直线构成的曲线。这个曲线叫做 <strong>简化极限应力曲线</strong></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823214733.png" alt=""></p><p>这个曲线不但可以使用很少的已知数据 $(\sigma_{-1},\sigma_0,\sigma_s)$ 画出，而且能够满足设计的需要。</p><p>其中：</p><p>AD段方程为：$\sigma_a^{‘} = \sigma_{-1}+\sigma_m^{‘}\times\frac{\frac{\sigma_0}{2}-\sigma_{-1}}{\frac{\sigma_0}{2}}\Rightarrow\sigma_{-1}=\sigma_a^{‘}+\sigma_m^{‘}\times\psi_\sigma$</p><p>CD段方程为：$\sigma_s=\sigma_a^{‘}+\sigma_m^{‘}$</p><p>$r_D=\frac{\sigma_{-1}(\sigma_s-\sigma_0)}{\sigma_s(\sigma_0-\sigma_{-1})}$</p><p>其中，$\psi_\sigma=\frac{2\sigma_{-1}-\sigma_0}{\sigma_0}$ 为材料特性系数（课本）或等效系数（PPT）</p><p><strong>对于工作应力为$(\sigma_a,\sigma_m)$的一点来说：</strong></p><p>其应力循环特征 $r=\frac{\sigma_{\min}}{\sigma_{\max}}=\frac{\sigma_m-\sigma_a}{\sigma_m+\sigma_a}=\frac{1-\frac{\sigma_a}{\sigma_m}}{1+\frac{\sigma_a}{\sigma_m}}=\frac{1-\tan\alpha}{1+\tan\alpha}$</p><p>对应的疲劳极限 $\sigma_{\max}^{‘}=\sigma_m^{‘}+\sigma_a^{‘}$，与上方AD或CD段联立方程即可解出疲劳极限。</p><p>不过，以上内容并没有讨论<strong>应力集中、绝对尺寸及表面状态</strong> 对疲劳极限的影响。由于以上问题比较复杂，因此在工程中，使用 $(K_\sigma)_ D$ 来代替这些因素的影响。这样的话极限应力图就有了一些变化，就变成了曲线 A’B’D’C’</p><p>A’B’、C’D’段，需要将纵坐标  $\sigma_{-1},\sigma_0$ 替换为 $\frac{\sigma_{-1}}{(K_\sigma)_ D},\frac{\sigma_0}{(K_\sigma)_ D}$</p><p>此时：</p><p>AD段方程为：$\sigma_{-1}=(K_\sigma)_ D\sigma_a^{‘}+\psi_\sigma\sigma_m^{‘}$</p><p>CD段方程为：$\sigma_s=\sigma_a^{‘}+\sigma_m^{‘}$</p><p>然后上面还没有讨论切应力。切应力和正应力一样，只是需要<strong>将上面式中的 $\sigma$ 替换成 $\tau$ </strong></p><p>上面求出了极限应力的值，然后通常还要求 <strong>安全系数</strong></p><p>这个比较麻烦，然后我也忘记当时是怎么讲的了，直接给出结论：</p><p>在 <strong>单向应力</strong> 作用下</p><script type="math/tex; mode=display">S_{\sigma}=\frac{\sigma_r}{\sigma}=\frac{\sigma_\max^{'}}{\sigma_\max}=\frac{\sigma_s}{\sigma_a+\sigma_m},D^{'}C^{'}</script><script type="math/tex; mode=display">S_{\sigma}=\frac{\sigma_r}{\sigma}=\frac{\sigma_\max^{'}}{\sigma_\max}=\frac{\sigma_{-1}}{(K_{\sigma})_ D\sigma_a+\psi_{\sigma}\sigma_m},A^{'}D^{'}</script><p>在 <strong>复合应力</strong> 作用下</p><script type="math/tex; mode=display">S=\frac{S_{\sigma}S_\tau}{\sqrt{S_\sigma^2+S_\tau^2}}</script><h2 id="机械中的摩擦、磨损和润滑"><a href="#机械中的摩擦、磨损和润滑" class="headerlink" title="机械中的摩擦、磨损和润滑"></a>机械中的摩擦、磨损和润滑</h2><p>这一部分内容是抄的MOOC上面的</p><h3 id="摩擦"><a href="#摩擦" class="headerlink" title="摩擦"></a>摩擦</h3><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">解释</th><th style="text-align:center">摩擦系数</th></tr></thead><tbody><tr><td style="text-align:center">干摩擦</td><td style="text-align:center">表面间无任何润滑剂或保护膜的纯金属接触时的摩擦</td><td style="text-align:center">大于0.1</td></tr><tr><td style="text-align:center">边界摩擦</td><td style="text-align:center">表面间被极薄的润滑膜所隔开，且摩擦性质与润滑剂的粘度无关而取决于两表面的特性和润滑油油性的摩擦</td><td style="text-align:center">0.01-0.1</td></tr><tr><td style="text-align:center">流体摩擦</td><td style="text-align:center">表面间的润滑膜把摩擦副完全隔开，摩擦力的大小取决于流体分子内部摩擦力的摩擦</td><td style="text-align:center">0.001-0.008</td></tr><tr><td style="text-align:center">混合摩擦</td><td style="text-align:center">摩擦副处于干摩擦、边界摩擦和流体摩擦混合状态时的摩擦</td><td style="text-align:center">-</td></tr></tbody></table></div><h3 id="磨损"><a href="#磨损" class="headerlink" title="磨损"></a>磨损</h3><p>由于表面的相对运动而使物体工作表面的物质不断损失的现象。</p><p>零件的磨损过程大体可分为三个阶段：<strong>磨合磨损阶段、稳定磨损阶段及剧烈磨损阶段</strong></p><div class="table-container"><table><thead><tr><th>类型</th><th>解释</th></tr></thead><tbody><tr><td>表面疲劳磨损</td><td>摩擦表面受循环接触应力作用到达一定程度时，就会在零件工作表面形成疲劳裂纹，随着裂纹的扩展与相互连接，会造成许多微粒从零件表面上脱落下来，致使表面上出现许多浅坑，这种磨损过程即为疲劳磨损；</td></tr><tr><td>粘着磨损</td><td>摩擦表面的微凸体在相互作用的各点发生粘着作用，使材料由一表面转移到另一表面的磨损</td></tr><tr><td>磨粒磨损</td><td>摩擦表面间的游离硬颗粒或硬的微凸体峰间在较软的材料表面上犁刨出很多沟纹的微切削过程</td></tr><tr><td>腐蚀磨损</td><td>在摩擦过程中金属与周围介质发生化学反应而引起的磨损。</td></tr></tbody></table></div><h3 id="润滑"><a href="#润滑" class="headerlink" title="润滑"></a>润滑</h3><p>润滑的作用有：<strong>减少或防止磨损、降低温升、防锈</strong>、降低摩擦、缓冲和吸振</p><p><strong>润滑的原理会在后面介绍</strong></p><h1 id="齿轮传动设计"><a href="#齿轮传动设计" class="headerlink" title="齿轮传动设计"></a>齿轮传动设计</h1><p>齿轮主参数：<strong>m、z</strong></p><p>本章的重点为强度计算以及载荷系数</p><h2 id="齿轮的特点与分类"><a href="#齿轮的特点与分类" class="headerlink" title="齿轮的特点与分类"></a>齿轮的特点与分类</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><strong>优点</strong>：瞬时传动比恒定、传动效率高、工作使用效率高、结构紧凑、适用范围大</p><p><strong>缺点</strong>：成本高、精度低时噪音大，不易用于间距过大的转动</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>按照齿轮的工作条件：闭式、开式、半开式</li><li>按照齿面硬度分：软齿面（HB ≤ 350）、硬齿面（HB &gt; 350）</li></ul><h2 id="齿轮的主要失效形式和计算准则"><a href="#齿轮的主要失效形式和计算准则" class="headerlink" title="齿轮的主要失效形式和计算准则"></a>齿轮的主要失效形式和计算准则</h2><h3 id="齿轮的主要失效形式"><a href="#齿轮的主要失效形式" class="headerlink" title="齿轮的主要失效形式"></a>齿轮的主要失效形式</h3><h4 id="齿轮的折断"><a href="#齿轮的折断" class="headerlink" title="齿轮的折断"></a>齿轮的折断</h4><p>闭式齿轮当齿轮的齿面比较硬的时候容易发生</p><ul><li>疲劳折断：齿根应力集中、交变载荷反复作用、疲劳裂纹拓展</li><li>脆性折断：齿轮脆性材料、冲击、过载</li></ul><p><strong>防止措施</strong>：增大齿根厚度、加工精度、选择合理材料、材料热处理、增大心部韧性</p><blockquote><p>疲劳断裂往往从齿根受拉处开始发生</p></blockquote><h4 id="齿面的疲劳点蚀"><a href="#齿面的疲劳点蚀" class="headerlink" title="齿面的疲劳点蚀"></a>齿面的疲劳点蚀</h4><p>闭式齿轮传动的主要失效形式，软齿面上容易发生。</p><ul><li>点蚀原因：接触应力的反复作用</li><li>后果：渐开线被破坏，产生噪音，甚至不能工作</li></ul><p><strong>防止措施</strong>：<strong>增大齿面硬度</strong>、降低粗糙度、合理选择润滑油</p><blockquote><p>点蚀主要出现在节线附近的齿根表面上</p></blockquote><h4 id="齿面磨损"><a href="#齿面磨损" class="headerlink" title="齿面磨损"></a>齿面磨损</h4><p>开式齿轮传动主要失效形式</p><ul><li>原因：齿面有磨料存在</li><li>后果：齿面破坏、引起冲击振动</li></ul><p><strong>防止措施</strong>：改善润滑、<strong>提高齿面硬度</strong>、改用闭式齿轮传动</p><h4 id="齿面胶合"><a href="#齿面胶合" class="headerlink" title="齿面胶合"></a>齿面胶合</h4><p>胶合现象是指两表面尖峰接触后粘接，然后再被撕开。 <strong>高速重载</strong> 齿轮容易发生</p><ul><li>原因：齿面软、相对滑动速度高、温度高、润滑失效</li><li>后果：与上面类似</li></ul><p><strong>防止措施</strong>：改善润滑条件、<strong>提高齿面硬度</strong>、降低齿面粗糙度</p><h4 id="塑性变形"><a href="#塑性变形" class="headerlink" title="塑性变形"></a>塑性变形</h4><p>有两种：齿体塑性变形（歪了）、齿面塑性变形（齿面材料沿摩擦力反向流动）</p><ul><li>原因：齿面软、润滑失效</li></ul><p><strong>防止措施</strong>：<strong>提高齿面硬度</strong>、提高润滑粘度</p><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">原因</th><th style="text-align:left">防止措施</th></tr></thead><tbody><tr><td style="text-align:left">轮齿的折断</td><td style="text-align:left">疲劳折断：齿根应力集中、交变载荷反复作用、疲劳裂纹拓展  脆性折断：齿轮脆性材料、冲击、过载</td><td style="text-align:left">增大齿根厚度、加工精度、选择合理材料、材料热处理、增大心部韧性</td></tr><tr><td style="text-align:left">齿面点蚀</td><td style="text-align:left">接触应力的反复作用</td><td style="text-align:left"><strong>增大齿面硬度</strong>、降低粗糙度、合理选择润滑油</td></tr><tr><td style="text-align:left">齿面磨损</td><td style="text-align:left">齿面有磨料存在</td><td style="text-align:left">改善润滑、<strong>提高齿面硬度</strong>、改用闭式齿轮传动</td></tr><tr><td style="text-align:left">齿面胶合</td><td style="text-align:left">齿面软、相对滑动速度高、温度高、润滑失效</td><td style="text-align:left">改善润滑条件、<strong>提高齿面硬度</strong>、降低齿面粗糙度</td></tr><tr><td style="text-align:left">塑性变形</td><td style="text-align:left">齿面软、润滑失效</td><td style="text-align:left"><strong>提高齿面硬度</strong>、提高润滑粘度</td></tr></tbody></table></div><h3 id="齿轮传动设计准则"><a href="#齿轮传动设计准则" class="headerlink" title="齿轮传动设计准则"></a>齿轮传动设计准则</h3><div class="table-container"><table><thead><tr><th style="text-align:center">齿轮类型</th><th style="text-align:center">主要失效形式</th><th style="text-align:center">设计准则</th><th style="text-align:center">校核准则</th></tr></thead><tbody><tr><td style="text-align:center">闭式软齿面</td><td style="text-align:center">齿面点蚀</td><td style="text-align:center">齿面接触疲劳强度</td><td style="text-align:center">齿根弯曲疲劳强度</td></tr><tr><td style="text-align:center">闭式硬齿面</td><td style="text-align:center">轮齿折断</td><td style="text-align:center">齿根弯曲疲劳强度</td><td style="text-align:center">齿面接触疲劳强度</td></tr><tr><td style="text-align:center">开式齿轮</td><td style="text-align:center">齿面磨损</td><td style="text-align:center">多按齿面弯曲疲劳强度</td><td style="text-align:center">？</td></tr></tbody></table></div><h2 id="齿轮材料与热处理"><a href="#齿轮材料与热处理" class="headerlink" title="齿轮材料与热处理"></a>齿轮材料与热处理</h2><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p>内软外硬、良好的机械加工和热处理、价格低</p><h3 id="常用材料"><a href="#常用材料" class="headerlink" title="常用材料"></a>常用材料</h3><p>锻钢（最常用）、铸钢（比较大的齿轮）、铸铁（速度低，功率不大的齿轮）、有色金属（常用于化工、医疗方面）</p><h2 id="齿轮传动的计算载荷"><a href="#齿轮传动的计算载荷" class="headerlink" title="齿轮传动的计算载荷"></a>齿轮传动的计算载荷</h2><p>计算载荷：名义载荷 × 载荷系数</p><p>载荷系数： $K = K_AK_vK_\beta K_\alpha$</p><h3 id="使用系数-K-A"><a href="#使用系数-K-A" class="headerlink" title="使用系数 $K_A$"></a>使用系数 $K_A$</h3><p>考虑到 <strong>外部因素</strong> （冲击振动）引起的附加动载荷影响的系数</p><p>与 <strong>原动机与工作机的工作状态</strong> 有关</p><h3 id="动载系数-K-v"><a href="#动载系数-K-v" class="headerlink" title="动载系数 $K_v$"></a>动载系数 $K_v$</h3><p>考虑到 <strong>齿轮本身的制造精度、运转速度</strong> 引起的附加动载荷影响的系数（齿轮齿距不相等→齿轮啮合时齿面有冲击载荷）</p><p>与 <strong>齿轮速度、齿形误差、轮齿啮合刚度</strong> 有关（精度↑,速度↓ → $K_v$↓；齿轮心部刚度↓ → 变形↑ → 间隙↓ → 载荷分布均匀）</p><p>减少影响：提高精度、齿廓修形</p><h3 id="齿向载荷分布系数-K-beta"><a href="#齿向载荷分布系数-K-beta" class="headerlink" title="齿向载荷分布系数 $K_\beta$"></a>齿向载荷分布系数 $K_\beta$</h3><p>考虑到<strong>轴安装的过程中轴的误差（轴装歪了），以及变形引起的载荷分布不均匀现象</strong>的影响系数</p><p><strong>当齿宽较小、齿轮轴刚度较大，齿面较软，齿轮对称布置时，$K_\beta$ 较小</strong>（齿面越软，接触越多）</p><h3 id="齿间载荷分布系数-K-alpha"><a href="#齿间载荷分布系数-K-alpha" class="headerlink" title="齿间载荷分布系数 $K_\alpha$"></a>齿间载荷分布系数 $K_\alpha$</h3><p>考虑到 <strong>单齿啮合和多齿啮合载荷分布不均匀</strong> 对的影响的系数</p><p>影响其因素有：重合度、齿轮刚度（齿面硬，数值大）、齿面精度</p><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">引起原因</th><th style="text-align:center">影响因素</th></tr></thead><tbody><tr><td style="text-align:center">使用系数 $K_a$</td><td style="text-align:center">外部因素（如冲击、振动）</td><td style="text-align:center">原动机和工作机的工作状态</td></tr><tr><td style="text-align:center">动载系数 $K_v$</td><td style="text-align:center">齿轮本身的制造误差、运转速度使啮合时齿间产生冲击造成附加动载</td><td style="text-align:center">制造精度、运转速度、齿轮啮合刚度（越大越不均匀）</td></tr><tr><td style="text-align:center">齿向载荷分布系数 $K_\beta$</td><td style="text-align:center">由于轴的安装误差和轴、轴承的变形（轴歪了）等引起的载荷分布不均匀</td><td style="text-align:center">轴的刚度、齿面硬度、齿宽（越大越不均匀）</td></tr><tr><td style="text-align:center">齿间载荷分布系数 $K_\alpha$</td><td style="text-align:center">单齿啮合和多齿啮合引起的载荷分布不均匀</td><td style="text-align:center">重合度、齿轮精度、齿面硬度</td></tr></tbody></table></div><blockquote><p><strong>斜齿轮传动十分平稳，因此 K 比圆柱齿轮小；锥齿轮设计误差和制造误差大，因此 K 比圆柱齿轮大</strong></p></blockquote><h2 id="齿轮的结构设计"><a href="#齿轮的结构设计" class="headerlink" title="齿轮的结构设计"></a>齿轮的结构设计</h2><p>结构设计要考虑齿轮的几何尺寸、毛坯材料、加工工艺、使用等因素。通常是先按照齿轮的直径大小，选择合适的结构形式然后再根据经验数据完成结构设计。常用的结构形式有齿轮轴、实心式齿轮、腹板式齿轮、轮辐式齿轮、组装齿卷式结构等等。</p><p><strong>注：选择的范围并不是特别的严格</strong></p><h3 id="齿轮轴"><a href="#齿轮轴" class="headerlink" title="齿轮轴"></a>齿轮轴</h3><p>齿轮和轴做成一体的轴。</p><p>当圆柱齿轮齿根圆到键槽底面的径向距离 $e\leq2.5 m(m_n)$，要制作成齿轮轴。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823214828.png" alt=""></p><p>制作成这样的原因是很难做出来，即使制作出来轮毂的强度也不够。</p><h3 id="实心式齿轮"><a href="#实心式齿轮" class="headerlink" title="实心式齿轮"></a>实心式齿轮</h3><p>最基本最简单的齿轮。</p><p>当 $d_a\leq200mm$ 且 $e\geq 2.5m(m_n)$ 时，做成实心式齿轮。</p><h3 id="腹板式齿轮"><a href="#腹板式齿轮" class="headerlink" title="腹板式齿轮"></a>腹板式齿轮</h3><p>当 $200mm\leq d_a \leq 500mm$ 时，通常采用腹板式齿轮。</p><p>目的是减少质量、节约材料。</p><h3 id="轮辐式齿轮"><a href="#轮辐式齿轮" class="headerlink" title="轮辐式齿轮"></a>轮辐式齿轮</h3><p>$d_a=400\sim1000mm$ 时，采用轮辐式铸造结构。</p><p>目的还是减少质量、节约材料。</p><h3 id="镶套式齿轮"><a href="#镶套式齿轮" class="headerlink" title="镶套式齿轮"></a>镶套式齿轮</h3><p>当齿轮要使用比较好的材料时，可以将齿圈用好材料；齿轮本体用差的材料两者镶套起来的叫做嵌套式齿轮。</p><p>好处是：节约材料，而且当齿轮磨损之后也只用更换齿圈。</p><h3 id="焊接式齿轮"><a href="#焊接式齿轮" class="headerlink" title="焊接式齿轮"></a>焊接式齿轮</h3><p>用钢板焊接出来的齿轮。</p><p>适用于单件生产、尺寸过大又不利于铸造的齿轮</p><p>缺点是有焊接内应力</p><h2 id="受力分析"><a href="#受力分析" class="headerlink" title="受力分析"></a>受力分析</h2><h3 id="直齿圆柱齿轮"><a href="#直齿圆柱齿轮" class="headerlink" title="直齿圆柱齿轮"></a>直齿圆柱齿轮</h3><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823214846.png" alt=""></p><div class="table-container"><table><thead><tr><th>名称</th><th>计算公式</th><th>方向</th></tr></thead><tbody><tr><td>圆周力 $F_t$ (tangential)</td><td>$F_t=2T_1/d_1$</td><td>主反从同</td></tr><tr><td>径向力 $F_r$ (radial)</td><td>$Fr=F_t\tan\alpha$</td><td>指向圆心</td></tr><tr><td>法向力 $F_n$ (normal)</td><td>$F_n=F_t/\cos\alpha$</td><td>前两个矢量和成</td></tr></tbody></table></div><p>（其中T1=9548·P/n为小齿轮扭矩；d1为小齿轮节圆直径，SI）</p><h3 id="斜齿圆柱齿轮"><a href="#斜齿圆柱齿轮" class="headerlink" title="斜齿圆柱齿轮"></a>斜齿圆柱齿轮</h3><div class="table-container"><table><thead><tr><th>名称</th><th>计算公式</th><th>方向</th></tr></thead><tbody><tr><td>圆周力 $F_t$</td><td>$F_t=2T_1/d_1$</td><td>主反从同</td></tr><tr><td>径向力 $F_r$</td><td>$F_r=F_t\tan\alpha_n/\cos\beta$</td><td>指向圆心</td></tr><tr><td>法向力 $F_n$</td><td>$F_n=F_t/(\cos\alpha_n\cos\beta)$</td><td>合成</td></tr><tr><td>轴向力 $F_a$</td><td>$F_a=F_t\tan\beta$</td><td>主动轮右手定则（四指为旋转方向，大拇指为受力方向）</td></tr></tbody></table></div><h2 id="齿轮齿面接触疲劳强度"><a href="#齿轮齿面接触疲劳强度" class="headerlink" title="齿轮齿面接触疲劳强度"></a>齿轮齿面接触疲劳强度</h2><h3 id="直齿圆柱齿轮-1"><a href="#直齿圆柱齿轮-1" class="headerlink" title="直齿圆柱齿轮"></a>直齿圆柱齿轮</h3><p>$\propto$ 接触应力、齿轮材料许用接触应力</p><p>齿轮轮齿节线接触为体接触，此时运用 <strong>赫兹公式</strong></p><script type="math/tex; mode=display">\sigma _ H=\sqrt{\frac{F_n}{\pi L}\frac{(\frac{1}{\rho_1}\pm\frac{1}{\rho_2})}{(\frac{1-\mu_1^2}{E_1}+\frac{1-\mu_2^2}{E_2})}}=Z_E\sqrt{\frac{F_n}{L}·\frac{1}{\rho_\Sigma}}(MPa)</script><ul><li><p>$F_n(N)$ ：正压力</p><ul><li>计算载荷为$F_{nc}=KF_n=\frac{KF_t}{\cos\alpha}$</li></ul></li><li><p>$L(mm)$ ：接触线长度$L=b_r=\frac{b}{Z_\varepsilon^2}$</p><p>其中$b_r$为有效齿宽，$Z_\varepsilon$为<strong>直齿轮重合度系数</strong></p></li><li><p>$\rho_\Sigma(mm)$ ：综合曲率半径$\frac{1}{\rho_\Sigma}=\frac{1}{\rho_1}\pm\frac{1}{\rho_2}$</p><p>其中 $\rho=\frac{d}{2}\sin\alpha$ （就是基圆半径）</p><p>令$\frac{d_2}{d_1}=\frac{Z_2}{Z_1}=u$，则$\frac{1}{\rho_\Sigma}=\frac{2}{d_1\cos\alpha\tan\alpha^{‘} }\frac{u\pm1}{u}$</p><p>其中，令$Z_H=\sqrt {\frac{2}{\cos^2\alpha\tan\alpha^{‘} } }$，记为<strong>节点区域系数 </strong></p></li><li><p>$(\pm)$ ：外接触取正号，内接触取负号</p></li><li><p>$Z_E(\sqrt{MPa})$ ：<strong>材料弹性系数</strong>$Z_E=\sqrt{\frac{1}{\pi(\frac{1-\mu_1^2}{E_1}+\frac{1-\mu_2^2}{E_2})} }$</p><p>其中 E 为弹性模量，μ 为泊松比</p></li></ul><p>经过整理，可得<strong>齿面接触疲劳强度的校核公式</strong></p><script type="math/tex; mode=display">\sigma_H=Z_E Z_H Z_\varepsilon\sqrt{\frac{KF_t}{bd_1}·\frac{u\pm1}{u}}\leq[\sigma]_ H</script><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">计算式</th><th style="text-align:center">影响因素</th></tr></thead><tbody><tr><td style="text-align:center">材料弹性系数 $Z_E$</td><td style="text-align:center">$Z_E=\sqrt{1/[{\pi(\frac{1-\mu_1^2}{E_1}+\frac{1-\mu_2^2}{E_2})}]}$</td><td style="text-align:center">弹性模量、柏松比</td></tr><tr><td style="text-align:center">节点区域系数 $Z_H$</td><td style="text-align:center">$Z_H=\sqrt{4/\sin{2\alpha}}$</td><td style="text-align:center">节点处齿廓曲率</td></tr><tr><td style="text-align:center">直齿轮重合度系数 $Z_\varepsilon$</td><td style="text-align:center">$Z_\varepsilon=\sqrt{(4-\varepsilon_a)/3}$</td><td style="text-align:center">重合度</td></tr><tr><td style="text-align:center">齿宽系数 $\psi_d$</td><td style="text-align:center">$\psi_d=b/d_1$</td><td style="text-align:center">-</td></tr></tbody></table></div><blockquote><p>大齿轮与小齿轮应力相同，但许用应力不一定相同。</p></blockquote><p>式中：u 是 齿数比 $u=z_2/z_1$，u &gt; 1（1为小齿轮，2为大齿轮）</p><h3 id="斜齿圆柱齿轮-1"><a href="#斜齿圆柱齿轮-1" class="headerlink" title="斜齿圆柱齿轮"></a>斜齿圆柱齿轮</h3><p>斜齿轮和直齿轮差不多，就是多了一个系数。</p><script type="math/tex; mode=display">\sigma_H=Z_E Z_H Z_\varepsilon Z_\beta\sqrt{\frac{KF_t}{bd_1}·\frac{u\pm1}{u}}\leq[\sigma]_ H</script><p>注：查表时使用 <strong>当量齿数</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">计算式</th><th style="text-align:center">影响因素</th></tr></thead><tbody><tr><td style="text-align:center">螺旋角系数 $Y_\beta$</td><td style="text-align:center">$Z_\beta=\sqrt{\cos\beta}$</td><td style="text-align:center">螺旋角</td></tr></tbody></table></div><h2 id="齿轮齿根弯曲强度"><a href="#齿轮齿根弯曲强度" class="headerlink" title="齿轮齿根弯曲强度"></a>齿轮齿根弯曲强度</h2><h3 id="直齿圆柱齿轮-2"><a href="#直齿圆柱齿轮-2" class="headerlink" title="直齿圆柱齿轮"></a>直齿圆柱齿轮</h3><p>计算齿根弯曲强度时将齿根当做悬臂梁，计算得出。</p><p>首先是判断危险界面</p><h4 id="30°切线法"><a href="#30°切线法" class="headerlink" title="30°切线法"></a>30°切线法</h4><p>作与轮齿轴线成30°角的直线与<strong>齿轮圆角过渡曲线</strong>相切，过两切点并垂直于轴线的面就是危险截面</p><h4 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h4><script type="math/tex; mode=display">\sigma_{F1}=\frac{M}{W}=\frac{F_n\cos\alpha_Fh_F}{bs_F^2/6}=\frac{KF_t}{bm}Y_{F1}Y_{S1}Y_{\varepsilon}</script><div class="table-container"><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>齿形系数 $Y_F$</td><td>考虑到轮齿几何形状对齿根弯曲应力的影响。<strong>决定于齿数，与模数无关。</strong></td></tr><tr><td>应力修正系数 $Y_S$</td><td>考虑到齿轮过渡圆角处应力集中和剪切应力及压应力对齿根应力影响</td></tr><tr><td>重合度系数 $Y_\varepsilon$</td><td>顾名思义</td></tr></tbody></table></div><blockquote><p>注：大齿轮与小齿轮是不同的</p></blockquote><h3 id="斜齿圆柱齿轮-2"><a href="#斜齿圆柱齿轮-2" class="headerlink" title="斜齿圆柱齿轮"></a>斜齿圆柱齿轮</h3><p>按照发面当量圆柱齿轮计算。然后也是多了一个系数</p><script type="math/tex; mode=display">\sigma_{F1}==\frac{KF_t}{bm_n}Y_{F1}Y_{S1}Y_{\varepsilon}Y_\beta</script><p>然后注意：模数为<strong>法向模数</strong>，查表采用 <strong>当量齿数</strong></p><h2 id="锥齿轮相关"><a href="#锥齿轮相关" class="headerlink" title="锥齿轮相关"></a>锥齿轮相关</h2><p><strong>标准参数在大端</strong>，<strong>不考虑与重合度相关的因素</strong>（$K_\varepsilon,Z_\varepsilon,Y_\varepsilon$），按当量齿数 $z_v=z/\cos\delta_1$ 查表。</p><h3 id="受力分析-1"><a href="#受力分析-1" class="headerlink" title="受力分析"></a>受力分析</h3><div class="table-container"><table><thead><tr><th>名称</th><th>相关公式</th><th>方向</th></tr></thead><tbody><tr><td>圆周力 $F_t$</td><td>$F_{t1}=-F_{t2}$</td><td>主反从同</td></tr><tr><td>径向力 $F_r$</td><td>$F_{r1}=-F_{a2}$</td><td>指向圆心</td></tr><tr><td>轴向力 $F_a$</td><td>$F_{a1}=-F_{r2}$</td><td>指向大端</td></tr></tbody></table></div><h3 id="载荷系数"><a href="#载荷系数" class="headerlink" title="载荷系数"></a>载荷系数</h3><p>$K=K_AK_vK_\beta$</p><h3 id="齿面接触疲劳强度"><a href="#齿面接触疲劳强度" class="headerlink" title="齿面接触疲劳强度"></a>齿面接触疲劳强度</h3><script type="math/tex; mode=display">\sigma_H=Z_E Z_H Z_K\sqrt{\frac{KF_t}{bd_{v1}}·\frac{u_{v}\pm1}{u_{v}}}\leq[\sigma]_ H</script><p>其中 Zk 为锥齿轮增加的一个系数</p><h2 id="齿轮传动的润滑"><a href="#齿轮传动的润滑" class="headerlink" title="齿轮传动的润滑"></a>齿轮传动的润滑</h2><p>润滑可以起到减小啮合处的 <strong>摩擦发热、减少磨损、降低噪音</strong> 的作用</p><div class="table-container"><table><thead><tr><th>传动方式</th><th>速度</th><th>润滑方式</th></tr></thead><tbody><tr><td>开式及半开式齿轮</td><td>低</td><td>人工定期润滑或润脂</td></tr><tr><td>闭式齿轮</td><td>&lt;10m/s</td><td>浸油润滑</td></tr><tr><td>闭式齿轮</td><td>≥10m/s</td><td>喷油润滑</td></tr></tbody></table></div><h2 id="齿轮传动主要参数"><a href="#齿轮传动主要参数" class="headerlink" title="齿轮传动主要参数"></a>齿轮传动主要参数</h2><ul><li><p>模数：主要影响 齿根弯曲强度，可以按照齿根弯曲疲劳强度计算</p></li><li><p>齿数：齿数多，传动平稳。需要为质数</p><blockquote><p>如果不互质，相互啮合的齿总是确定的，这样的话磨损位置相同，会加速磨损</p></blockquote></li></ul><h1 id="蜗杆传动"><a href="#蜗杆传动" class="headerlink" title="蜗杆传动"></a>蜗杆传动</h1><ul><li>大题预定</li><li>标准件，选择型号即可</li></ul><h2 id="蜗杆传动的特点"><a href="#蜗杆传动的特点" class="headerlink" title="蜗杆传动的特点"></a>蜗杆传动的特点</h2><p>蜗杆最重要的一个特性就是 <strong>传动效率低</strong>。因此有自锁性等优点，也会有摩擦发热的现象（因此后面有热平衡计算）</p><blockquote><p>蜗杆与蜗轮在节点处速度方向相互垂直。节点处速度 $v_s=\sqrt{v_1^2+v_2^2}$ 比较大。因此传动<strong>相对滑动大</strong>，效率低，传动磨损也比较大。</p><p>由于蜗轮蜗杆的自锁性，因此只能蜗杆带动蜗轮</p></blockquote><h2 id="蜗杆传动的失效形式、设计准则、材料"><a href="#蜗杆传动的失效形式、设计准则、材料" class="headerlink" title="蜗杆传动的失效形式、设计准则、材料"></a>蜗杆传动的失效形式、设计准则、材料</h2><ul><li><p>失效形式：（与齿轮类似）齿面胶合、齿面点蚀、<strong>齿面磨损</strong>，而且通常发生在<strong>蜗轮</strong>上</p></li><li><p>设计准则</p></li></ul><div class="table-container"><table><thead><tr><th>类别</th><th>失效形式</th><th>设计准则</th></tr></thead><tbody><tr><td>闭式</td><td>磨损</td><td>按<strong>齿面接触疲劳强度</strong>计算，<strong>齿根弯曲疲劳强度</strong> 校核</td></tr><tr><td>开式</td><td>磨损</td><td>以保证齿根弯曲疲劳强度为设计准则</td></tr></tbody></table></div><ul><li><p>常用的材料</p><p>不仅要求强度和刚度，还要求一定的耐磨性、减摩性和跑和性</p><ul><li>蜗杆常用碳素钢或合金钢</li><li>蜗轮铸铁、铸造青铜等等</li></ul></li></ul><h2 id="蜗杆的效率、润滑、热平衡计算"><a href="#蜗杆的效率、润滑、热平衡计算" class="headerlink" title="蜗杆的效率、润滑、热平衡计算"></a>蜗杆的效率、润滑、热平衡计算</h2><h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><script type="math/tex; mode=display">\eta=\eta_1\eta_2\eta_3=(0.95-0.96)\frac{\tan\gamma}{\tan(\gamma+\rho_v)}</script><ul><li><p>$\eta_1$：<strong>啮合效率</strong>（与蜗轮头数有关。当 $z_1 = 1$ 时，$\eta_1=0.7$）</p></li><li><p>$\eta_2,\eta_3$：<strong>轴承效率、搅油效率</strong></p></li><li><p>$\gamma$：导程角，与斜齿轮的螺旋角比较类似</p><script type="math/tex; mode=display">\tan\gamma=\frac{z_1}{q}</script><ul><li>$z_1$：蜗杆头数</li><li>$q$：蜗杆直径系数 $q=d_1/m$（使刀具标准化）</li></ul></li><li><p>$\rho_v$：当量摩擦角</p><script type="math/tex; mode=display">\tan\rho_v=f_v</script></li></ul><div class="table-container"><table><thead><tr><th>$z_1$</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>$\eta$</td><td>0.7</td><td>0.8</td><td>0.85</td><td>0.9</td></tr></tbody></table></div><blockquote><p>头数$z_1$ 越大，加工越困难</p><p>自锁条件：$\gamma\leq\rho_v$</p></blockquote><h3 id="相对滑动速度"><a href="#相对滑动速度" class="headerlink" title="相对滑动速度"></a>相对滑动速度</h3><script type="math/tex; mode=display">v_s=\frac{v_1}{\cos\gamma}=\frac{\pi d_1n_1}{60\times1000\cos\gamma}</script><h3 id="润滑-1"><a href="#润滑-1" class="headerlink" title="润滑"></a>润滑</h3><p>目的：防止 <strong>胶合</strong>（有时还会加添加剂）和 <strong>磨损</strong></p><p>开式：定期涂润滑脂</p><p>闭式：浸油（深度为一个齿高）或喷油润滑（对准蜗杆啮入端）</p><h3 id="热平衡计算"><a href="#热平衡计算" class="headerlink" title="热平衡计算"></a>热平衡计算</h3><p>由于蜗杆效率低，因此工作时会产生大量的热。然而温度过高会使润滑失效，导致齿面胶合。因此需要进行热平衡计算，来保证油温在一定范围    内</p><ul><li><p>单位时间的发热量为(W)</p><script type="math/tex; mode=display">Q_1=1000P_1(1-\eta)</script></li><li><p>单位时间的散热量为(W)</p><script type="math/tex; mode=display">Q_2=\alpha_sA(t-t_0)</script></li><li><p>热平衡时的油温为</p><script type="math/tex; mode=display">t=t_0+\frac{1000P_1(1-\eta)}{\alpha_sA}</script><p>一般会使 t 在80℃以下</p></li></ul><h4 id="改善散热常见的措施"><a href="#改善散热常见的措施" class="headerlink" title="改善散热常见的措施"></a>改善散热常见的措施</h4><ul><li>合理设计箱体结构，焊上散热片，增大散热面积</li><li>在蜗轮轴上装风扇</li><li>在箱体油池内设置蛇形冷却水管</li><li>采用压力喷油循环润滑（最吼的冷却效果、润滑效果）<ul><li>上置式：润滑效果不好，但油不易洒出来</li><li>下置式：润滑效果好，但油容易洒出来</li></ul></li></ul><h2 id="蜗杆的受力分析"><a href="#蜗杆的受力分析" class="headerlink" title="蜗杆的受力分析"></a>蜗杆的受力分析</h2><div class="table-container"><table><thead><tr><th>名称</th><th>计算公式</th><th>方向</th></tr></thead><tbody><tr><td>圆周力 $F_t$</td><td>$F_{t1}=-F_{a2}=2T_1/d_1$</td><td>主反</td></tr><tr><td>轴向力 $F_a$</td><td>$F_{a1}=-F_{t2}=F_{t1}/(\cos\alpha_n\cos\gamma)$</td><td>左右手定则</td></tr><tr><td>径向力 $F_r$</td><td>$F_{r1}=-F_{r2}=F_{t1}\tan\alpha$</td><td>向心</td></tr></tbody></table></div><blockquote><p>左旋蜗杆使用左手法则，手握蜗杆，四指指向蜗杆旋转方向，则大拇指的方向即为蜗轮在蜗杆与蜗轮啮合点的旋转方向</p><p>涡轮蜗杆的转动方向的判定方法： 主动蜗杆为右旋用右手四个手指顺着蜗杆的转向握住蜗杆，大拇指的指向与蜗轮的节点速度方向相反，来判定蜗轮的转向。</p></blockquote><h3 id="计算载荷"><a href="#计算载荷" class="headerlink" title="计算载荷"></a>计算载荷</h3><p>$K=K_AK_vK_\beta$</p><p>其中 $K_v,K_\beta$ 可以忽略</p><h1 id="带传动"><a href="#带传动" class="headerlink" title="带传动"></a>带传动</h1><p>适用于中高速，常常接在原动机后面避免 <strong>超载</strong></p><p>已标准化，只需要选择型号</p><h2 id="带的结构与型号"><a href="#带的结构与型号" class="headerlink" title="带的结构与型号"></a>带的结构与型号</h2><ul><li>平带</li><li>V 带（摩擦力比平带大，传动能力强些）</li></ul><h3 id="V-带结构"><a href="#V-带结构" class="headerlink" title="V 带结构"></a>V 带结构</h3><p><strong>抗拉层、顶胶层、底胶层、包布层</strong> 构成。根据抗拉层结构的不同，还分为帘布结构和线绳结构</p><p>由于带的主要成分是橡胶，因此不适合于高温、有化学腐蚀的场合</p><h3 id="普通-V-带的型号"><a href="#普通-V-带的型号" class="headerlink" title="普通 V 带的型号"></a>普通 V 带的型号</h3><p>有 Y、Z、A、B、C、D、E 七种型号，他们的横截面积逐渐增大</p><p>中性层：当带垂直于底边弯曲时，长度保持不变的那一层。其宽度为节宽</p><h2 id="V-带的受力分析"><a href="#V-带的受力分析" class="headerlink" title="V 带的受力分析"></a>V 带的受力分析</h2><p>令带轮的初始拉力为 $F_0$，紧边拉力为 $F_1$，松边拉力为 $F_2$，有效拉力为 $F$ 有：</p><script type="math/tex; mode=display">2F_0=F_1+F_2</script><script type="math/tex; mode=display">F_f=F=F_1-F_2</script><p>根据欧拉公式，当处于临界状态时，有：</p><script type="math/tex; mode=display">\frac{F_1}{F_2}=e^{f\alpha_1}</script><p>此时的有效拉力为：（可以由上面式子推出）</p><script type="math/tex; mode=display">F_{max}=2F_0\frac{1{e^{f\alpha_1}-1}}{1{e^{f\alpha_1}+1}}</script><blockquote><p>紧边为 进入主动轮的 那一边</p><p>上式中，f 应该带当量摩擦系数，对于V带，$f_v=\frac{f}{\sin{\frac{\varphi_0}{2}}}$</p><p>增大有效拉力的方法有：增加$F_0,\alpha_1,f$</p></blockquote><h2 id="V-带的应力分析"><a href="#V-带的应力分析" class="headerlink" title="V 带的应力分析"></a>V 带的应力分析</h2><h3 id="拉应力"><a href="#拉应力" class="headerlink" title="拉应力"></a>拉应力</h3><p>紧边拉应力：</p><script type="math/tex; mode=display">\sigma_1=\frac{F_1}{A}</script><p>送边拉应力：</p><script type="math/tex; mode=display">\sigma_2=\frac{F_2}{A}</script><h3 id="由离心力产生的应力"><a href="#由离心力产生的应力" class="headerlink" title="由离心力产生的应力"></a>由离心力产生的应力</h3><script type="math/tex; mode=display">\sigma_c=\frac{F_c}{A}=\frac{qv^2}{A}</script><blockquote><p>各点处都有，且相等</p><p>这里只考虑的拉应力，原因是，其他的也拉应力，若此处考虑压应力，与其他的是相互抵消的关系</p></blockquote><h3 id="带弯曲产生的应力"><a href="#带弯曲产生的应力" class="headerlink" title="带弯曲产生的应力"></a>带弯曲产生的应力</h3><script type="math/tex; mode=display">\sigma_b=\frac{2E_by_0}{d_p}</script><ul><li>$E_b$：带的当量弯曲弹性模量</li><li>$y_0$：带最外层到中性层距离</li><li>$d_p$：带轮节圆直径</li></ul><h3 id="带的应力分布"><a href="#带的应力分布" class="headerlink" title="带的应力分布"></a>带的应力分布</h3><p>注：<strong>最大应力产生在紧边进入小带轮处</strong></p><script type="math/tex; mode=display">\sigma_{max}=\sigma_1+\sigma_{b1}+\sigma_c</script><h2 id="带的弹性滑动"><a href="#带的弹性滑动" class="headerlink" title="带的弹性滑动"></a>带的弹性滑动</h2><p>由于带的弹性变形而引起的带与带轮之间的相对滑动现象（不可避免的本身属性）</p><h3 id="后果"><a href="#后果" class="headerlink" title="后果"></a>后果</h3><ul><li>使从动轮的圆周速度总是落后于主动轮的圆周速度</li><li>传动比不是常数</li><li>损失能量、降低效率、使带的温度升高，引起磨损</li></ul><h3 id="打滑"><a href="#打滑" class="headerlink" title="打滑"></a>打滑</h3><ul><li>造成带的严重磨损并使带处于不稳定状态</li><li>打滑总是发生在小带轮处</li><li>打滑可以避免超载</li></ul><h2 id="带的失效形式与设计准则"><a href="#带的失效形式与设计准则" class="headerlink" title="带的失效形式与设计准则"></a>带的失效形式与设计准则</h2><ul><li>失效形式：<strong>打滑和疲劳破坏</strong></li><li>设计准则：$\sigma_{\max}=\sigma_1+\sigma_{b1}+\sigma_{c}\leq[\sigma]$</li></ul><p>当 $\sigma_{\max}=[\sigma]$ 时，带发挥出最大的效能</p><p>此时，有</p><script type="math/tex; mode=display">[P_0]=\frac{Fv}{1000}=\sigma_1(1-\frac{1}{e^{f_v\alpha_1}})\frac{Av}{1000}\\=([\sigma]-\sigma_{b1}-\sigma_c)(1-\frac{1}{e^{f_v\alpha_1}})\frac{Av}{1000}</script><h2 id="带的张紧"><a href="#带的张紧" class="headerlink" title="带的张紧"></a>带的张紧</h2><ul><li>定期张紧装置（定期改变中心距）</li><li>自动张紧装置（靠重力使带张紧）</li><li>用带轮张紧（加一个带轮）</li></ul><h1 id="链传动"><a href="#链传动" class="headerlink" title="链传动"></a>链传动</h1><p>已标准化</p><h2 id="套筒滚子链结构"><a href="#套筒滚子链结构" class="headerlink" title="套筒滚子链结构"></a>套筒滚子链结构</h2><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823214932.png" alt=""></p><p>1：内链板        2：外链板        3：销轴        4：套筒        5：滚子</p><p>其中，1、4为过盈配合；2、3为过盈配合；4、5为间隙配合；3、4为间隙配合</p><p>销轴于销轴之间的距离称为 <strong>链节距</strong> ，是链传动的主要参数</p><p>为了使链条形成环形，正好是内链板与外链板之间相连接，因此链节数最好设置成 <strong>双数</strong></p><p>当链节数为单数时，会使用 <strong>过渡链节</strong> 来进行连接，不过强度不高，因此设计时应该尽量避免这个</p><h2 id="链传动的不均匀性"><a href="#链传动的不均匀性" class="headerlink" title="链传动的不均匀性"></a>链传动的不均匀性</h2><p>链传动，链条会在链轮上形成一个多边形，多边形的边长就是链节距的大小。</p><p>因为形成了这种多边形，因此，其瞬时速度和瞬时传动比都是变化的，这个叫做链传动的<strong>多边形效应</strong></p><p>链的平均速度</p><script type="math/tex; mode=display">v=\frac{z_1n_1p}{60\times1000}=\frac{z_2n_2p}{60\times1000}</script><p>链的瞬时传动比</p><script type="math/tex; mode=display">i=\frac{\omega_1}{\omega_2}=\frac{R_2\cos\gamma}{R_1\cos\beta}</script><p><strong>当 Z1 = Z2 时，紧边链长 = 链节距的整数倍</strong> 时，<strong>传动比 = 1</strong>，为常数</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>瞬时传动比不恒定</li><li>有冲击振动</li><li>有噪音</li><li>有上下分速度，有上下抖动</li><li>容易跳齿，容易脱链</li></ul><h1 id="轴毂连接设计"><a href="#轴毂连接设计" class="headerlink" title="轴毂连接设计"></a>轴毂连接设计</h1><p>轮毂链接最常用的其实是 <strong>键连接</strong></p><p>主要参数为：键宽、键高</p><h2 id="键的主要类型"><a href="#键的主要类型" class="headerlink" title="键的主要类型"></a>键的主要类型</h2><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823214949.png" alt=""></p><h2 id="键的选择"><a href="#键的选择" class="headerlink" title="键的选择"></a>键的选择</h2><ul><li>键宽与键高：由轴的直径按照标准确定</li><li>键长：需要符合长度系列，等于或略小于轮毂长</li></ul><h2 id="键的强度计算"><a href="#键的强度计算" class="headerlink" title="键的强度计算"></a>键的强度计算</h2><script type="math/tex; mode=display">\sigma_P=\frac{2T}{dlk}\leq[\sigma_P]</script><ul><li>l：键长（不含圆头）</li><li>k：键与轮毂<strong>接触高度</strong></li><li>d：轴径</li></ul><h2 id="花键"><a href="#花键" class="headerlink" title="花键"></a>花键</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>键槽浅，对轴的和毂的削弱小</li><li>载荷可以由多个齿承担，传递转矩能力强</li><li>对称分布，受力均匀，对中性好，旋转精度高</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>成本高</li><li>需要特殊的加工才能保证精度</li></ul><h1 id="螺纹连接"><a href="#螺纹连接" class="headerlink" title="螺纹连接"></a>螺纹连接</h1><p>特点是结构简单、拆装方便，连接可靠性强，适用范围广</p><h2 id="螺纹的主要参数"><a href="#螺纹的主要参数" class="headerlink" title="螺纹的主要参数"></a>螺纹的主要参数</h2><ul><li>大径D：螺纹的公称直径</li><li>小径D1：危险界面的计算直径</li><li>中径D2：齿厚与齿间处相等处直径，<strong>确定几何参数</strong></li><li>线速n：螺旋线的数量</li><li>螺距P：相邻两牙在中径线上的轴向距离</li><li>升角$\psi$：$\tan\psi=nP/(\pi d_2)$ 中径圆柱上螺旋展开时的角</li><li>牙形角$\alpha$</li><li>导程S：同一条螺旋线相邻两牙之间的距离</li></ul><h2 id="螺纹的分类"><a href="#螺纹的分类" class="headerlink" title="螺纹的分类"></a>螺纹的分类</h2><p>要求：<strong>足够的强度与良好性</strong></p><p>当然各个螺纹也有自己的要求，比如说：链接螺纹（自锁性）、管螺纹（密封性）、转动螺纹（效率高）、调整螺纹（精度高）等等</p><h3 id="普通螺纹"><a href="#普通螺纹" class="headerlink" title="普通螺纹"></a>普通螺纹</h3><p>又叫做三角螺纹，牙形角 $\alpha=2\beta=60°$</p><p>牙形角大，当量摩擦系数大，自锁性好</p><p>根据螺距的大小，又分为粗牙螺纹和细牙螺纹</p><p>细牙螺纹螺距小，自锁性好，常用于承受冲击，振动，变载荷的地方</p><p>缺点：牙小，磨损大，易脱扣</p><blockquote><p>主要用于 <strong>连接</strong></p></blockquote><h3 id="矩形螺纹"><a href="#矩形螺纹" class="headerlink" title="矩形螺纹"></a>矩形螺纹</h3><p>$\alpha=\beta=0$ 传动效率高，但是加工困难，常被梯形螺纹代替</p><blockquote><p>主要用于 <strong>传动</strong></p></blockquote><h3 id="梯形螺纹"><a href="#梯形螺纹" class="headerlink" title="梯形螺纹"></a>梯形螺纹</h3><p>$\alpha=2\beta=30°$ 牙根强度高，易于对中，易于制造，部分螺母可以消除间隙</p><blockquote><p>主要用于 <strong>传动</strong></p></blockquote><h3 id="锯齿形螺纹"><a href="#锯齿形螺纹" class="headerlink" title="锯齿形螺纹"></a>锯齿形螺纹</h3><p>单向，效率高，牙根强度高</p><blockquote><p>主要用于 <strong>传动</strong></p></blockquote><h2 id="螺纹连接的基本类型"><a href="#螺纹连接的基本类型" class="headerlink" title="螺纹连接的基本类型"></a>螺纹连接的基本类型</h2><div class="table-container"><table><thead><tr><th>名称</th><th>适用范围</th></tr></thead><tbody><tr><td>螺栓连接</td><td>连接件不太厚且有足够空间</td></tr><tr><td>螺钉连接</td><td>不经常拆卸的场合</td></tr><tr><td>双头螺柱</td><td>经常拆装或用螺钉无法安装</td></tr><tr><td>紧定螺钉</td><td>用于传递不大的力及扭矩，在轴上用的比较多</td></tr></tbody></table></div><h2 id="螺纹连接的预紧"><a href="#螺纹连接的预紧" class="headerlink" title="螺纹连接的预紧"></a>螺纹连接的预紧</h2><p>预紧的目的是：<strong>增强连接的刚性，紧密型和防松能力</strong></p><p>当然后面会有预紧力的计算</p><h2 id="螺纹连接的防松"><a href="#螺纹连接的防松" class="headerlink" title="螺纹连接的防松"></a>螺纹连接的防松</h2><p>在静载荷作用下，螺栓连接一般能够满足自锁条件。不过当遇到 <strong>冲击振动或变载荷</strong> 时，或当<strong>温度变化很大</strong>时，摩擦副之间的摩擦力减小，可能就达不到自锁条件了，这时就会发生自动脱松现象</p><p>螺纹放松的办法有：摩擦放松、机械放松以及破坏性永久放松</p><div class="table-container"><table><thead><tr><th>名称</th><th>类别</th><th>备注</th></tr></thead><tbody><tr><td>对顶螺母（双螺母）</td><td>摩擦力放松</td><td>两个螺母对顶产生内力，增大摩擦，结构简单，但是不可靠</td></tr><tr><td>弹簧垫片</td><td>摩擦力放松</td><td>反弹力使螺纹将保持压紧力</td></tr><tr><td>锁紧螺母</td><td>摩擦力放松</td><td>螺纹旋入处镶嵌纤维或者尼龙</td></tr><tr><td>开口销或六角开槽螺母</td><td>机械放松</td><td>-</td></tr><tr><td>止动垫圈</td><td>机械放松</td><td>-</td></tr><tr><td>串联钢丝</td><td>机械放松</td><td>串联钢丝方向与螺钉拧紧的方向相同</td></tr><tr><td>焊接、冲点、涂胶</td><td>永久放松</td><td>-</td></tr></tbody></table></div><h2 id="单个螺栓强度计算"><a href="#单个螺栓强度计算" class="headerlink" title="单个螺栓强度计算"></a>单个螺栓强度计算</h2><div class="table-container"><table><thead><tr><th>类别</th><th>失效形式</th><th>计算准则</th></tr></thead><tbody><tr><td>受拉螺栓</td><td>断裂</td><td>静力/疲劳 拉伸强度</td></tr><tr><td>受剪螺栓</td><td>压溃或剪断</td><td>挤压强度和剪切强度</td></tr></tbody></table></div><p>下面只考虑受拉螺栓</p><h3 id="只受到预紧力的紧螺纹连接"><a href="#只受到预紧力的紧螺纹连接" class="headerlink" title="只受到预紧力的紧螺纹连接"></a>只受到预紧力的紧螺纹连接</h3><p>这种连接是靠结合面处的摩擦来传递横向载荷，为了避免相对滑移，因此必须有：</p><script type="math/tex; mode=display">F^{'}\geq\frac{K_fF_R}{fm}</script><p>当然这个还受到应力的限制，因此有：</p><script type="math/tex; mode=display">\sigma_{ca}=1.3\sigma=\frac{1.3F^{'}}{\pi d_1^2/4}\leq[\sigma]</script><blockquote><p>其中，螺纹连接不仅受预紧力拉力的作用，还有横向载荷扭矩的作用，因此需要考虑这个。根据第四强度理论对大量螺栓进行统计分析可以得到：复合应力的计算只需要将拉伸应力增大30%即可</p></blockquote><p>这种螺纹在冲击、振动和交变应力作用下会非常不可靠，而且所需直径一般比较大。但是由于结构简单，装配方便，一直在使用。为避免上述缺点，可以使用各种减压键来承受横向载荷。</p><h3 id="受预紧力和轴向工作载荷的紧螺纹连接"><a href="#受预紧力和轴向工作载荷的紧螺纹连接" class="headerlink" title="受预紧力和轴向工作载荷的紧螺纹连接"></a>受预紧力和轴向工作载荷的紧螺纹连接</h3><p>分三步走：力的计算、静载荷下强度计算、变载荷下强度计算</p><h4 id="受力分析-2"><a href="#受力分析-2" class="headerlink" title="受力分析"></a>受力分析</h4><p>由于被连接件的弹性形变的恢复，最后螺栓收到的总拉力 F0≠F’+F，而是：</p><script type="math/tex; mode=display">F_0=F^{"}+F</script><p>然后经过公式的换算有：</p><script type="math/tex; mode=display">F_0=F^{"}+F=F^{'}+\frac{C_1}{C_1+C_2}F</script><p>为了防止出现间隙，应该保证：</p><script type="math/tex; mode=display">F^{"}\geq0</script><p>$C_1/(C_1+C_2)$ 为螺栓的相对刚度，<strong>为了提高螺栓的承载能力，应该使这个值尽量小</strong></p><h4 id="静载荷下强度计算"><a href="#静载荷下强度计算" class="headerlink" title="静载荷下强度计算"></a>静载荷下强度计算</h4><script type="math/tex; mode=display">\sigma_{ca}=1.3\sigma=\frac{1.3F_0}{\pi d_1^2/4}\leq[\sigma]</script><h4 id="变载荷下强度计算"><a href="#变载荷下强度计算" class="headerlink" title="变载荷下强度计算"></a>变载荷下强度计算</h4><script type="math/tex; mode=display">\sigma_{a}=\frac{0.5C_1/(C_1+C_2)F}{\pi d_1^2/4}\leq[\sigma_a]</script><h2 id="螺栓组连接的设计"><a href="#螺栓组连接的设计" class="headerlink" title="螺栓组连接的设计"></a>螺栓组连接的设计</h2><h3 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h3><ul><li>连接结合面几何形状常设计成轴对称</li><li>螺栓布置应该受力合理</li><li>应该预留一定的扳手空间</li><li>分布在同一圆上的螺栓数目，应该取4,6,8等偶数，方便划线和分度</li><li>避免螺栓受到偏载（加凸台/沉头座）</li></ul><h3 id="受力分析-3"><a href="#受力分析-3" class="headerlink" title="受力分析"></a>受力分析</h3><ul><li><p>收到轴向载荷的螺栓组连接</p><script type="math/tex; mode=display">F=F_Q/z</script><ul><li>z：螺栓数量</li></ul></li><li><p>收到横向载荷的螺栓组连接</p><script type="math/tex; mode=display">F^{'}\geq\frac{F_RK_f}{fmz}</script></li><li><p>受到扭转力矩 <em>T</em> 的螺栓组连接</p><script type="math/tex; mode=display">fF^{'}r_1+fF^{'}r_2+...+fF^{'}r_z=K_fT</script><p>化简得</p><script type="math/tex; mode=display">F^{'}=\frac{K_fT}{f(r_1+r_2+...+r_z)}</script></li><li><p>受到翻转力矩的螺栓组连接</p><p>需要验证三个式子：<strong>最大工作压力、不压溃、不出现间隙</strong></p><p>工作压力：</p><script type="math/tex; mode=display">F_\max=\frac{ML_\max}{L_1^2+L_2^2+...+L^2_z}</script><ul><li>$L_\max$ <strong>受力最大的螺栓</strong> 到翻转轴的距离</li><li>$F_\max$ 受力最大螺栓受到的工作载荷</li><li>$M$ 翻转扭矩</li></ul><p>不压溃：</p><script type="math/tex; mode=display">\sigma_{p\max}\approx \frac{zF^{'}}{A}+\frac{M}{W}\leq[\sigma_p]</script><p>不出现间隙：</p><script type="math/tex; mode=display">\sigma_{p\min}\approx\frac{zF^{'}}{A}-\frac{W}{M}\geq0</script></li></ul><h1 id="轴的设计"><a href="#轴的设计" class="headerlink" title="轴的设计"></a>轴的设计</h1><h2 id="轴的类型与型号"><a href="#轴的类型与型号" class="headerlink" title="轴的类型与型号"></a>轴的类型与型号</h2><div class="table-container"><table><thead><tr><th>类型</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>转轴</td><td>承受扭矩和弯矩的轴</td><td>转速箱里面连着斜齿轮的轴</td></tr><tr><td>心轴</td><td>只承受弯矩的轴</td><td>起重机吊钩的轴</td></tr><tr><td>传动轴</td><td>只承受扭矩的轴</td><td>转速箱那个原动机引出的轴</td></tr></tbody></table></div><p>一般轴用的材料有两大类：碳素钢、合金钢</p><p>碳素钢 45钢 用的最多。碳素钢价格低廉、对应力集中敏感性小</p><p>合金钢的力学性能和淬火性能比碳素钢要好，但对应力比较敏感，而且价格高</p><blockquote><p>合金钢与碳素钢在常温下 <strong>弹性模量</strong> 差不多，因此，用合金钢并<strong>不能有效提高材料刚性</strong></p></blockquote><h2 id="轴的设计过程"><a href="#轴的设计过程" class="headerlink" title="轴的设计过程"></a>轴的设计过程</h2><h3 id="应力特点"><a href="#应力特点" class="headerlink" title="应力特点"></a>应力特点</h3><ul><li>弯曲应力：对称循环应力</li><li>扭转剪切应力：同转矩</li></ul><h3 id="设计准则"><a href="#设计准则" class="headerlink" title="设计准则"></a>设计准则</h3><p>主要失效形式为：<strong>疲劳断裂</strong></p><p>设计时一般进行 <strong>疲劳强度计算</strong></p><p>对有刚度要求的轴（车床主轴）要进行 <strong>刚度计算</strong> ，瞬时过载很大，则需要 <strong>按照最大载荷计算静强度</strong> ，对高速轴还要进行 <strong>稳定振动分析</strong></p><h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs flow">st=&gt;start: 已知条件<br>op1=&gt;operation: 选择轴的材料<br>op2=&gt;operation: 初算轴径<br>op3=&gt;operation: 结构设计<br>op4=&gt;operation: 计算弯矩、扭矩<br>op5=&gt;condition: 校核计算<br>e=&gt;end: 完善设计<br><br>st-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;op5<br>op5(yes)-&gt;e<br>op5(no)-&gt;op3<br><br></code></pre></td></tr></table></figure><h2 id="轴径的初步估计"><a href="#轴径的初步估计" class="headerlink" title="轴径的初步估计"></a>轴径的初步估计</h2><p>按 <strong>扭转强度</strong> 估算：</p><script type="math/tex; mode=display">\tau_T=\frac{T}{W_T}=\frac{9.55\times10^6P/n}{0.2d^3}\leq[\tau_T]</script><p>化简得：</p><script type="math/tex; mode=display">d\geq\sqrt[3]{\frac{9.55\times10^6}{0.2[\tau_T]}}\sqrt[3]{\frac{P}{n}}=C\sqrt[3]{\frac{P}{n}}</script><h2 id="轴的结构设计"><a href="#轴的结构设计" class="headerlink" title="轴的结构设计"></a>轴的结构设计</h2><h3 id="制造安装要求"><a href="#制造安装要求" class="headerlink" title="制造安装要求"></a>制造安装要求</h3><p>便于拆卸、便于安装、便于制造</p><ul><li>做成阶梯轴</li><li>应有倒角（方便安装零件）</li><li>需要磨削的部分应有砂轮越程槽</li><li>键应靠近装零件的端部（安装观察方便）</li><li>键的应该位于同一轴线上（良好的工艺性）</li><li>齿轮宽度应该大于轴径的长度（使齿轮压紧）</li></ul><h3 id="固定要求"><a href="#固定要求" class="headerlink" title="固定要求"></a>固定要求</h3><ul><li><p>轴向定位</p><p>轴肩连接、套筒固定（不宜太长）、双螺母固定、轴端挡圈（端部）、弹性挡圈、紧定螺钉（传递离校）</p></li><li><p>周向固定</p><p>键</p></li></ul><h3 id="受力、应力要求"><a href="#受力、应力要求" class="headerlink" title="受力、应力要求"></a>受力、应力要求</h3><ul><li>合理布置轴上传动零件位置</li><li>合理设置轴上零件的结构（减小弯矩、改善配合）</li><li>减少应力集中</li><li>提高表面质量<blockquote><ul><li>定位轴与端盖之间的轴向距离不能太小</li><li>轴承外圈应该与壳体之间有5-8mm间隙</li><li>脂润滑必须有密封装置</li></ul><h2 id="轴的强度计算"><a href="#轴的强度计算" class="headerlink" title="轴的强度计算"></a>轴的强度计算</h2></blockquote></li></ul><h3 id="应力校核法"><a href="#应力校核法" class="headerlink" title="应力校核法"></a>应力校核法</h3><script type="math/tex; mode=display">\sigma_c=\sqrt{\frac{M^2+(\alpha T)^2}{W}}\leq[\sigma_{-1}]</script><ul><li>$\alpha$ 应力修正系数。</li></ul><div class="table-container"><table><thead><tr><th>转矩不变</th><th>脉动循环</th><th>对称循环</th></tr></thead><tbody><tr><td>0.3</td><td>0.6</td><td>1</td></tr></tbody></table></div><h3 id="安全系数法"><a href="#安全系数法" class="headerlink" title="安全系数法"></a>安全系数法</h3><h4 id="疲劳强度"><a href="#疲劳强度" class="headerlink" title="疲劳强度"></a>疲劳强度</h4><script type="math/tex; mode=display">S_c=\frac{S_\sigma S_\tau}{\sqrt{S_\sigma^2+S_\tau^2}}\geq[S]</script><script type="math/tex; mode=display">S_\sigma=\frac{\sigma_{-1}}{\frac{K_\sigma}{\beta\varepsilon_\sigma}\sigma_a+\psi_\sigma\sigma_m}</script><ul><li>$K_\sigma$ 有效应力集中系数</li><li>$\beta$  表面质量系数</li><li>$\varepsilon$  绝对尺寸</li></ul><div class="table-container"><table><thead><tr><th>工作状态</th><th>应力类型</th><th>应力幅</th><th>平均应力</th></tr></thead><tbody><tr><td><code>弯曲应力</code>一般情况</td><td>对称循环</td><td>$\sigma_a=M/W$</td><td>$\sigma_m=0$</td></tr><tr><td><code>弯曲应力</code>轴不转或载荷和轴一起转</td><td>脉动循环</td><td>$\sigma_a=M/(2W)$</td><td>$\sigma_m=M/(2W)$</td></tr><tr><td><code>扭转应力</code>一般情况</td><td>脉动循环</td><td>$\tau_a=T/(2W_T)$</td><td>$\tau_m=T/(2W_T)$</td></tr><tr><td><code>扭转应力</code> 轴频繁正反转</td><td>对称循环</td><td>$\tau_a=T/W_T$</td><td>$\tau_m=0$</td></tr></tbody></table></div><p>其中：$W_T=2W$</p><h4 id="静强度"><a href="#静强度" class="headerlink" title="静强度"></a>静强度</h4><script type="math/tex; mode=display">S=\frac{S_{0\sigma} S_{0\tau}}{\sqrt{S_{0\sigma}^2+S_{0\tau}^2}}\geq[S_0]\\S_{0\sigma}=\frac{\sigma_{S}}{\sigma_\max},S_{0\tau}=\frac{\tau_S}{\tau_\max}</script><h1 id="联轴器与离合器"><a href="#联轴器与离合器" class="headerlink" title="联轴器与离合器"></a>联轴器与离合器</h1><p>联轴器和离合器都是用来连接轴与轴的，用来传递运动和扭矩</p><div class="table-container"><table><thead><tr><th>名称</th><th>作用</th><th>特点</th></tr></thead><tbody><tr><td>联轴器</td><td>主要用于轴与轴的连接，以传递运动和扭矩</td><td>停机才能连接或分离</td></tr><tr><td>离合器</td><td>在及其工作中可以随时使两轴分离或结合</td><td>①可以随时控制启动、停车②可以控制变速和换挡③过载安全保护</td></tr></tbody></table></div><h2 id="计算扭矩"><a href="#计算扭矩" class="headerlink" title="计算扭矩"></a>计算扭矩</h2><script type="math/tex; mode=display">KT\leq[T_n]</script><ul><li><em>K</em> 为工作系数</li></ul><h1 id="滑动轴承"><a href="#滑动轴承" class="headerlink" title="滑动轴承"></a>滑动轴承</h1><p>失效形式主要是：<strong>轴瓦的胶合和磨损</strong></p><p>按滑动轴承受载荷的方向，可以将滑动轴承分为：<strong>径向轴承、止推轴承</strong></p><h2 id="滑动轴承的结构形式"><a href="#滑动轴承的结构形式" class="headerlink" title="滑动轴承的结构形式"></a>滑动轴承的结构形式</h2><h3 id="径向轴承"><a href="#径向轴承" class="headerlink" title="径向轴承"></a>径向轴承</h3><ul><li><p>整体式轴承</p><p>结构简单、磨损后间隙过大、轴径只能从端部安装、拆卸</p><p>适用于小型轴</p></li><li><p>剖分式轴承</p><p>适用范围十分广泛、可以通过增加垫片调整间隙</p><p>剖分面的位置垂直于载荷，可以防止剪切</p><p>剖分式轴瓦下轴瓦承载，上轴瓦不承载，因此有沟开在上轴瓦非承载区</p></li></ul><h3 id="推力滑动轴承"><a href="#推力滑动轴承" class="headerlink" title="推力滑动轴承"></a>推力滑动轴承</h3><p>只能承受轴向载荷</p><h2 id="轴瓦的材料与结构"><a href="#轴瓦的材料与结构" class="headerlink" title="轴瓦的材料与结构"></a>轴瓦的材料与结构</h2><h3 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h3><ul><li>良好的强度</li><li>良好的塑形、减磨性、耐磨性、耐腐蚀性</li><li>抗胶合能力强</li><li>良好的导热性</li><li>易于跑合、制造</li></ul><h3 id="常用材料-1"><a href="#常用材料-1" class="headerlink" title="常用材料"></a>常用材料</h3><p>主要有三大类：金属材料、粉末冶金材料、金属材料</p><h4 id="轴承合金"><a href="#轴承合金" class="headerlink" title="轴承合金"></a>轴承合金</h4><p>又叫做巴氏合金，是轴承最好的材料</p><ul><li>锡基轴承合金</li><li>铅基轴承合金</li></ul><p>优点：有良好抗<strong>胶合能力</strong>、的耐磨性、跑和性、塑形等</p><p>缺点：强度不高、价格昂贵</p><h4 id="青铜"><a href="#青铜" class="headerlink" title="青铜"></a>青铜</h4><p>抗胶合能力强，仅次于轴承合金，强度较高</p><h4 id="粉末冶金"><a href="#粉末冶金" class="headerlink" title="粉末冶金"></a>粉末冶金</h4><p>可以制作称为含油轴承</p><p>有成本低、耐磨性好、强度高的优点</p><h3 id="轴承结构"><a href="#轴承结构" class="headerlink" title="轴承结构"></a>轴承结构</h3><ul><li>有沟应该开在非承载区</li><li>油沟长度小于轴承长度</li></ul><h2 id="非液体润滑轴承的计算"><a href="#非液体润滑轴承的计算" class="headerlink" title="非液体润滑轴承的计算"></a>非液体润滑轴承的计算</h2><p>主要失效形式：<strong>胶合、磨损</strong></p><p>对于这两种失效形式，目前还没有完善的设计计算方法。一般从限制轴承压强 <em>p</em> 和限制轴承压强与圆周速度的乘积 <em>pv</em> 进行计算，对于压强小的轴承，还应该验算其速度</p><p>在设计是一般知道 <strong>载荷、轴径、转速</strong></p><ul><li><p>验算轴承平均压强</p><p>保证<strong>润滑油不被过大的压力挤出、避免轴瓦的过度磨损</strong></p><script type="math/tex; mode=display">p=\frac{F}{Bd}\leq[p]</script><ul><li>B：轴承的工作宽度</li><li>d：轴颈直径</li></ul></li><li><p>验算轴承的 <em>pv</em> 值</p><p><strong>限制功耗、避免温升</strong></p><script type="math/tex; mode=display">pv=\frac{F}{Bd}\frac{n\pi d}{60\times1000}\leq[pv]</script></li><li><p>限制轴承速度</p><script type="math/tex; mode=display">v=\frac{n\pi d}{60\times1000}\leq[v]</script></li></ul><h2 id="滑动轴承的润滑"><a href="#滑动轴承的润滑" class="headerlink" title="滑动轴承的润滑"></a>滑动轴承的润滑</h2><h3 id="液体摩擦轴承"><a href="#液体摩擦轴承" class="headerlink" title="液体摩擦轴承"></a>液体摩擦轴承</h3><ul><li>重载、有冲击：高粘度</li><li>高速、轻载：低粘度</li></ul><h3 id="非液体摩擦轴承"><a href="#非液体摩擦轴承" class="headerlink" title="非液体摩擦轴承"></a>非液体摩擦轴承</h3><script type="math/tex; mode=display">K=\sqrt{pv^3}</script><p>当 <strong>K≤2</strong> 时，脂润滑；当 <strong>K&gt;2</strong> ，油润滑</p><h2 id="动压滑动轴承的热平衡计算"><a href="#动压滑动轴承的热平衡计算" class="headerlink" title="动压滑动轴承的热平衡计算"></a>动压滑动轴承的热平衡计算</h2><script type="math/tex; mode=display">\Delta t=t_2-t_1=\frac{fFv}{q\rho c+\alpha_s\pi dB}\\t_m=t_1+\frac{\Delta t}{2}</script><h2 id="液体动压润滑轴承"><a href="#液体动压润滑轴承" class="headerlink" title="液体动压润滑轴承"></a>液体动压润滑轴承</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h4><ol><li>两板间流体做层流运动</li><li>两板间流体为牛顿流体，其粘度只与温度有关，忽略压力对其影响</li><li>与两板接触的流体层与板间无相对滑动</li><li>流体重力、惯性不考虑</li><li>由于间隙很小，压力沿纵向大小不变</li><li>平板无限长</li></ol><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><script type="math/tex; mode=display">\frac{\partial p}{\partial x}=6\eta v\frac{h-h_0}{h^3}</script><ul><li>$\eta$ 流体粘度</li><li>$v$ 流体速度</li><li>$h$ 任意处油膜厚度</li><li>$h_0$ 当 $p=p_\max$ 时的油膜厚度</li></ul><h4 id="液体动压形成条件"><a href="#液体动压形成条件" class="headerlink" title="液体动压形成条件"></a>液体动压形成条件</h4><ul><li>流体有<strong>足够的速度</strong></li><li>流体有<strong>足够的粘度</strong></li><li>流体必须经过<strong>收敛间隙</strong>，而且收敛间隙越大，油膜的压力越大</li></ul><h3 id="液体动压轴承工程条件"><a href="#液体动压轴承工程条件" class="headerlink" title="液体动压轴承工程条件"></a>液体动压轴承工程条件</h3><h4 id="承载能力"><a href="#承载能力" class="headerlink" title="承载能力"></a>承载能力</h4><script type="math/tex; mode=display">F=\frac{2\eta vB}{\psi^2}C_p</script><ul><li>$C_p$ 承载量系数，与长径比 <em>B/d</em> 有关</li><li>$\psi=(R-r)/r$ 相对间隙。相对间隙大，轴的承载能力小。设计时根据载荷和速度选取（$v\uparrow,F\downarrow\Rightarrow\psi\uparrow$）</li><li>$B$ 工作宽度</li></ul><h4 id="最小油膜厚度"><a href="#最小油膜厚度" class="headerlink" title="最小油膜厚度"></a>最小油膜厚度</h4><script type="math/tex; mode=display">h_\min=(R-r)-e>Rz_1+Rz_2</script><p>为了保证获得完全的液体摩擦，必须保证：轴承的最小油膜厚度大于轴颈和轴的表面粗糙度之和</p><h4 id="油膜温度"><a href="#油膜温度" class="headerlink" title="油膜温度"></a>油膜温度</h4><p>根据上面热平衡计算式求</p><h1 id="滚动轴承"><a href="#滚动轴承" class="headerlink" title="滚动轴承"></a>滚动轴承</h1><p>主要失效形式为疲劳点蚀</p><p>重点在于滚动轴承的规格、类型、失效形式</p><h2 id="滚动轴承的构造和特点"><a href="#滚动轴承的构造和特点" class="headerlink" title="滚动轴承的构造和特点"></a>滚动轴承的构造和特点</h2><p>由外圈、内圈、滚动体、保持架组成</p><blockquote><p>保持架将滚动体均匀的分布在内外圈之间，一般都需要</p></blockquote><p>特点：</p><ul><li>摩擦系数小、传动效率高</li><li>起动力矩小，启动灵活</li><li>润滑简单，耗油量小</li><li>标准件，易于更换</li><li>抗冲击能力差，很难做成剖分式</li><li>径向尺寸比滑动轴承大</li></ul><h2 id="滚动轴承的类型"><a href="#滚动轴承的类型" class="headerlink" title="滚动轴承的类型"></a>滚动轴承的类型</h2><p>轴承公称接触角 $\alpha$ ：滚动体与套圈接触处的法线 与 轴承径向平面 之间的夹角</p><div class="table-container"><table><thead><tr><th>类型</th><th>公称接触角</th><th>举例</th></tr></thead><tbody><tr><td>径向接触轴承</td><td>$\alpha=0$</td><td>深沟球轴承、圆柱滚子轴承</td></tr><tr><td>向心角接触轴承</td><td>$0&lt;\alpha\leq\pi/4$</td><td>角接触球轴承</td></tr><tr><td>推力角接触轴承</td><td>$\pi/4&lt;\alpha&lt;\pi/2$</td><td>推力角接触球轴承</td></tr><tr><td>轴向接触轴承</td><td>$\alpha=\pi/2$</td><td>推力球轴承</td></tr></tbody></table></div><p>常用滚动轴承的特性如图：</p><div class="table-container"><table><thead><tr><th>轴承名称及类型代号</th><th>转速</th><th>主要特性及应用</th></tr></thead><tbody><tr><td>调心球轴承 1</td><td>中</td><td>主要从承受径向载荷，可同时承受双向轴向载荷；外圈滚道为球面，具有自动调心功能；适用于多支点轴、弯曲刚度小的轴</td></tr><tr><td>调心滚子轴承 2</td><td>低</td><td>径向承载能力比调心球轴承大，其余特点与上面相似</td></tr><tr><td>推力调心滚子轴承 2</td><td>低</td><td>可以承受很大的径向载荷和一定的轴向载荷，能够自动调心</td></tr><tr><td><strong>圆锥滚子轴承 3</strong></td><td>中</td><td>只能承受单方向轴向力、内外圈可以分离，轴承游隙可以在安装时调整</td></tr><tr><td>推力球轴承 5</td><td>低</td><td>套圈和滚动体可分离</td></tr><tr><td><strong>深沟球轴承 6</strong></td><td>高</td><td>主要承受径向力、可以承受极少量轴向力，极限转速高，价格便宜</td></tr><tr><td><strong>角接触球轴承 7</strong></td><td>较高</td><td>可取$\alpha=15,25,40$，公称接触角越大，轴向承载能力越大</td></tr><tr><td>圆柱滚子轴承 N</td><td>较高</td><td>只能承受径向载荷</td></tr></tbody></table></div><p>选择：</p><ul><li>载荷大，有冲击 =&gt; 滚子轴承</li><li>转速高 =&gt; 球轴承</li><li>便宜 =&gt; 球轴承</li></ul><h2 id="滚动轴承的代号"><a href="#滚动轴承的代号" class="headerlink" title="滚动轴承的代号"></a>滚动轴承的代号</h2><p>滚动轴承由 <code>前置代号</code>、<code>基本代号</code>、<code>后置代号</code> 组成</p><h3 id="基本代号"><a href="#基本代号" class="headerlink" title="基本代号"></a>基本代号</h3><p>由 <code>类型代号</code>、<code>尺寸系列代号</code>、<code>内径代号</code> 组成</p><ul><li><p><code>类型代号</code> 见上表格</p></li><li><p><code>尺寸系列代号</code></p><p>由 轴承的宽(高)系列代号（本质上是承载能力的不同） 和 直径代号组合而成。</p></li></ul><div class="table-container"><table><thead><tr><th>说明</th><th>窄 0</th><th>正常 1</th><th>宽 2</th></tr></thead><tbody><tr><td><strong>轻 2</strong></td><td>02</td><td>12</td><td>22</td></tr><tr><td><strong>中 3</strong></td><td>03</td><td>13</td><td>23</td></tr><tr><td><strong>重 4</strong></td><td>04</td><td>14</td><td>24</td></tr></tbody></table></div><ul><li><p><code>内径代号</code></p><p>一般是用 <strong>直径/5</strong> 来表示，下面是一些特殊情况</p></li></ul><div class="table-container"><table><thead><tr><th>00</th><th>01</th><th>02</th><th>03</th><th>用”/“隔开</th></tr></thead><tbody><tr><td>10mm</td><td>12mm</td><td>15mm</td><td>17mm</td><td>本身</td></tr></tbody></table></div><h3 id="后置代号"><a href="#后置代号" class="headerlink" title="后置代号"></a>后置代号</h3><ul><li><code>内部结构代号</code></li></ul><div class="table-container"><table><thead><tr><th>C</th><th>AC</th><th>B</th><th>E</th></tr></thead><tbody><tr><td>角接触球轴承 $\alpha=15$</td><td>角接触球轴承 $\alpha=25$</td><td>角接触球轴承 $\alpha=40$ ；圆锥滚子轴承接触角加大</td><td>加强型</td></tr></tbody></table></div><ul><li><p><code>公差等级代号</code></p><p>含有 <strong>P</strong> 的，常见的有 <strong>/P6、/P5、/P4、/P2</strong></p></li><li><p><code>轴承装配代号</code></p><p>常见的有 <strong>/DB、/DF、/DT</strong></p></li></ul><div class="table-container"><table><thead><tr><th>/DB</th><th>/DF</th><th>/DT</th></tr></thead><tbody><tr><td>背对背（小口对小口）</td><td>面对面（大口对大口）</td><td>串联安装</td></tr></tbody></table></div><blockquote><p>例如：<strong>7210 C/P5/DF</strong> 表示这是一个角接触球轴承，基本尺寸代号为（02）属于窄轻系列，内径为50mm，该轴承公称接触角 $\alpha=15$ ，公差等级5级，属于面对面安装</p></blockquote><h2 id="失效形式"><a href="#失效形式" class="headerlink" title="失效形式"></a>失效形式</h2><p>受到交变载荷（由于轴承的弹性变形引起的）</p><ul><li><strong>疲劳点蚀</strong>，最主要的失效形式</li><li>塑形变形</li><li>磨损</li><li>胶合</li></ul><h2 id="计算准则"><a href="#计算准则" class="headerlink" title="计算准则"></a>计算准则</h2><p>计算准则主要是进行寿命计算，对低速轴承还可以进行 静强度计算，对高速轴承还可以验算 极限转速</p><h3 id="寿命计算"><a href="#寿命计算" class="headerlink" title="寿命计算"></a>寿命计算</h3><blockquote><p>寿命计算的本质还是强度计算</p></blockquote><ul><li><p>基本额定寿命</p><p>一批相同轴承，在相同条件下运转，90%轴承在疲劳点蚀前转过的转速</p></li><li><p>基本额定动载荷</p><p>轴承温度在100℃以下，基本额定寿命为10^6转时，轴承所能承受的最大载荷</p><blockquote><p>方向：向心轴承 =&gt; 径向力；推力轴承 =&gt; 轴向力；角接触 =&gt; 径向分力</p></blockquote></li></ul><p>由实验可以推导出：</p><p>$P^\varepsilon L=$ 常数</p><ul><li>$P$：当量动载荷</li><li>$\varepsilon$ ：寿命系数，球轴承 $\varepsilon=3$，滚子轴承 $\varepsilon=10/3$</li><li>$L$：寿命（以次数为单位）</li></ul><p>引入基本额定动载荷，可以得到</p><script type="math/tex; mode=display">P^\varepsilon L=C^\varepsilon\times10^6</script><p>化简得寿命</p><script type="math/tex; mode=display">L=(\frac{C}{P})^\varepsilon\times10^6</script><p>将次数转化为时间，并引入温度系数，对 C 值进行修正，得</p><script type="math/tex; mode=display">L_h=(\frac{Cf_t}{P})^\varepsilon\times\frac{10^6}{60n}</script><ul><li>$L_h(h)$ 轴承寿命</li><li>$C$ 基本额定动载荷</li><li>$f_t$ 温度系数（温度越高，温度系数越低）</li><li>$\varepsilon$ 寿命系数，球轴承 $\varepsilon=3$ ，滚子轴承 $\varepsilon=10/3$</li><li>$n(r/\min)$ 转速</li><li>$P(N)$ 当量动载荷</li></ul><p>下面讨论 $P$ 的计算</p><script type="math/tex; mode=display">P=f_p(XF_R+YF_A)</script><ul><li>$X,Y$ 径向动载荷系数，轴向动载荷系数</li><li>$f_P$ 冲击载荷系数</li></ul><h3 id="角接触轴承轴向力的判断"><a href="#角接触轴承轴向力的判断" class="headerlink" title="角接触轴承轴向力的判断"></a>角接触轴承轴向力的判断</h3><p>由<code>内部派生轴向力</code>与<code>外部轴向力</code>综合影响的叠加</p><p>内部轴向力：</p><ul><li><p>方向</p><p>使内外圈脱离的方向，即由小口指向大口</p></li><li><p>大小</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">轴承类型</th><th style="text-align:center">角接触球轴承C</th><th style="text-align:center">角接触球轴承AC</th><th style="text-align:center">角接触球轴承B</th><th style="text-align:center">圆锥滚子轴承</th></tr></thead><tbody><tr><td style="text-align:center"><strong>$F_S$</strong></td><td style="text-align:center">$0.5F_r$</td><td style="text-align:center">$0.7F_r$</td><td style="text-align:center">$1.1F_r$</td><td style="text-align:center">$F_r/(2Y)$</td></tr></tbody></table></div><p>轴向力判断方法</p><ol><li>判明轴上全部轴向力（包括外载荷 $F_A$ 和内部轴向力 $F_S$），合力指向，确定 <code>压紧端</code> 和 <code>放松端</code></li><li><code>压紧端</code> <strong>轴向力 = ∑所有轴向力</strong>（<strong>除自身内部轴向力外</strong>）</li><li><code>放松端</code> <strong>轴向力 = 自身轴向力</strong></li></ol><blockquote><p>注意圆锥滚子轴承和角接触球轴承都只能承受单向载荷</p></blockquote><h3 id="静载荷计算"><a href="#静载荷计算" class="headerlink" title="静载荷计算"></a>静载荷计算</h3><blockquote><p>非重点</p></blockquote><script type="math/tex; mode=display">C_0\geq P_0S_0</script><ul><li>$S_0$ ：静载荷安全系数</li></ul><p>对于向心轴承，有</p><script type="math/tex; mode=display">P_{0r}=X_0F_R+Y_0F_A\\P_{0r}=F_R</script><p>取最大值</p><p>对于推力轴承</p><script type="math/tex; mode=display">P_{0a}=F_A</script><p>对于推力角接触球轴承</p><script type="math/tex; mode=display">P_{0a}=2.3F_R\tan\alpha+F_A</script><h3 id="极限转速"><a href="#极限转速" class="headerlink" title="极限转速"></a>极限转速</h3><blockquote><p>非重点</p></blockquote><script type="math/tex; mode=display">n_\max\leq f_1f_2n_\lim</script><ul><li>$f_1$ 载荷系数</li><li>$f_2$ 载荷分布系数</li><li>$n_\lim$ 在一定载荷和润滑条件下所允许的最大转速</li></ul><h2 id="滚动轴承的轴向固定"><a href="#滚动轴承的轴向固定" class="headerlink" title="滚动轴承的轴向固定"></a>滚动轴承的轴向固定</h2><p>目的</p><ul><li>控制轴相对于基座的轴向移动，抵抗轴向力</li><li>保证发热变形时有伸缩的可能</li></ul><h3 id="两端固定支撑"><a href="#两端固定支撑" class="headerlink" title="两端固定支撑"></a>两端固定支撑</h3><p>适用于<strong>普通工作温度</strong>下跨距小于 $l\leq300—500$ 的 <strong>短轴</strong></p><p>此时，轴承盖与轴承之间，故意留了一个很小的间隙 $c=0.2-0.4mm$</p><p>轴的轴向力通过轴肩传递给轴承，轴承传递给端盖，最后端盖通过连接螺钉传递给机座</p><h3 id="一端固定一端游动"><a href="#一端固定一端游动" class="headerlink" title="一端固定一端游动"></a>一端固定一端游动</h3><p>适用于 <strong>轴较长或工作温度较高</strong> 的轴</p><p>固定端内圈固定在轴上，外圈固定在基座上，形成固定</p><p>移动端若为深沟球轴承，外圈与端盖间留有一定间隙，以此游动</p><p>移动端若为圆柱滚子轴承，可以进行双向固定，考滚子与套筒间的相对运动来游动</p><h3 id="两端游动支撑"><a href="#两端游动支撑" class="headerlink" title="两端游动支撑"></a>两端游动支撑</h3><p>利用人字齿轮确定位置。在使用人字齿轮时，大齿轮被定死，小齿轮由于人字齿轮存在误差，必须要左右移动，此时就需要两端游动</p><blockquote><p>人字齿轮，小齿轮两端游动，大齿轮两端固定</p></blockquote><h3 id="滚动轴承部件的调整与拆装"><a href="#滚动轴承部件的调整与拆装" class="headerlink" title="滚动轴承部件的调整与拆装"></a>滚动轴承部件的调整与拆装</h3><ul><li>轴承游隙的调整<ul><li>加减垫片</li><li>调整螺钉</li></ul></li><li>传动件位置的调整（还是垫片）</li></ul><blockquote><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823215017.png" alt=""></p><p>其中 垫片1 是为了调整锥齿轮位置；垫片2 是为了调整轴承游隙。画图时要注意</p></blockquote><ul><li><p>轴承预紧</p><p>预先施加外力，消除游隙，<strong>提高刚度、旋转精度</strong>。</p></li><li><p>轴承的配合</p><ul><li>标注：轴与内圈配合：只标轴；外圈与孔配合：只标孔</li><li>紧配合用于转速高、承载大、温度高的情况；松配合用于经常拆卸外圈静止的情况</li></ul></li><li><p>轴承的装拆</p><ul><li>加热</li><li>利用拆装工具</li></ul></li><li><p>滚动轴承的润滑</p><ul><li><p>$dn&lt;(1.5-2)\times10^5$ 脂润滑</p></li><li><p>$dn&gt;(1.5-2)\times10^5$ 油润滑</p></li></ul></li></ul><h2 id="课本例题"><a href="#课本例题" class="headerlink" title="课本例题"></a>课本例题</h2><p>如图为斜齿轮、轴、轴承、联轴器组合图。斜齿轮用油润滑，轴承用脂润滑，试改正错误。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823215033.png" alt=""></p><div class="table-container"><table><thead><tr><th>序号</th><th>错误详情</th></tr></thead><tbody><tr><td>1</td><td>端盖与机架之间应该有调整垫片，同时要有螺栓进行定位</td></tr><tr><td>2</td><td>轴肩高度超过轴承内圈，无法拆卸</td></tr><tr><td>3</td><td>轴肩高度过低，无法装配；应使用套筒进行轴向定位，此时轴肩宽度应该略小于齿轮宽度</td></tr><tr><td>4</td><td>键槽不在同一母线上，不方便加工</td></tr><tr><td>5</td><td>此处需要挡油板</td></tr><tr><td>6</td><td>轴承装配距离过长，应该设计成阶梯轴</td></tr><tr><td>7</td><td>此处应该考虑密封，同时，转动体与非转动体之间要有间隙</td></tr><tr><td>8</td><td>键槽过宽</td></tr><tr><td>9</td><td>轮毂宽度应该大于对应轴的宽度</td></tr><tr><td>10</td><td>转动体非转动体之间不能互相定位</td></tr></tbody></table></div><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823215048.png" alt=""></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823215101.png" alt=""></p><hr><p>Learning By Sharing，2018©Fu_Qingchen，Markdown，LaTeX</p>]]></content>
    
    
    <categories>
      
      <category>机械相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机械设计</tag>
      
      <tag>机械</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android入门之旅</title>
    <link href="/2018/03/31/WHUT/AndroidOpenDoor/"/>
    <url>/2018/03/31/WHUT/AndroidOpenDoor/</url>
    
    <content type="html"><![CDATA[<p>注：这是一个学习笔记。很可惜今年的 <strong>Google Study Jams</strong> 活动取消了，于是就只能自己来了，幸好 Google 官方有很多面向新手的教程，那么，开干！本文基于<a href="https://developers.google.cn/training/android/">https://developers.google.cn/training/android/</a> 给出的教程(而且是中文教程，感觉很良心)</p><p>2018©Fu_Qingchen，Typora</p><p>本文的运行环境是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Android Studio <span class="hljs-number">3.1</span><br>Build #AI-<span class="hljs-number">173.4670197</span>, built on March <span class="hljs-number">22</span>, <span class="hljs-number">2018</span><br>JRE: <span class="hljs-number">1.8</span><span class="hljs-number">.0_152</span>-release-<span class="hljs-number">1024</span>-b02 amd64<br>JVM: OpenJDK <span class="hljs-number">64</span>-Bit Server VM by JetBrains s.r.o<br>Windows <span class="hljs-number">10</span> <span class="hljs-number">10.0</span><br></code></pre></td></tr></table></figure></p><h1 id="总体规划"><a href="#总体规划" class="headerlink" title="总体规划"></a>总体规划</h1><p>参照 <strong>Google Study Jams</strong> 的活动进行</p><p>第一阶段</p><ul><li>L1 (3:38:59)：1A  (1:04:07) 、1B  (1:13:59)、1C  (1:20:53)</li><li>L2 (5:07:02)：2A  (2:00:40)、2B  (1:03:40)、2C  (2:02:42)</li><li>L3 (4:25:20)：3A  (2:15:36)、3B  (2:09:44)</li><li>拓展 (2:06:44)：Firebase 介绍(0:34:25) + Firebase 周末(1:32:19)</li></ul><p>第二阶段</p><ul><li>实践教程：制作结业 App、上载结业 App 到 Google Play</li></ul><p>总时长 15:18:05，建议 40 - 45 小时的<strong>空闲时间</strong>学习 ，比如工作日每天一个小时，周末每天两个小时。</p><h1 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h1><p>1C为AndroidStudio的运用，暂不介绍</p><h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><p>简单来说一个展示内容的长方形，有很多，像什么TestView，ImageView，Button等等</p><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p>描述Android外观的语言</p><p><strong>注：下面的代码块中，注释的写法是错误的，但是为了方便，还是这么写了</strong></p><p>例如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> //类型</span><br><span class="hljs-tag">          <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Happy Birthday!&quot;</span></span><br><span class="hljs-tag">          //属性名=<span class="hljs-string">&quot;值&quot;</span> 的形式</span><br><span class="hljs-tag">          <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@android:color/darker_gray&quot;</span>//属性值放在引号内部</span><br><span class="hljs-tag">          <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;150dp&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;75dp&quot;</span>&lt;/<span class="hljs-attr">TextView</span>&gt;</span><br>//当然也可以如果需要嵌套，必须使用<br>//<span class="hljs-tag">&lt;/<span class="hljs-name">TextView</span>&gt;</span>来结束<br></code></pre></td></tr></table></figure><h3 id="TextView"><a href="#TextView" class="headerlink" title="TextView"></a>TextView</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">      <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Happy Birthday!&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@android:color/darker_gray&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#2196F3&quot;</span>//替换自己的颜色</span><br><span class="hljs-tag">      <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;150dp&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">dp</span>代表密度无关像素，其中可以接触的东东需要至少<span class="hljs-attr">48dp</span></span><br><span class="hljs-tag">          //用<span class="hljs-attr">dp</span>的原因是不同的设备点像素点的大小是不同的，<span class="hljs-attr">dp</span>可以使不同的设备显示相同的尺寸</span><br><span class="hljs-tag">      //<span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;75dp&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;warp_content&quot;</span></span><br><span class="hljs-tag">          //让<span class="hljs-attr">TextView</span>的高度正好等于文字的高度</span><br><span class="hljs-tag">      //<span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;45sp&quot;</span>//大小可以按照<span class="hljs-attr">MD</span>的说明来弄，其中<span class="hljs-attr">sp</span>是比例无关像素</span><br><span class="hljs-tag">      <span class="hljs-attr">android:textAppearance</span>=<span class="hljs-string">&quot;?android:textAppearanceLarge&quot;</span></span><br><span class="hljs-tag">          //用系统的文字大小进行匹配/&gt;</span><br></code></pre></td></tr></table></figure><p>相关链接：<a href="https://developer.android.google.cn/reference/android/widget/TextView.html">TextView官方文档</a></p><h3 id="ImageView"><a href="#ImageView" class="headerlink" title="ImageView"></a>ImageView</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">      <span class="hljs-attr">android:src</span>=<span class="hljs-string">&quot;@drawable/cake&quot;</span></span><br><span class="hljs-tag">           //使用@符号表示在<span class="hljs-attr">Android</span> <span class="hljs-attr">APP</span>里面引用一个资源</span><br><span class="hljs-tag">           //<span class="hljs-attr">drawable</span>是一种资源类型,能将图形显示在屏幕上</span><br><span class="hljs-tag">           //<span class="hljs-attr">cake</span>是图片名,不需要添加文件的扩展名</span><br><span class="hljs-tag">      <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">android:scaleType</span>=<span class="hljs-string">&quot;center&quot;</span></span><br><span class="hljs-tag">           //不改变图片大小，然后居中显示</span><br><span class="hljs-tag">           //<span class="hljs-attr">android:scaleType</span>=<span class="hljs-string">&quot;centerCrop&quot;</span>//放大缩小以满足 <span class="hljs-attr">View</span> 的宽高要求/&gt;</span><br></code></pre></td></tr></table></figure><p>相关链接：<a href="https://developer.android.google.cn/reference/android/widget/ImageView.html">ImageView官方文档</a></p><h2 id="ViewGroup"><a href="#ViewGroup" class="headerlink" title="ViewGroup"></a>ViewGroup</h2><p>ViewGroup是一个组，相当于是一个容器，他能管理底下的TextView，ImageView，Button等等</p><h2 id="LinearLayout"><a href="#LinearLayout" class="headerlink" title="LinearLayout"></a>LinearLayout</h2><p>线性布局，分为水平和竖直两种。一般竖直的比较常用</p><p>在下面的例子中会介绍线性布局的一些基础内容，还有布局权重</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span></span><br><span class="hljs-tag">              //线性布局的方向为&quot;竖直&quot;</span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">              //这是一种新的标尺寸的东东，与之前的&quot;<span class="hljs-attr">wrap_content</span>&quot;类似。</span><br><span class="hljs-tag">              //&quot;<span class="hljs-attr">match_parent</span>&quot;的含义是：这个尺寸与父级的尺寸相同</span><br><span class="hljs-tag">              //此处<span class="hljs-attr">LinearLayout</span>宽就与设备宽度相同，下同</span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>&gt;</span><br>    &lt;注意这里有一个&quot;&gt;&quot;/&gt;<br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:src</span>=<span class="hljs-string">&quot;@drawable/ocean&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;5&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:scaleType</span>=<span class="hljs-string">&quot;centerCrop&quot;</span> /&gt;</span><br>&lt;<br>    这里出现了layout_weight=&quot;1&quot;此处的weight就是权重。<br>    在这个例子中，ImageView占比5/6，TextView占比1/6<br>    当有权重weight出现时通常把对应的值设置为0（竖直:height）<br>    /&gt;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;You&#x27;re invited!&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;@android:color/white&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;54sp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#009688&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="RelativeLayout"><a href="#RelativeLayout" class="headerlink" title="RelativeLayout"></a>RelativeLayout</h2><p>相对布局</p><p>顾名思义嘛，同样的，在例子中解释</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">RelativeLayout</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span> &gt;</span><br>&lt;<br>   相对布局就不需要android:orientation这个方向属性了<br>    /&gt;<br>   <br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/ocean_image_view&quot;</span></span><br><span class="hljs-tag">               //相对的嘛，就需要参照物了，参照物需要一个名字，就是<span class="hljs-attr">id</span></span><br><span class="hljs-tag">               //由于这里是添加属性，因此是&quot;@+<span class="hljs-attr">id</span>&quot;</span><br><span class="hljs-tag">               //一般习惯性的给每个<span class="hljs-attr">View</span>都给一个<span class="hljs-attr">id</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;56dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;56dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:scaleType</span>=<span class="hljs-string">&quot;centerCrop&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:src</span>=<span class="hljs-string">&quot;@drawable/ocean&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/Pebble_Beach_text_view&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Pebble Beach&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_toRightOf</span>=<span class="hljs-string">&quot;@id/ocean_image_view&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textAppearance</span>=<span class="hljs-string">&quot;?android:textAppearanceMedium&quot;</span> /&gt;</span><br>&lt;<br>    其中layout_toRightOf属性就是表示相对位置的，含义是在参照物的右边<br>    同理，还有layout_below，layout_above，toLeftOf，见下方<br>    /&gt;<br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/California_text_view&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;California&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_toRightOf</span>=<span class="hljs-string">&quot;@id/ocean_image_view&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_below</span>=<span class="hljs-string">&quot;@id/Pebble_Beach_text_view&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textAppearance</span>=<span class="hljs-string">&quot;?android:textAppearanceSmall&quot;</span> /&gt;</span><br><br>&lt;<br>    除了把其他View当作参照物，还可以直接把父视图当作参照物，用以下的语句表示：<br>    android:layout_alignParentTop=&quot;true&quot;<br>    android:layout_alignParentBottom=&quot;true&quot;<br>    android:layout_alignParentLeft=&quot;true&quot;<br>    android:layout_centerHorizontal=&quot;true&quot;//水平居中<br>    android:layout_centerVertical=&quot;true&quot;//竖直居中<br>    /&gt;<br><span class="hljs-tag">&lt;/<span class="hljs-name">RelativeLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>注意：为了避免过于复杂，能够使用线性视图就使用线性视图</strong></p><h2 id="内边距与外边距"><a href="#内边距与外边距" class="headerlink" title="内边距与外边距"></a>内边距与外边距</h2><p>内边距（padding）呢就是View本身往外边扩展一层，如果View有背景颜色的话，背景颜色也会扩充</p><p>外边距（margin）就是把View隔开一下，隔开的地方是没有颜色的。外边距讲究一种隔开的情况，因此需要建立在ViewGroup里面</p><p>下面的图形就是内边距和外边距的例子（PS：Google的教程截图）</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200821222439.png" alt="内边距和外边距"></p><p>其中蓝色部分代表TextView，红色部分代表ViewGroup，左边是内边距，右边是外边距</p><p>其实感觉外边距的运用广泛一些，可能跟最近卡片风格流行有关吧</p><p>控制内边距（padding）的语句有</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">android:padding=&quot;8dp&quot;//对于全局<br>android:paddingLeft=&quot;8dp&quot;<br>android:paddingRight=&quot;8dp&quot;<br>android:paddingTop=&quot;8dp&quot;<br>android:paddingBottom=&quot;8dp&quot;<br></code></pre></td></tr></table></figure><p>控制外边距的语句有</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">android:layout_margin=&quot;8dp&quot;//对于全局<br>android:layout_marginLeft=&quot;8dp&quot;<br>android:layout_marginRight=&quot;8dp&quot;<br>android:layout_marginTop=&quot;8dp&quot;<br>android:layout_marginBottom=&quot;8dp&quot;<br></code></pre></td></tr></table></figure><p>当然，这个是可以对各个View分别设置的，也可以对ViewGroup设置</p><h2 id="ConstraintLayout"><a href="#ConstraintLayout" class="headerlink" title="ConstraintLayout"></a>ConstraintLayout</h2><p> 约束布局，能够非常快速地制作自适应 UI的一种布局。</p><h2 id="※-构建布局的步骤"><a href="#※-构建布局的步骤" class="headerlink" title="※ 构建布局的步骤"></a>※ 构建布局的步骤</h2><ol><li><p>选择视图类型</p><p><code>3 Button, 4 TextView</code></p></li><li><p>确定视图的位置</p><p><code>标题下面是一行按钮和一个TextView，然后是另一个标题和TextView，最后面是一个Button</code></p></li><li><p>设置视图的样式</p><p><code>内边距外边距什么的</code></p></li></ol><h1 id="用户交互"><a href="#用户交互" class="headerlink" title="用户交互"></a>用户交互</h1><h2 id="什么是Activity？"><a href="#什么是Activity？" class="headerlink" title="什么是Activity？"></a>什么是Activity？</h2><p>Activity是应用中用户可以操作的东西，有时候Activity就是应用中的一个屏幕。</p><p>比如在Google日历中，你点开时看到的就是一个Activity，让你查看日程的，而且这个Activity有一个侧边栏。Google日历的设置是另外一个Activity，让你设置一些东西的。</p><h2 id="XML与Java在Android中有什么作用？"><a href="#XML与Java在Android中有什么作用？" class="headerlink" title="XML与Java在Android中有什么作用？"></a>XML与Java在Android中有什么作用？</h2><p>XML其实就是一个控制布局的，你可以在里边编辑你的UI</p><p>Java呢，就是控制程序的，实现各种各样的功能</p><h2 id="XML如何调用Java？"><a href="#XML如何调用Java？" class="headerlink" title="XML如何调用Java？"></a>XML如何调用Java？</h2><p>在XML中，我们可以看到这样的语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:onClick</span>=<span class="hljs-string">&quot;submitOrders&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;order&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>其中<code>android:onClick=&quot;submitOrders&quot;</code> 就是用来调用Java中的<code>submitOrders</code> 方法的</p><p>如果<code>submitOrders</code> 方法是这样的，那么当用户点击<code>ORDER</code> 按钮时，就会执行相对应的display方法和displayPrice方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">submitOrders</span><span class="hljs-params">(View view)</span> </span>&#123;<br>    <span class="hljs-comment">//将submitOrders变为submitOrder会在应用运行时报错</span><br>    <span class="hljs-keyword">int</span> numberOfCoffee = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> price = <span class="hljs-number">3</span>;<br>    display(numberOfCoffee);<br>    displayPrice(numberOfCoffee * price);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>debug是消除bug的调试过程</p><h2 id="系统日志"><a href="#系统日志" class="headerlink" title="系统日志"></a>系统日志</h2><p>System Log: Android开发中常用logcat这个工具来分层次、分类型地显示不同等级的日志，方便程序员查找感兴趣的信息(错误信息或者更琐碎、更底层的信息)。</p><h3 id="断点功能"><a href="#断点功能" class="headerlink" title="断点功能"></a>断点功能</h3><p>为了快速找到错误指令，我们可以在希望设备暂停的指令位置插入一个断点，类似停车标志或路障。然后我们可以让调试器从第一条指令开始全速运行应用，运行至断点时，设备一定会暂停供我们进行检查。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>进行Debugging必须首先进入debug模式，Android的debug是用一只小瓢虫代替。</p><p>进入Debug模式之后，程序会和运行时一样重新编译这个App，此时手机会弹出提示，过一会等弄好了，提示也就自己消失了。</p><p>当在手机上操作时，在Android Studio的程序框里面就会显示信息，程序运行到断点就会停止，你可以看到一些数据的值</p><p><a href="https://blog.csdn.net/Yaoobs/article/details/51296198">https://blog.csdn.net/Yaoobs/article/details/51296198</a> 这里非常详细的介绍了Debug模式的使用方法</p><h2 id="Nested-ViewGroups"><a href="#Nested-ViewGroups" class="headerlink" title="Nested ViewGroups"></a>Nested ViewGroups</h2><p>嵌套视图组，简单的说就是可以在一个布局里面嵌套多个布局。比如说在竖直的线性布局里面嵌套水平布局。</p><p>比如说下面这个图例：</p><ul><li>图例首先是包含两个子视图一个竖直的线性布局（vertical LinearLayout）</li><li>第一个子视图是一个包含3个子视图的水平线性布局（horizontal LinearLayout）</li><li>第二个子视图是一个包含4个子视图的相对布局（RelativeLayout）<ul><li>其中一个子视图还包含着一个子视图</li></ul></li></ul><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200821222535.png" alt="嵌套"></p><h2 id="Java字符串"><a href="#Java字符串" class="headerlink" title="Java字符串"></a>Java字符串</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String message = <span class="hljs-string">&quot;Item count&quot;</span> + quantity + <span class="hljs-number">3</span>;<br><span class="hljs-comment">//字符串还可以这么写，其中quantity是字符变量</span><br></code></pre></td></tr></table></figure><p>其他的都是Java基础了，这里就不写了</p><h2 id="控制对齐的属性"><a href="#控制对齐的属性" class="headerlink" title="控制对齐的属性"></a>控制对齐的属性</h2><p>主要有两个：<strong><a href="http://developer.android.youdaxue.com/reference/android/widget/LinearLayout.LayoutParams.html?utm_source=udacity&amp;utm_medium=course&amp;utm_campaign=android_basics#attr_android:layout_gravity">layout_gravity</a></strong> 以及 <strong><a href="http://developer.android.youdaxue.com/reference/android/widget/LinearLayout.html?utm_source=udacity&amp;utm_medium=course&amp;utm_campaign=android_basics#attr_android:gravity">gravity</a></strong></p><p>关于两者的区别：</p><ul><li>layout_gravity是对整个view的布局。view整体发生变化，但是view里面的内容改咋样还是咋样</li><li>gravity是对view内的布局。view本身不变，变的是里面的东西</li></ul><p>下图是一个很好的例子（来源：<a href="https://stackoverflow.com/questions/3482742/difference-between-gravity-and-layout-gravity-on-android/26190050#26190050?newreg=12160f705b15400fa08bba26d9d0e635">stackoverflow</a>）</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823220410.png" alt=""></p><h2 id="Java常量"><a href="#Java常量" class="headerlink" title="Java常量"></a>Java常量</h2><p>在编程语言中，<strong>常量</strong>是指在整个程序中永远不会改变的值。在 Java 中，你可以使用关键字 <code>final</code> 来强制规定某个值不得被更改。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> POINTS_FOR_FREE_THROW = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>Then if you wrote the following, you’d get an error:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">POINTS_FOR_FREE_THROW = <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><p>注意，按照惯例，常量的名称全为大写形式。此外，单词之间用下划线连接，而不用空格或用骆驼拼写法。你可以将变量声明为常量，防止自己意外地更改了变量的值。</p><h2 id="Android的构成"><a href="#Android的构成" class="headerlink" title="Android的构成"></a>Android的构成</h2><p>一个Android应用主要由资源文件和java代码构成。</p><ul><li>java代码负责处理一些事情，比如说按按钮之后还会干啥。。。</li><li>资源文件就是资源是代码使用的附加文件和静态内容，例如位图，布局定义，用户界面字符串，动画说明等。像一些什么布局文件（XML）啊，图片啊，音乐啊等等</li></ul><p>相关资源在 <a href="http://developer.android.youdaxue.com/guide/index.html">这里</a></p><h2 id="Java获取资源"><a href="#Java获取资源" class="headerlink" title="Java获取资源"></a>Java获取资源</h2><p>在运用编译时，Android中有一个叫 <code>aapt</code> 的工具，这个工具会产生 <code>R</code> 类（就是一个简单的R.java文件）这个里面S目录里包含所有资源文件的ID</p><p>有两种方式使用ID：</p><ul><li><p>在Java代码中用 <code>R.资源类型.资源名</code> 的形式调用。</p><p>比如 <code>R.string.hello</code>、<code>R.drawable.photo</code></p></li><li><p>在XML文件中，用 <code>@资源类型/资源名</code> 的形式调用</p><p>比如<code>@string/hello</code>、<code>@drawable/photo</code></p></li></ul><h2 id="XML-amp-JAVA"><a href="#XML-amp-JAVA" class="headerlink" title="XML&amp;JAVA"></a>XML&amp;JAVA</h2><p>当你点击APP的时候，它会打开<code>MainActivity</code>，此时什么都看不到，因为它在初始化。然后java中的<code>onCreate</code>方法会被自动调用，activity会被创建。</p><p>在<code>MainActivity</code>中的 <code>onCreate</code>方法中有一句<code>setContentView(R.layout.activity_main);</code>，这个对应着布局文件的资源ID。此时XML文件与Java文件就结合起来了 。Android程序就开始解析XML文件，识别XML文件中的各种布局还有View等等。</p><h2 id="findViewById方法"><a href="#findViewById方法" class="headerlink" title="findViewById方法"></a>findViewById方法</h2><p>这个方法会在XML文件中找到与传入ID相对应的View，然后在onCreate方法中处理它</p><p>例如下面这个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">View textView = findViewById(R.id.order_summary_text_view);<br></code></pre></td></tr></table></figure><p>这个语句的意思就是：我们传入一个id参数 <code>R.id.order_summary_text_view</code> 给 <code>findViewById</code> 方法。这个方法会遍历整个XML文件，直到找到id为 <code>R.id.order_summary_text_view</code> 的一个View，然后把这个View作为一个Java对象返回，然后把这个对象存放在名字为<code>textView</code> 的View类对象中。</p><p>注：如果ID为为 <code>R.id.order_summary_text_view</code> 的View是<code>TextView</code>的话，它是无法使用<code>TextView</code>类的方法的，因为<code>findViewById</code>创建的是一个<code>View</code>类型的对象，如果要用<code>TextView</code>的特殊方法，就必须要使用以下的语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">TextView textView = (TextView) findViewById(R.id.order_summary_text_view);<br></code></pre></td></tr></table></figure><h2 id="向-Android-日志中写消息"><a href="#向-Android-日志中写消息" class="headerlink" title="向 Android 日志中写消息"></a>向 Android 日志中写消息</h2><p>注：这个是抄的Udacity上面的</p><p>本质上，你是在代码中写出类似于以下内容的 Java 语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Log.i(<span class="hljs-string">&quot;eatCookie&quot;</span>,<span class="hljs-string">&quot;Oh my God, You Killed Kenny!!!&quot;</span>);<br></code></pre></td></tr></table></figure><p>第一个参数是日志语句所来自的<strong>类的名称</strong>。第二个参数是你想要显示的<strong>文字</strong>。</p><p>这里，我们使用了 Log.i()，表示“信息”级别的日志。其他级别的选项如下所示：</p><ul><li><a href="http://developer.android.youdaxue.com/reference/android/util/Log.html?utm_source=udacity&amp;utm_medium=course&amp;utm_campaign=android_basics#e(java.lang.String,%20java.lang.String">e(String, String)</a>)（错误）</li><li><a href="http://developer.android.youdaxue.com/reference/android/util/Log.html?utm_source=udacity&amp;utm_medium=course&amp;utm_campaign=android_basics#w(java.lang.String,%20java.lang.String">w(String, String)</a>)（警告）</li><li><a href="http://developer.android.youdaxue.com/reference/android/util/Log.html?utm_source=udacity&amp;utm_medium=course&amp;utm_campaign=android_basics#i(java.lang.String,%20java.lang.String">i(String, String)</a>)（信息）</li><li><a href="http://developer.android.youdaxue.com/reference/android/util/Log.html?utm_source=udacity&amp;utm_medium=course&amp;utm_campaign=android_basics#d(java.lang.String,%20java.lang.String">d(String, String)</a>)（调试）</li><li><a href="http://developer.android.youdaxue.com/reference/android/util/Log.html?utm_source=udacity&amp;utm_medium=course&amp;utm_campaign=android_basics#v(java.lang.String,%20java.lang.String">v(String, String)</a>) (详情)</li></ul><p>它们对应的是不同的日志级别，当你运行应用时可以在下图所示位置进行设置：</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823220537.png" alt=""></p><p>当你设置日志级别时，它将显示该日志级别及<strong>更高级别</strong>的所有日志消息，所以“详情 (verbose)”日志级别显示的消息最多，而“错误”日志级别仅显示最严重的日志。</p><h2 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h2><p>在Android中，你可以把所有的字符内容都储存在一个文件里面，每一个字符都有一个唯一的ID。这样的话，当你创建一个想要翻译这个APP是，就只需要改变这个文件里面的东西了，而不用跑到每个文件里更改。这个文件就是 <em>res/values/strings.xml</em> 文件。</p><p>看上去是下面这个样子的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span> 姓名<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;toppings&quot;</span>&gt;</span>配料<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;order&quot;</span>&gt;</span>预定<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中第一个<code>&quot; &quot;</code> 里的就是id，后面的那个就是翻译的内容。</p><p>注：除了编写 string.xml 文件外，还可以使用 Android Studio 自身的 <strong>Translations Editor</strong> ，用起来很舒服。界面简单易懂，这里就不做介绍了。</p><p>调用这个文件的方式还是使用id进行调用，具体实现方式如下</p><ul><li>Java： <code>getString(R.string.name)</code> ，得到字符串</li><li>XML： <code>@string/name</code></li></ul><h2 id="Style-amp-Theme"><a href="#Style-amp-Theme" class="headerlink" title="Style &amp; Theme"></a>Style &amp; Theme</h2><p>emmmmmm不想写了，有生之年再来填坑吧</p><p>到时候看官方文档得了</p><h2 id="让你的应用连接到别的应用？"><a href="#让你的应用连接到别的应用？" class="headerlink" title="让你的应用连接到别的应用？"></a>让你的应用连接到别的应用？</h2><p>这里是运用 <strong>Intent</strong> 知识。<strong>Intent</strong> 是要求其他应用组件完成的一个信息，让我们的应用调用其他的应用，比如说连接到邮箱啊，相机啊日历啊等等。当然必须要确保有应用可以实现这个功能，要不然程序就会崩溃。</p><p>一般的 Intent 的里面有动作、数据URI、目录还有一些其他的消息等等</p><p>在 <a href="http://developer.android.youdaxue.com/guide/components/intents-common.html?utm_source=udacity&amp;utm_medium=course&amp;utm_campaign=android_basics">这里</a> 有一个比较基础的介绍。</p><p>例如，你想链接到邮件，就可以在 Java 文件中写入下面类似的语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">composeEmail</span><span class="hljs-params">(String[] addresses, String subject)</span> </span>&#123;<br>    Intent intent = <span class="hljs-keyword">new</span> Intent(Intent.ACTION_SENDTO);<br>    intent.setData(Uri.parse(<span class="hljs-string">&quot;mailto:&quot;</span>)); <span class="hljs-comment">// only email apps should handle this</span><br>    intent.putExtra(Intent.EXTRA_EMAIL, addresses);<br>    <span class="hljs-comment">//收件人地址，不过好像没效果</span><br>    intent.putExtra(Intent.EXTRA_SUBJECT, subject);<span class="hljs-comment">//主题</span><br>    <span class="hljs-keyword">if</span> (intent.resolveActivity(getPackageManager()) != <span class="hljs-keyword">null</span>) &#123;<br>        startActivity(intent);&#125;<br>    <span class="hljs-comment">//这个是为了防止没有应用可以外链而避免程序的崩溃</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="多屏应用"><a href="#多屏应用" class="headerlink" title="多屏应用"></a>多屏应用</h1><h2 id="Android资源文件"><a href="#Android资源文件" class="headerlink" title="Android资源文件"></a>Android资源文件</h2><p>这里只说 res 文件夹里的东西。这个里面的一般都是控制程序外观的文件，包括一些XML文件、图片、还有其他媒体文件</p><ul><li>layout文件夹：这个里面存放着的就是一些 activity 的XML文件，定义了应用的布局</li><li>mipmap文件夹：放应用图标的文件夹</li><li>value 文件夹<ul><li>color.xml：定义了应用的颜色，反正是各种颜色</li><li>dimensions.xml：包括不同的维度，高度，宽度等等，这一系列的</li><li>strings.xml：放置字符的，让我们很容易的将应用翻译成其他语言，以及更改文字等等</li><li>style.xml：包含主题和样式</li></ul></li></ul><h2 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h2><p>每个文件都必须有的一个文件。这个里面存放着应用的一些重要信息，比如java的包名、应用组件、Intent权限等等，以及所有的activity。</p><p>在这个里面，有一个 <strong>intent-filter</strong> 代码。具体长这样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个Intent是一种代码，用来要求其他应用执行操作；这个Intent-filter就厉害些，它相当于表明程序的入口。当点击应用图标时，Android将会发送一个Intent来启动我们的应用</p><p>当然在这里还可以更改每一个 Activity  的 lable 名称</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">android:label=&quot;@string/category_about&quot;<br></code></pre></td></tr></table></figure><h2 id="使用Intent打开其他Activity"><a href="#使用Intent打开其他Activity" class="headerlink" title="使用Intent打开其他Activity"></a>使用Intent打开其他Activity</h2><p>要使用Intent必须首先要创建一个Intent对象。然后传入两个值，一个 <em>context</em> 和一个 <em>class</em> 组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Intent intentName = <span class="hljs-keyword">new</span> Intent(<span class="hljs-keyword">this</span>, ActivityName.class)<br></code></pre></td></tr></table></figure><p>其中 <code>this</code> 表示当前 Activity 的 context</p><p>然后呢，打开这个Activity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">startActivity(intentName);<br></code></pre></td></tr></table></figure><p>这样的话安卓就会启动我们的Activity，应用也就相对应的切换到 <em>ActivityName</em> 这个里面了。</p><p>当然这个与上文 <strong>让你的应用连接到别的应用</strong> 的Intent是有所不同的。因此Intent可以被分为两类：<em>显式的 intent</em>和 <em>隐式的 intent</em> 。</p><p>显式的 intent 是指知道执行那个操作的是谁，是十分具体的指向。就是 <strong>本块</strong> 中的示例</p><p>隐式的 intent 是指你不知道执行那个操作的是谁，只要是可以执行的都可以执行操作。到最后是谁执行还不清楚。 <strong>让你的应用连接到别的应用</strong> 中的就是隐式的 intent </p><h2 id="事件监视器Listener"><a href="#事件监视器Listener" class="headerlink" title="事件监视器Listener"></a>事件监视器Listener</h2><p>之前点击应用，完成一系列的操作，我们是在 XML 文件中进行的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">android:onclick = &quot;methodInJava&quot;<br></code></pre></td></tr></table></figure><p>下面介绍的这个可以不用 XML 文件执行（其实也就是探究 <em>onclick</em> 的本质）</p><p>首先了解一下 <strong>过程</strong>，在用户点击按钮时（用户输入事件），物理设备会检测到一些数据，然后通知Android发生了这个事件，安卓就会通过点击的位置信息定位到相对应的View上。<strong>事件监视器</strong> 就是来获取这些信息的，如果有特定的信息传入[比如点击]，你知道这个事件发生了，就可以执行一些交互了，如 <code>methodInJava</code> 方法。</p><p>注：事件监视器在Java中其实是一个接口类。接口类中，方法全为抽象方法，也没有数据成员。</p><p>了解了过程，接下来就是要使用了，使用事件监视器可以按照以下3步走：</p><ol><li><p>建立一个事件监视器类</p><p>在 <em>Name.java</em>文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClickTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">View</span>.<span class="hljs-title">OnClickListener</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View view)</span> </span>&#123;<br>        <span class="hljs-comment">//做你想做的事情</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建事件监视器的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ClickTest cickTest = <span class="hljs-keyword">new</span>  ClickTest();<br></code></pre></td></tr></table></figure></li><li><p>连接你的事件监视器和对应的 View</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">TextView about = (TextView) findViewById(R.id.about);<br><span class="hljs-comment">//首先要构造一个TextView的实例才能对它进行操作嘛</span><br>about.setOnClickListener(cickTest)<br><span class="hljs-comment">//连接你的事件监视器和对应的 View</span><br></code></pre></td></tr></table></figure></li></ol><p>这样的话，事件监视器就被使用了。当然，为了代码的可读性，还可以进行简化，该文件为 <em>MainActivity.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将活动的内容设置为使用activity_main.xml布局文件，一般系统会自动生成</span><br><span class="hljs-comment">// 也就是说下面的内容定义在了 activity_main.xml 中</span><br><span class="hljs-comment">// 如果注释掉就会使 setOnClickListener 报错：NullPointerException</span><br>setContentView(R.layout.activity_main);<br><br><span class="hljs-comment">//创造出一个about的TextView实例出来，这样就可以对它进行操作了</span><br>TextView about = (TextView) findViewById(R.id.about);<br><br><span class="hljs-comment">//用户点击about这个文字的时候做出一些操作的方法</span><br><span class="hljs-comment">//使用事件监视器(Listener)需要调用set...Listener方法</span><br><span class="hljs-comment">//set...Listener方法需要传入一个...Listener对象</span><br><span class="hljs-comment">//此处本来应该构造一个有OnClickListener接口的aboutOnClickListener类的对象，然后将他示例化，但是本例中把这个简化了</span><br>about.setOnClickListener(<span class="hljs-keyword">new</span> OnClickListener() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View view)</span> </span>&#123;<br><span class="hljs-comment">//下面，创建一个Intent类对象，并直接把这个当做参数传递给startActivity方法</span><br><span class="hljs-comment">//用来打开AboutActivity</span><br>startActivity(<span class="hljs-keyword">new</span> Intent(MainActivity.<span class="hljs-keyword">this</span>, AboutActivity.class));<br>&#125;<br>&#125;<span class="hljs-comment">//直接创建一个OnClickListener的类，然后实例化当做setOnClickListener的参数</span><br>);<br><span class="hljs-comment">//以后可以看谁不爽直接 new 一个类出来</span><br></code></pre></td></tr></table></figure><h2 id="ArrayList-数组列表"><a href="#ArrayList-数组列表" class="headerlink" title="ArrayList[数组列表]"></a>ArrayList[数组列表]</h2><p>其实跟数组差不多。与数组的区别有以下几个方面：</p><ol><li>数组列表的长度是可以改变的，数组列表中有多少元素其长度就是多少</li><li>数组列表是一种类型，数组的话，就比较基本</li><li>既然是一种类型，就可以调用各种各样的方法，你还可以继承它，覆盖一些方法等等（可玩性更高吧）</li><li>数组列表只能包含对象数据类型，向 int 这种就只能使用它们的包装类了</li></ol><p>注：一般来说固定长度的使用数组，不固定长度的使用数组列表</p><p>ArrayList 的文档在：<a href="http://developer.android.youdaxue.com/reference/java/util/ArrayList.html?utm_source=udacity&amp;utm_medium=course&amp;utm_campaign=android_basics">这里</a></p><p>在 Java 中，ArrayList 继承自<a href="http://developer.android.youdaxue.com/reference/java/util/AbstractList.html">AbstractList</a><E>，实现implements <a href="http://developer.android.youdaxue.com/reference/java/util/List.html">List</a><E>接口，是一个泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">注：泛型类有主要以下类型参数：<br>E:元素K:键N:数字T:类型V:值<br></code></pre></td></tr></table></figure><p>下面列举一些常见的ArrayList使用方法</p><div class="table-container"><table><thead><tr><th>用途</th><th>Java</th></tr></thead><tbody><tr><td>创建数组列表</td><td><code>ArrayList&lt;Word&gt; familyList = new ArrayList&lt;Word&gt;();</code></td></tr><tr><td>增加元素</td><td><code>familyList.add(new Word(getString(R.string.phrase_Where), &quot;minto wuksus&quot;));</code></td></tr><tr><td>去除元素</td><td><code>familyList.remove(new Word(getString(R.string.phrase_Where), &quot;minto wuksus&quot;));</code></td></tr><tr><td>查看元素</td><td><code>familyList.get(0);</code>、<code>familyList.get(1);</code>、<code>familyList.get(2);</code></td></tr><tr><td>查看元素数量</td><td><code>familyList.size();</code></td></tr></tbody></table></div><h2 id="内存优化——ListView-ArrayAdapter"><a href="#内存优化——ListView-ArrayAdapter" class="headerlink" title="内存优化——ListView+ArrayAdapter"></a>内存优化——ListView+ArrayAdapter</h2><p>我们之前要创建一串列表时，肯定是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">LinearLayout number_LinearLayout = (LinearLayout) findViewById(R.id.numbers_LinearLayout);<span class="hljs-comment">//先建立一个LinearLayout</span><br>TextView[] textViews = <span class="hljs-keyword">new</span> TextView[restaurantsToTry.size()];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; restaurantsToTry.size(); i++) &#123;<br>    textViews[i] = <span class="hljs-keyword">new</span> TextView(<span class="hljs-keyword">this</span>);<br>    textViews[i].setText(restaurantsToTry.get(i));<br>    number_LinearLayout.addView(textViews[i]);<br>&#125;<span class="hljs-comment">//然后填上TextView</span><br></code></pre></td></tr></table></figure><p>但是随着数据的增大，一次显示的东西也曰来越多，所占用的内存也会越来越大，从而导致卡顿。这个是我们很不愿意看到了。为了解决这个问题，有以下的思路：</p><p>我们不一次显示所有的啊东西，只是显示屏幕上需要的东西。<strong>就是根据屏幕，创建所需要的视图</strong>。如果屏幕不需要，我们就不显示，把它抛弃了；如果需要就建立一个。这样成了一个可循环的了，屏幕上不需要的循环到屏幕上需要的。</p><p>做到这一步需要 <strong>一个可循环的ViewGroup</strong> + <strong>一个配适器(ArrayAdapter)</strong> 。可循环的ViewGroup有：ListView、GridView、RecylcerView 等等</p><p>下面来以ListView为例说原理：</p><p>ArrayAdapter会处理数据，将他们调用或传输到ListView上，然后在上面显示</p><p>ListView可以看成是用户界面，ArrayAdapter是处理数据的。</p><p>ListView首先会向ArrayAdapter询问数据的长度。然后ListView会向ArrayAdapter调用一个方法（相当于一个请求），传入一个position，即用户正在查看的列表的位置。得到了请求之后，ArrayAdapter会查看数据结构，然后<strong>创造出一个View</strong>出来。当屏幕占满的时候，ListView就会停止请求。当屏幕滚动的时候，不在可见的View就会到一个 Scrap Views 的地方，然后ListView请求新的东西，传入 Scrap Views 的position，然后达到循环利用。</p><p>原理部分说明完毕。（其实最后还是有些不清楚。。。）</p><p>实现这个还是要三步走：</p><ol><li><p>构造一个ListView对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ListView listview = (ListView) findViewById(R.id.list)<br></code></pre></td></tr></table></figure><p>这样才能对ListView进行操作嘛。当然，为了实现这个必须想要建立一个id为R.id.list的ListView在xml文件中，比如这个</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ListView</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/list&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:padding</span>=<span class="hljs-string">&quot;@dimen/activity_vertical_margin&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>构造一个ArrayAdapter对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayAdapter arrayAdapter = <span class="hljs-keyword">new</span> WordAdapter(<span class="hljs-keyword">this</span>, arrayListName);<br></code></pre></td></tr></table></figure><p>第一个参数为context，第二个参数为要传入其中的arrayList，数组啊等等</p></li><li><p>将ListView对象与ArrayAdapter对象联系起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">listView.setAdapter(arrayAdapter);<br></code></pre></td></tr></table></figure></li></ol><p>这样的话，一个列表就形成了。不过目前还有一个问题：ArrayList一次只能传入一个参数。ArrayAdapter只能生成一个TextView。如果想要产生一个比较复杂的列表（比如通讯录既有图片又有文字），采用刚刚那样就会报错。</p><p>如果需要解决就必须要自定义一些内容，下面介绍自定义的东西：</p><ul><li><p>数据类</p><p>这是由于ArrayList造成的。ArrayList一次只能传入一个参数。如果一个列有两个项目（比如一个单词的翻译放在List就有中文和英文两项），就必须要自己创造一种类型。这种类型包含两个项目。比如说这里就可以创造一个 Word 类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Word</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String defaultWord;<br>    <span class="hljs-keyword">private</span> String anotherWord;<br><br>    <span class="hljs-comment">//获取default语言</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDefaultWord</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> defaultWord;&#125;<br><br>    <span class="hljs-comment">//获取另外一种语言</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAnotherWord</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> anotherWord;&#125;<br><br>    <span class="hljs-comment">//构造函数无返回值</span><br>    Word(String defaultWord, String anotherWord) &#123;<br>        <span class="hljs-keyword">this</span>.defaultWord = defaultWord;<br>        <span class="hljs-keyword">this</span>.anotherWord = anotherWord;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>配适器（Adapter）类</p><p>这回是要创建自己的Adapter，让它能够一次生成多个View出来（改写getView方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WordAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ArrayAdapter</span>&lt;<span class="hljs-title">Word</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">//构造函数，不写这个不给用ArrayAdapter</span><br>    WordAdapter(Activity context, ArrayList&lt;Word&gt; wordArrayList) &#123;<br>        <span class="hljs-comment">//第二个参数设置，在 getView 方法中会得到，因此可以是任何数字</span><br>        <span class="hljs-keyword">super</span>(context, <span class="hljs-number">0</span>, wordArrayList);<br>    &#125;<br><br>    <span class="hljs-comment">//为 AdapterView 提供（构件）View</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">getView</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;<br>        <span class="hljs-comment">// Check if the existing view is being reused, otherwise inflate the view</span><br>        View listItemView = convertView;<br>        <span class="hljs-keyword">if</span> (listItemView == <span class="hljs-keyword">null</span>) &#123;<br>            listItemView = LayoutInflater.from(getContext()).inflate(<br>                    R.layout.list_item, parent, <span class="hljs-keyword">false</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 获取 restaurantsToTry[ArrayList类] 在position这个位置上的值</span><br>        <span class="hljs-comment">// 在这个例子中，这个值是一个 Word 类型的</span><br>        Word currentAndroidFlavor = getItem(position);<br><br>        <span class="hljs-comment">// 建立一个指定id的 TextView 的实例，并且命名为 nameTextView</span><br>        <span class="hljs-comment">// 注意：findViewById方法在 View中有，在这里没有</span><br>        <span class="hljs-comment">//因此要通过 listItemView.findViewById调用</span><br>        TextView nameTextView = (TextView) listItemView.findViewById(R.id.numbers_translate_TextView);<br>        nameTextView.setText(currentAndroidFlavor.getDefaultWord());<br><br>        TextView numberTextView = (TextView) listItemView.findViewById(R.id.numbers_micwok_TextView);<br>        numberTextView.setText(currentAndroidFlavor.getMiwokWord());<br><br>        <span class="hljs-keyword">return</span> listItemView;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>这样的话一些自定义也结束了。</p>]]></content>
    
    
    <categories>
      
      <category>计算机相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>Android</tag>
      
      <tag>Google</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>课程设计：牛头刨床机构的分析与综合</title>
    <link href="/2018/01/28/WHUT/CourseDesignOfMechanicalPrinciple/"/>
    <url>/2018/01/28/WHUT/CourseDesignOfMechanicalPrinciple/</url>
    
    <content type="html"><![CDATA[<p>机械原理课程设计实验报告书</p><p>这个是一个很经典的设计，这些年来一直都没有变过</p><span id="more"></span><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【机械原理】课程设计说明书_Page_01.png" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【机械原理】课程设计说明书_Page_02.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【机械原理】课程设计说明书_Page_03.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【机械原理】课程设计说明书_Page_04.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【机械原理】课程设计说明书_Page_05.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【机械原理】课程设计说明书_Page_06.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【机械原理】课程设计说明书_Page_07.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【机械原理】课程设计说明书_Page_08.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【机械原理】课程设计说明书_Page_09.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【机械原理】课程设计说明书_Page_10.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【机械原理】课程设计说明书_Page_11.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【机械原理】课程设计说明书_Page_12.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【机械原理】课程设计说明书_Page_13.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【机械原理】课程设计说明书_Page_14.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【机械原理】课程设计说明书_Page_15.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【机械原理】课程设计说明书_Page_16.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/【机械原理】课程设计说明书_Page_17.png" alt=""></p><h1 id="图纸"><a href="#图纸" class="headerlink" title="图纸"></a>图纸</h1><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200822185327.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>机械相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程设计</tag>
      
      <tag>机械</tag>
      
      <tag>机械原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>互换性与测量技术笔记</title>
    <link href="/2018/01/17/WHUT/InterchangeabilityAndMeasuringTechnology/"/>
    <url>/2018/01/17/WHUT/InterchangeabilityAndMeasuringTechnology/</url>
    
    <content type="html"><![CDATA[<p>听正在工作的师兄说这是一门非常重要的课程。</p><p>基于《互换性与测量技术》（ISBN：978-7-118-08882-3）</p><span id="more"></span><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="互换性"><a href="#互换性" class="headerlink" title="互换性"></a>互换性</h4><p>按照规定的几何、物理及其他质量参数的极限，来分别制造机械的各个组成部分，使其在装配与更换时不需辅助加工及修配，便能很好的满足使用和生产上的要求的特性</p><p>简单点说就是：将一批工件按照一定的<strong>标准</strong>来制作，它们之间在功能上可以彼此相互替换，这样的性质就是互换性</p><ul><li>完全互换性与不完全互换性</li></ul><p>在装配和更换时，不需要选择或调整的互换为完全互换；需要对工件进行选择、分组替换的为不完全替换。<br><code>例如：滚珠轴承的维护或更换时采用完全互换；而它自身的生产则采用不完全互换。</code></p><h4 id="优先数与优先数集"><a href="#优先数与优先数集" class="headerlink" title="优先数与优先数集"></a>优先数与优先数集</h4><p>国标规定优先数系是以公比q=10^(1/r) 的一串数字，其中常见的r有R5（q≈1.6）、R10(q≈1.25）、R20(q≈1.12)、R40(q≈1.06)<code>例如R5系列在1~10有：1、1.6、1.6^2≈2.5、2.5*1.6=4、4*1.6≈6.3、6.3*1.6≈10</code></p><p>优先数的复合使用：在前面用较密的R10系列，在后面用较疏的R5系列；派生使用：使用R10/3系列（1,2,4…）(从R10中每3个数取一个数构成的数系)</p><h4 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h4><h5 id="公称尺寸（D，d）"><a href="#公称尺寸（D，d）" class="headerlink" title="公称尺寸（D，d）"></a>公称尺寸（D，d）</h5><p>由图样规范确定的理想尺寸。</p><h5 id="实际尺寸（Da，da）"><a href="#实际尺寸（Da，da）" class="headerlink" title="实际尺寸（Da，da）"></a>实际尺寸（Da，da）</h5><p>实际测量得到的尺寸</p><h5 id="极限尺寸（Ds，ds，Di，di）"><a href="#极限尺寸（Ds，ds，Di，di）" class="headerlink" title="极限尺寸（Ds，ds，Di，di）"></a>极限尺寸（Ds，ds，Di，di）</h5><p>尺寸要素允许的最大尺寸称为上极限尺寸Ds，ds，尺寸要素允许的最小尺寸称为上极限尺寸Di，di。<br>工件合格的标准是：Di&lt;=Da&lt;=Ds; di&lt;=da&lt;=ds。</p><h5 id="作用尺寸"><a href="#作用尺寸" class="headerlink" title="作用尺寸"></a>作用尺寸</h5><p>以下的“体外”可以理解为无材料的部分</p><p>体外作用尺寸：在配合全长上，与实际体外相接的最(大/小)理想(轴/孔)的尺寸</p><p>体外作用尺寸：在配合全长上，与实际体外相接的最(小/大)理想(轴/孔)的尺寸</p><h5 id="实体尺寸（DM，DL，dM，dL）"><a href="#实体尺寸（DM，DL，dM，dL）" class="headerlink" title="实体尺寸（DM，DL，dM，dL）"></a>实体尺寸（DM，DL，dM，dL）</h5><p>MMC：组成要素的局部尺寸处处位于使工件材料量最多的状态称为最大实体尺寸DM=Di；dm=ds</p><p>LMS：组成要素的局部尺寸处处位于使工件材料量最少的状态称为最小实体尺寸DM=Ds；dm=d</p><p>MMVS：在达到MMC的情况下，中心要素的形位公差也达到最大，此时的体外作用尺寸称为<strong>最大实体实效尺寸</strong></p><p>Dmv = Di - t            dmv = ds + t</p><h4 id="公差与偏差"><a href="#公差与偏差" class="headerlink" title="公差与偏差"></a>公差与偏差</h4><h5 id="尺寸偏差（有正负号）"><a href="#尺寸偏差（有正负号）" class="headerlink" title="尺寸偏差（有正负号）"></a>尺寸偏差（有正负号）</h5><ul><li>上极限偏差Es=Ds-D；es=ds-d</li><li>下极限偏差Ei=Di-D；ei=di-d</li><li>实际偏差Ea=Da-D；ea=da-d</li></ul><p>工件合格需满足：Ei&lt;=Ea&lt;=Es；ei&lt;=ea&lt;=es</p><h5 id="尺寸公差（Th，Ts）"><a href="#尺寸公差（Th，Ts）" class="headerlink" title="尺寸公差（Th，Ts）"></a>尺寸公差（Th，Ts）</h5><p>孔的公差Th=Ds-Di=Es-Ei轴的公差Ts=ds-di=es-ei</p><h5 id="公差带图"><a href="#公差带图" class="headerlink" title="公差带图"></a>公差带图</h5><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200822204143.png" alt="公差带图"></p><h4 id="配合"><a href="#配合" class="headerlink" title="配合"></a>配合</h4><h5 id="间隙配合"><a href="#间隙配合" class="headerlink" title="间隙配合"></a>间隙配合</h5><p>间隙配合包括最小间隙为0的配合</p><p>最大间隙 Xmax = Ds - di = Es - ei    (&gt;0)<br>最小间隙 Xmin = Di - Ds = Ei - es    (&gt;0)<br>平均间隙 Xav = ( Xmax + Xmin ) / 2    (&gt;0)</p><h5 id="过盈配合"><a href="#过盈配合" class="headerlink" title="过盈配合"></a>过盈配合</h5><p>间隙配合包括最小过盈为0的配合</p><p>最大过盈 Ymax = Di - ds = Ei - es    (&lt;0)<br>最小过盈 Ymin  = Ds - di = Es - ei    (&lt;0)<br>平均间隙 Yav = ( Ymax + Ymin ) / 2    (&lt;0)</p><h5 id="过渡配合"><a href="#过渡配合" class="headerlink" title="过渡配合"></a>过渡配合</h5><p>最大间隙 Xmax = Ds - di = Es - ei<br>最大过盈 Ymax = Di - ds = Ei - es<br>平均间隙 Xav = ( Xmax + Ymax ) / 2</p><h5 id="配合公差"><a href="#配合公差" class="headerlink" title="配合公差"></a>配合公差</h5><p>组成配合的孔、轴公差之和</p><p>Tf = Th +Ts</p><p>Tf不能过大（会造成配合困难）；也不能过小（配合比较困难）</p><h5 id="配合公差带图"><a href="#配合公差带图" class="headerlink" title="配合公差带图"></a>配合公差带图</h5><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200822204228.png" alt="配合公差带图"></p><h3 id="几何公差"><a href="#几何公差" class="headerlink" title="几何公差"></a>几何公差</h3><p>总共有14个形位公差，其中有8个位置公差</p><h4 id="标注"><a href="#标注" class="headerlink" title="标注"></a>标注</h4><p>形位公差的标注主要有：框格、被测要素和基准要素</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200822204254.png" alt=""></p><ul><li><p>注意：</p><p>当需要标出的要素为<strong>组成要素</strong>（零件外形上可接触的点、线、面）时，箭头应<strong>垂直指向要素的轮廓或其引出线上</strong>，并且<strong>与尺寸线明显错开</strong></p><p>当需要标出的要素为<strong>导出要素</strong>（不可接触的中心对称部分）时，箭头应<strong>与尺寸线对齐</strong>，并且可以代替其中一个箭头</p></li></ul><h4 id="形状公差"><a href="#形状公差" class="headerlink" title="形状公差"></a>形状公差</h4><p>不涉及基准，其方向和位置随实际要素不同而浮动</p><div class="table-container"><table><thead><tr><th>特征</th><th>公差带定义</th><th>解释</th></tr></thead><tbody><tr><td>直线度</td><td>在给定平面内，公差带是距离为公差值的两直线间的区域</td><td>被测要素必须位于平行于所给平面，距离为公差值的两直线内</td></tr><tr><td></td><td>在给定方向上，公差带是距离为公差值的两平面间的区域</td><td>被测要素必须位于平行于所给方向，距离为公差值的两平面间</td></tr><tr><td></td><td>在任意方向上，公差带是直径为公差值的圆柱面内的区域</td><td>被测要素必须位于直径为公差值的圆柱面内</td></tr><tr><td>平面度</td><td>公差带是距离为公差值的两平面间的区域</td><td>被测表面必须位于距离为公差值的两平面间</td></tr><tr><td>圆度</td><td>公差带是半径差为公差值的两同心圆之间的区域</td><td>被测表面必须位于距离为公差值的两同心圆之间</td></tr><tr><td>圆柱度</td><td>公差带是半径差为公差值的两同轴圆柱面之间的区域</td><td>被测表面必须位于半径差为公差值的两同轴圆柱面之间</td></tr></tbody></table></div><h4 id="形状或位置公差"><a href="#形状或位置公差" class="headerlink" title="形状或位置公差"></a>形状或位置公差</h4><p>无基准时为形状公差，有基准时为位置公差。公差带是公差值的两等距曲线或曲面之间的区域</p><h4 id="位置公差"><a href="#位置公差" class="headerlink" title="位置公差"></a>位置公差</h4><h5 id="定向公差"><a href="#定向公差" class="headerlink" title="定向公差"></a>定向公差</h5><p>用于限制被测形体对基准的方向变动。</p><p>定向公差带相对基准有明确的方向，而且它不仅控制方向，也控制了形状。（一般标注了定向公差不再规定形状公差）</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200822204328.png" alt=""></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200822204354.png" alt=""></p><h5 id="定位公差"><a href="#定位公差" class="headerlink" title="定位公差"></a>定位公差</h5><p>用于限制被测要素对基准的位置变动</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200822204418.png" alt=""></p><h5 id="跳动公差"><a href="#跳动公差" class="headerlink" title="跳动公差"></a>跳动公差</h5><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200822204440.png" alt=""></p><h4 id="形位公差值之间的协调关系"><a href="#形位公差值之间的协调关系" class="headerlink" title="形位公差值之间的协调关系"></a>形位公差值之间的协调关系</h4><ul><li>① 形状公差 &lt; 定向公差 &lt; 定位公差 &lt; 尺寸公差</li><li>② 直线度 &lt; 平面度；圆度 &lt; 圆柱度</li></ul><h2 id="互换性要求"><a href="#互换性要求" class="headerlink" title="互换性要求"></a>互换性要求</h2><h3 id="《极限与配合》国家标准"><a href="#《极限与配合》国家标准" class="headerlink" title="《极限与配合》国家标准"></a>《极限与配合》国家标准</h3><h4 id="公差"><a href="#公差" class="headerlink" title="公差"></a>公差</h4><p>确定尺寸精确程度的等级称为公差等级，由公差代号IT 和 公差等级数字01、0、1、2……18表示，从IT01~IT18等级精度依次降低，相应的公差数值依次增大，加工越容易</p><ul><li>常见的标准公差数值</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">公称尺寸</th><th style="text-align:center">IT6</th><th style="text-align:center">IT7</th><th style="text-align:center">IT8</th></tr></thead><tbody><tr><td style="text-align:center">&gt;30~50</td><td style="text-align:center">16</td><td style="text-align:center">25</td><td style="text-align:center">39</td></tr><tr><td style="text-align:center">&gt;50~80</td><td style="text-align:center">19</td><td style="text-align:center">30</td><td style="text-align:center">46</td></tr><tr><td style="text-align:center">&gt;80~120</td><td style="text-align:center">22</td><td style="text-align:center">35</td><td style="text-align:center">54</td></tr><tr><td style="text-align:center">&gt;120~180</td><td style="text-align:center">25</td><td style="text-align:center">40</td><td style="text-align:center">63</td></tr></tbody></table></div><p>工艺等价原则：配合的孔、轴加工难度应该相当。因此在间隙配合与过渡配合时，</p><p>  ①当公称直径 <strong>D≤500mm</strong> 时且 <strong>IT≤8</strong> 时，有孔应该比轴的标准公差等级低一级，例如：Φ50G8/h7</p><p>  ②当 <strong>IT&gt;9</strong> 时，孔和轴应该取同级</p><h4 id="偏差"><a href="#偏差" class="headerlink" title="偏差"></a>偏差</h4><p><strong>基本偏差</strong>：<strong>一般</strong>指靠近零线或位于零线的那个极限偏差</p><p>基本偏差代号：A、B、C、CD、E、EF、F、FG、G、H、J、JS、K、M、N、P、R、S、T、U、V、X、Y、Z、ZA、ZB、ZC（没有L、O、Q、W）</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200822204503.png" alt=""></p><ul><li>a-h与 H 为间隙配合（A-H 与 h）</li><li>j-n 与 H 为过渡配合（J-N 与 h ）</li><li>p-zc与H为过盈配合（P-ZC与h）</li></ul><p>注：<strong>JS/js</strong>的上下偏差与IT有关，为 IT/2 或 ( IT -1)/2。其基本偏差可以是上偏差，也可以是下偏差。</p><h4 id="配合制"><a href="#配合制" class="headerlink" title="配合制"></a>配合制</h4><p>国家标准中规定有基孔制配合和基轴制配合</p><ul><li>基孔制指定了优先配合13个，基轴制指定了优先配合13个</li></ul><p>选用：优先选择基孔制，其次基轴制<code>①与冷拉钢配合②与标准件配合③直径小的轴④一轴多孔</code>，特殊场合采用非基准值</p><p>注：基孔制与基轴制平行，<code>例如：H7/k6与K7/h6的配合性质相同</code></p><h3 id="几何公差相关要求"><a href="#几何公差相关要求" class="headerlink" title="几何公差相关要求"></a>几何公差相关要求</h3><h4 id="独立原则（IP）"><a href="#独立原则（IP）" class="headerlink" title="独立原则（IP）"></a>独立原则（IP）</h4><p>最严格的一种要求，图样上给定的各个尺寸和形状、位置公差要求都是独立的，应该分别满足要求。</p><h4 id="包容要求（ER）"><a href="#包容要求（ER）" class="headerlink" title="包容要求（ER）"></a>包容要求（ER）</h4><p>实质：直接用尺寸公差来控制中心要素的形位误差，主要运用于保证配合性质</p><p>合格性条件：</p><p>1.体外作用尺寸受最大实体尺寸限制 <strong>Dfe ≥ Di</strong> 、 <strong>dfe ≤ ds</strong></p><p>2.局部作用尺寸受最小实体尺寸限制 <strong>Da ≤ Ds</strong> 、 <strong>da ≥ di</strong></p><p>注：当轴的实际尺寸等于最大实体尺寸时，不允许轴线有直线度误差。</p><h4 id="最大实体要求（MMR）"><a href="#最大实体要求（MMR）" class="headerlink" title="最大实体要求（MMR）"></a>最大实体要求（MMR）</h4><p>实质：控制被测要素实际轮廓处于最大实体实效边界内的一种公差要求，运用于配合要求不严格，但能顺利的装入配上的场合</p><p>合格性条件：</p><p>1.体外作用尺寸受最大实体实效尺寸限制 <strong>Dfe ≥ Di - t</strong> 、 <strong>dfe ≤ ds + t</strong></p><p>2.局部作用尺寸受尺寸公差限制 <strong>Di ≤ Da ≤ Ds</strong> 、 <strong>di ≤ da ≤ ds</strong></p><h2 id="测量与检验"><a href="#测量与检验" class="headerlink" title="测量与检验"></a>测量与检验</h2><h3 id="技术测量"><a href="#技术测量" class="headerlink" title="技术测量"></a>技术测量</h3><p>测量就是将被测量与测量单位或标准量在数值上进行比较，从而确定两者比值的实验认知过程。包括测量对象、计量单位、测量方法、测量精度</p><h4 id="量块"><a href="#量块" class="headerlink" title="量块"></a>量块</h4><p>一种 <strong>无刻度</strong> 的标准 端面 量具，其制造材料多为<strong>特殊合金钢</strong>，一般为长方六面体结构，其中两个<strong>互相平行的极为光滑的平面</strong>为测量面</p><ul><li>标称长度的位置</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">&lt;6mm</th><th style="text-align:center">=6mm</th><th style="text-align:center">&gt;6mm</th></tr></thead><tbody><tr><td style="text-align:center">测量面上</td><td style="text-align:center">非测量面上，且该表面的左右两侧面在测量面上</td><td style="text-align:center">非测量面上，且该表面的左右两侧面在测量面上</td></tr></tbody></table></div><ul><li>※第二套量块（83块）的尺寸系列</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">尺寸系列/mm</th><th style="text-align:center">间隔/mm</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td style="text-align:center">0.5</td><td style="text-align:center">-</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">-</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1.005</td><td style="text-align:center">-</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1.01,1.02,……1.49</td><td style="text-align:center">0.01</td><td style="text-align:center">49</td></tr><tr><td style="text-align:center">1.5,1.6,……1.9</td><td style="text-align:center">0.1</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">2.0,2.5,……9.5</td><td style="text-align:center">0.5</td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">10,20,……100</td><td style="text-align:center">10</td><td style="text-align:center">10</td></tr></tbody></table></div><ul><li><p>量块的使用</p><p>①按级使用：直接将量块的标称长度作为工作长度（测量精度有影响，但不用加修订值）</p><p>②按等使用：将量块经检定后给出的实际中心长度作为工作长度（排除了量块的制造误差）</p></li></ul><h4 id="测量分类"><a href="#测量分类" class="headerlink" title="测量分类"></a>测量分类</h4><p>绝对测量：测量器具的式值直接反映被测量值 的测量。例如，直尺千分尺的测量</p><p>相对测量：将被测量与一个标准量值进行比较得到两者差值 的测量。例如，立式光学比较仪的测量</p><h3 id="表面粗糙度"><a href="#表面粗糙度" class="headerlink" title="表面粗糙度"></a>表面粗糙度</h3><p>零件的表面会存在几何误差，根据波距的大小，将表面误差分为3种：①波距小于1mm，称为表面粗糙度；②1~10mm称为表面波纹度；③大于10mm称为表面宏观形状误差</p><h4 id="粗糙度对零件使用性能的影响"><a href="#粗糙度对零件使用性能的影响" class="headerlink" title="粗糙度对零件使用性能的影响"></a>粗糙度对零件使用性能的影响</h4><h5 id="摩擦磨损方面"><a href="#摩擦磨损方面" class="headerlink" title="摩擦磨损方面"></a>摩擦磨损方面</h5><p>零件表面越粗糙，表面的摩擦系数越大，摩擦阻力也就越大，零件配合表面的磨损也就越快。</p><h5 id="配合性质方面"><a href="#配合性质方面" class="headerlink" title="配合性质方面"></a>配合性质方面</h5><p>表面粗糙度会影响配合性质。对于间隙配合，粗糙的表面会使峰顶迅速磨平，使间隙逐渐增大；对过盈配合，粗糙的表面会使峰顶挤平，实际有效过盈量减少。</p><h5 id="疲劳强度方面"><a href="#疲劳强度方面" class="headerlink" title="疲劳强度方面"></a>疲劳强度方面</h5><p>粗糙度越大，一般表面的凹痕就越深，交变应力作用下的应力集中也就越大，越容易造成零件疲劳强度的降低。</p><h5 id="耐腐蚀方面"><a href="#耐腐蚀方面" class="headerlink" title="耐腐蚀方面"></a>耐腐蚀方面</h5><p>表面越粗糙，腐蚀性的气体或液体越容易在谷底聚集，渗入金属内部，造成腐蚀。</p><h5 id="结合面密封性方面"><a href="#结合面密封性方面" class="headerlink" title="结合面密封性方面"></a>结合面密封性方面</h5><p>粗糙的表面相互结合时，有为接触的部分，会产生间隙，影响密封性</p><h4 id="粗糙度轮廓的评定参数"><a href="#粗糙度轮廓的评定参数" class="headerlink" title="粗糙度轮廓的评定参数"></a>粗糙度轮廓的评定参数</h4><p>有幅度参数、间距参数、形状参数等</p><h5 id="轮廓算术平均偏差Ra"><a href="#轮廓算术平均偏差Ra" class="headerlink" title="轮廓算术平均偏差Ra"></a>轮廓算术平均偏差Ra</h5><p>在取样长度内，轮廓各点至基准线距离的算术平均值</p><h5 id="轮廓的最大高度Rz"><a href="#轮廓的最大高度Rz" class="headerlink" title="轮廓的最大高度Rz"></a>轮廓的最大高度Rz</h5><p>在一个取样长度内，最大轮廓峰高和最大轮廓谷深之和</p><h4 id="评定参数值的选择"><a href="#评定参数值的选择" class="headerlink" title="评定参数值的选择"></a>评定参数值的选择</h4><p>总原则：在满足零件功能的要求下，尽可能是参数的允许值大。具体选用时，先根据经验统计资料初步选择，然后对比工作条件做出适当的调整。调整时，需要注意：</p><p>1.同一零件上，工作面上的粗糙度值比非工作面小</p><p>2.摩擦表面的粗糙度值比非摩擦面小</p><p>3.高速、大应力等的粗糙度小</p><p>4.表面粗糙度参数值应该与尺寸公差及形状公差相协调</p><h4 id="表面粗糙度的测量"><a href="#表面粗糙度的测量" class="headerlink" title="表面粗糙度的测量"></a>表面粗糙度的测量</h4><ul><li>比较法，将被测表面与已知其幅度参数值的表面粗糙度标准样块比较</li><li>光学测量法，其中有一种是光切法</li></ul><h3 id="光滑工件尺寸的检验"><a href="#光滑工件尺寸的检验" class="headerlink" title="光滑工件尺寸的检验"></a>光滑工件尺寸的检验</h3><p>孔轴的尺寸公差与几何公差的关系采用独立原则时，使用通用测量器来测量。而当采用包容要求是，则是采用光滑极限量规进行检验</p><p>检验要求：只允许误废，不允许误收。</p><h4 id="光滑极限量规"><a href="#光滑极限量规" class="headerlink" title="光滑极限量规"></a>光滑极限量规</h4><ul><li>1.检验孔的称为塞规，检验轴的称为环规</li><li>2.量规由通规和止规构成，通规按照最大实体尺寸制造；止规按照最小实体尺寸制造。</li><li>3.量规按照使用方法的不同，分为三种：工作量规（一般使用的量规）、检收量规（检验量规的量规）、校对量规</li><li>4.量规的尺寸设计：<ol><li>通规的公称直径为工件的最大实体尺寸，止规的公称直径为工件的最小实体尺寸</li><li>通规在使用时经常磨损，因此为了防止误收，需要为通规留出一定的预留量，即公差带内缩</li></ol></li></ul><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200822204531.png" alt=""></p><h2 id="常见结构互换性"><a href="#常见结构互换性" class="headerlink" title="常见结构互换性"></a>常见结构互换性</h2><h3 id="滚动轴承"><a href="#滚动轴承" class="headerlink" title="滚动轴承"></a>滚动轴承</h3><h4 id="配合特点"><a href="#配合特点" class="headerlink" title="配合特点"></a>配合特点</h4><p>滚珠轴承外圈与外壳孔的配合采用<strong>基轴制</strong>，滚珠轴承内圈与轴颈的配合采用<strong>基孔制</strong></p><p>滚珠轴承内圈与轴颈的基孔制与一般基孔制不同，标准规定：<strong>内圈基准孔公差带位于公称内径d为零线的下方，即上偏差为0，下偏差为负值</strong>。<code>原因：滚珠轴承配合时内圈经常磨损，为了防止这种情况，配合时应该有一定的过盈量。又由于这是薄壁零件，需要经常更换，因此过盈量不能过大。公差带布置在零件上方时，过盈量过大；采用间隙配合时，又会产生间隙。</code></p><h4 id="配合表面要求"><a href="#配合表面要求" class="headerlink" title="配合表面要求"></a>配合表面要求</h4><p>①凡是与轴承内、外圈配合的表面，通常对粗糙度提出了较高的要求。</p><p>②装配图上标注滚珠轴承和轴和壳体配合时，只标注轴和壳体的公差带代号</p><h3 id="键、花键"><a href="#键、花键" class="headerlink" title="键、花键"></a>键、花键</h3><p>采用基轴制</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200822204553.png" alt=""></p><h3 id="圆柱齿轮"><a href="#圆柱齿轮" class="headerlink" title="圆柱齿轮"></a>圆柱齿轮</h3><p>齿轮一般都是传递动力和运动的，其使用要求因用途不同而异，但归纳起来主要有4个方面传递运动的准确性、传递运动的平稳性、载荷</p><div class="table-container"><table><thead><tr><th>类型</th><th>要求</th></tr></thead><tbody><tr><td>读数与分度齿轮</td><td>传递运动的准确性</td></tr><tr><td>高速齿轮</td><td>传递运动的平稳性</td></tr><tr><td>传递动力的齿轮</td><td>载荷分布的均匀性</td></tr></tbody></table></div><h4 id="传递运动的准确性"><a href="#传递运动的准确性" class="headerlink" title="传递运动的准确性"></a>传递运动的准确性</h4><p>是指在<strong>一转</strong>范围内<strong>传动比</strong>的变动量。即一转范围内，从动齿轮转角误差的最大变动量。</p><p>如图所示，将理论转角与最大转角误差用图表画出，一般为余弦图像，转角误差的最大变化量△φ∑即为最大变动量。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200822204615.png" alt=""></p><h5 id="评定参数"><a href="#评定参数" class="headerlink" title="评定参数"></a>评定参数</h5><div class="table-container"><table><thead><tr><th>项目</th><th>解释说明</th><th>备注</th></tr></thead><tbody><tr><td>齿距累积总偏差Fp</td><td>齿轮各齿距与理论齿距偏差累计值的代数差的最大值（将齿轮各个齿以同一个齿为基准，由于加工误差，会出现齿距，此时测量的各个齿距误差为累计误差，各个齿累计误差的代数差最大的就是齿距累积总偏差）</td><td>必检项目，既可以反应切线误差也可以反应径向误差</td></tr><tr><td>齿距累积偏差Fpk</td><td>k个齿距的单个齿距偏差代数和（前面的是找出最大的代数差，这个是找出其中k个点的）</td><td>有时为必检项目</td></tr><tr><td>径向跳动Fr</td><td>-</td><td>主要反应同轴度误差</td></tr></tbody></table></div><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200822204634.png" alt=""></p><h4 id="传递运动的平稳性"><a href="#传递运动的平稳性" class="headerlink" title="传递运动的平稳性"></a>传递运动的平稳性</h4><p>是指齿轮回转过程中，瞬时传动比的变化尽量小。即在一齿过程中的最大转角误差。</p><p>一般来说，齿轮传递的不准确性及不平稳性，是同时存在的</p><h5 id="评定参数-1"><a href="#评定参数-1" class="headerlink" title="评定参数"></a>评定参数</h5><div class="table-container"><table><thead><tr><th>项目</th><th>解释说明</th><th>备注</th></tr></thead><tbody><tr><td>单个齿距偏差Fpt</td><td>一个齿齿距与理论值的偏差</td><td>必检项目</td></tr><tr><td>齿廓总偏差Fα</td><td>在计值范围内，包含实际廓线的两条设计迹线之间的距离</td><td>必检项目</td></tr><tr><td>齿廓形状偏差Ffα</td><td>在计值范围内，包含实际齿廓的两条与平均齿廓迹线等距的曲线间的距离</td><td>-</td></tr><tr><td>齿廓倾斜偏差FHα</td><td>在计值范围内，两端与平均迹线相交的两设计齿廓迹线间的距离</td><td>-</td></tr></tbody></table></div><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200822204651.png" alt=""></p><h4 id="载荷分布的均匀性"><a href="#载荷分布的均匀性" class="headerlink" title="载荷分布的均匀性"></a>载荷分布的均匀性</h4><p>用沿齿长和齿高方向上的接触面积表示。</p><h5 id="评定参数-2"><a href="#评定参数-2" class="headerlink" title="评定参数"></a>评定参数</h5><p>螺旋线偏差是评定轮齿载荷分布均匀性的指标</p><div class="table-container"><table><thead><tr><th>项目</th><th>解释说明</th><th>备注</th></tr></thead><tbody><tr><td>螺旋线总偏差Fβ</td><td>在计值范围内，包含实际廓线的两条设计迹线之间的距离</td><td>必检项目</td></tr><tr><td>螺旋线形状偏差Ffβ</td><td>在计值范围内，包含实际齿廓的两条与平均齿廓迹线等距的曲线间的距离</td><td>-</td></tr><tr><td>螺旋线倾斜偏差FHβ</td><td>在计值范围内，两端与平均迹线相交的两设计齿廓迹线间的距离</td><td>-</td></tr></tbody></table></div><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200822204718.png" alt=""></p><h4 id="齿轮副精度、传动侧隙"><a href="#齿轮副精度、传动侧隙" class="headerlink" title="齿轮副精度、传动侧隙"></a>齿轮副精度、传动侧隙</h4><p>为了保证齿轮转动灵活，通常留出一些侧隙用于储存润滑油等等物质</p><h5 id="评定参数-3"><a href="#评定参数-3" class="headerlink" title="评定参数"></a>评定参数</h5><div class="table-container"><table><thead><tr><th>项目</th><th>解释说明</th><th>备注</th></tr></thead><tbody><tr><td>轴线平面内的平行度偏差f∑δ</td><td>公共平面上两轴线的平行度误差</td><td>推荐值：f∑δ = ( L/b )·Fβ（L为箱体轴承孔跨距，b为齿轮齿厚）</td></tr><tr><td>垂直平面内的平行度偏差f∑β</td><td>垂直平面上两轴线的平行度误差</td><td>推荐值：f∑β = 0.5f∑δ</td></tr><tr><td>中心距允许偏差fa</td><td>顾名思义</td><td>5、6级精度齿轮：fa = IT7/2；7、8级精度齿轮：fa = IT9/2</td></tr><tr><td>齿厚偏差Esn</td><td>齿厚的实际值与公称值之差</td><td>公称齿厚 S = mzsin( 90°/z )</td></tr><tr><td>齿轮副最小法向侧隙jbn min</td><td>顾名思义</td><td>jbn min = 2/3( 0.06 + 0.0005a + 0.03mn)（工作时齿轮节圆线速度小于15m/s时）</td></tr><tr><td>分度圆上偏差Esns</td><td>不解释</td><td>Esns = -jbn min / (2cosαn)</td></tr><tr><td>齿厚公差Tsn</td><td>不解释</td><td>Tsn = 2tanαn · sqrt( Fr² + br² )（br为切齿时径向进刀公差允许值，Fr为齿轮径向跳动公差允许值）</td></tr><tr><td>分度圆下偏差Esni</td><td>不解释</td><td>Esni = Esns - Tsn = -jbn min/(2cosαn) - 2tanαn · sqrt( Fr² + br²)</td></tr></tbody></table></div><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200822204736.png" alt=""></p><h4 id="齿轮坯公差"><a href="#齿轮坯公差" class="headerlink" title="齿轮坯公差"></a>齿轮坯公差</h4><h5 id="精度等级表示方法"><a href="#精度等级表示方法" class="headerlink" title="精度等级表示方法"></a>精度等级表示方法</h5><p>示例：7Fp6(FαFβ)GB/T 10095.1—2008</p><p>含义：齿轮各项偏差项目均应符合GB/T10095.1—2008的要求，且Fp为7级精度，Fα与Fβ为6级精度</p><h5 id="齿轮检验组"><a href="#齿轮检验组" class="headerlink" title="齿轮检验组"></a>齿轮检验组</h5><p>①Fp（齿距累积总偏差）、Fα（齿廓总偏差）、Fβ（螺旋线总偏差）、Fr（齿轮径向跳动公差）、Esn（分度圆偏差）、Ebn（公法线长度极限偏差）</p><p>②Fp（齿距累积总偏差）、Fα（齿廓总偏差）、Fβ（螺旋线总偏差）、Fr（齿轮径向跳动公差）、Esn（分度圆偏差）、Ebn（公法线长度极限偏差）、Fpk（齿距累积偏差）</p><h5 id="齿轮坯顶圆直径偏差"><a href="#齿轮坯顶圆直径偏差" class="headerlink" title="齿轮坯顶圆直径偏差"></a>齿轮坯顶圆直径偏差</h5><p>= ±0.05mn</p><h4 id="齿轮精度的确定"><a href="#齿轮精度的确定" class="headerlink" title="齿轮精度的确定"></a>齿轮精度的确定</h4><p>①确定齿轮精度等级</p><p>​    可根据齿轮圆周线速度 v 确定齿轮精度等级</p><p>②确定最小侧隙和齿厚偏差</p><p>​    公称齿厚：<strong>S = m·z1·sin( 90°/z1 )</strong></p><p>​    最小侧隙：<strong>jbn min = 2/3 · ( 0.06 + 0.0005a + 0.03mn )</strong></p><p>​        其中：<strong>a = m( z1+z2 ) / 2</strong></p><p>​    齿厚偏差：<strong>Esns = - jbn min / ( 2cosαn )、Tsn = 2tanαn · sqrt( Fr² + br² )、Esni = Esns - Tsn</strong></p><p>​        其中：根据分度圆直径 <strong>d = m·z1</strong> 查表可得<strong>Fr、br</strong></p><p>​    综上，得到公称齿厚及偏差</p><p>③确定检验组</p><p>​    一般可取：<strong>Fp、Fα、Fβ、Fr、Esn、Ebn</strong></p><p>④确定齿轮副精度</p><p>​    中心距公差 <strong> ±fa = IT7/2（5、6级精度）</strong>或 <strong>±fa = IT9/2 （7、8级精度）</strong></p><p>​    轴线平行度偏差 <strong>f∑δ = (L/b)·Fβ</strong> 和 <strong>f∑β = 0.5 · f∑δ</strong></p><p>⑤齿轮坯精度</p><p>​    内孔尺寸偏差：根据 齿轮精度等级 查表得</p><p>​    齿顶圆直径偏差：<strong>±0.05m</strong></p><p>​    基准面尺寸公差：根据类型查表可得</p><p>​    表面粗糙度：根据 齿轮精度 查表可得</p>]]></content>
    
    
    <categories>
      
      <category>机械相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机械</tag>
      
      <tag>互换性与测量技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机械原理笔记</title>
    <link href="/2018/01/16/WHUT/PrincipleOfMechanism/"/>
    <url>/2018/01/16/WHUT/PrincipleOfMechanism/</url>
    
    <content type="html"><![CDATA[<p>一半是几何画图，一半是理论力学的应用，哦，还有个齿轮的计算。画图相关的现在都用计算机辅助软件了，估计过几年这门课就要改版了。</p><p>参考资料：《机械原理与机械设计》第三版（ISBN：978-7-04-039981-3）</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/bcedc069gy1fnpm922snpj21kw0ldn3k.jpg" alt="第一章思维导图"></p><span id="more"></span><h2 id="平面连杆机构"><a href="#平面连杆机构" class="headerlink" title="平面连杆机构"></a>平面连杆机构</h2><h3 id="平面连杆机构的基本特性"><a href="#平面连杆机构的基本特性" class="headerlink" title="平面连杆机构的基本特性"></a>平面连杆机构的基本特性</h3><p>平面四杆机构的基本形式是铰链四杆机构。运动副均为转动副的四连杆机构称为铰链四连杆机构。铰链四连杆机构中，能够整周回转的连架杆称为<strong>曲柄</strong>，不能的连架杆称为<strong>摇杆</strong>。按照连架杆的不同，又分为<strong>曲柄摇杆机构</strong>、<strong>双曲柄机构</strong>、<strong>双摇杆机构</strong></p><h4 id="曲柄存在的条件"><a href="#曲柄存在的条件" class="headerlink" title="曲柄存在的条件"></a>曲柄存在的条件</h4><p>当连架杆可以共线时，就可以存在曲柄</p><p>根据几何关系可以得到曲杆存在的条件：①最短杆与最长杆长度之和≤其他两杆长度之和②最短杆做连架杆或机架</p><p>总结可以得到，在满足上式①条件后：</p><div class="table-container"><table><thead><tr><th>做机架的杆</th><th>机构类型</th></tr></thead><tbody><tr><td>最短杆</td><td>双曲柄机构</td></tr><tr><td>最短杆临边</td><td>曲柄连杆机构</td></tr><tr><td>最短杆对边</td><td>双连杆机构</td></tr></tbody></table></div><h4 id="急回运动特性"><a href="#急回运动特性" class="headerlink" title="急回运动特性"></a>急回运动特性</h4><p>曲柄运动的时候做等速运动，而从动件在往返这两个阶段速度是不一样的，这就是<strong>急回运动特性</strong>，急回程度可以用<strong>行程变化系数K</strong>表示，K = 输出构件回程的平均速度/输出构件工作行程的平均速度</p><p>在曲柄摇杆机构中，曲柄与连杆两次共线的夹角称为<strong>极位夹角θ</strong>（θ为锐角），摇杆在这两个位置的夹角称为<strong>摆角</strong></p><p>极位夹角θ与K的关系：θ = 180° · (K-1)/(K+1)，其中当θ = 0时，K=1，机构无急回特性</p><h4 id="压力角与传动角"><a href="#压力角与传动角" class="headerlink" title="压力角与传动角"></a>压力角与传动角</h4><p>压力角：<em>主动件通过连杆作用于从动件的力</em> 与 <em>从动件作用点绝对速度</em> 的方向所夹的锐角</p><h4 id="死点位置"><a href="#死点位置" class="headerlink" title="死点位置"></a>死点位置</h4><p>主动件做往复运动时，存在死点位置（从动件无法从主动件获得力的位置）。</p><h2 id="凸轮机构"><a href="#凸轮机构" class="headerlink" title="凸轮机构"></a>凸轮机构</h2><p>1.优点：只要设计出适当的轮廓，即可实现特定的运动规律。结构简单，工作可靠</p><p>2.缺点：高副接触，压强较大，容易磨损，且费用较高。</p><h3 id="凸轮基本概念介绍"><a href="#凸轮基本概念介绍" class="headerlink" title="凸轮基本概念介绍"></a>凸轮基本概念介绍</h3><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/bcedc069gy1fnpm91j79xj21h013odh8.jpg" alt="凸轮"></p><p>1.基圆：以凸轮轮廓最小向径r0为半径所作的圆，r0为基圆半径</p><p>2.推程：从动件逐渐远离轴心的过程，此时转过的角度为推程运动角</p><p>3.回城：从动件由最高位置回到最低位置的过程，此时转过的角度为回程运动角</p><p>4.远休止角：推程结束到回程开始出所转动的夹角；近休止角：回程结束到推程开始出所转动的夹角</p><h3 id="从动件常见运动规律"><a href="#从动件常见运动规律" class="headerlink" title="从动件常见运动规律"></a>从动件常见运动规律</h3><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/bcedc069gy1fnpm92190uj21kw12a0xp.jpg" alt="从动件常见运动规律"><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/bcedc069gy1fnpm922jx2j21kw14hq84.jpg" alt="从动件常见运动规律"><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/bcedc069gy1fnpm923beaj21kw13iq8m.jpg" alt="从动件常见运动规律"></p><p>注：在等速运动规律中，运动的起点处和终点处速度发生了突变，机构会受到<strong>刚性冲击</strong>，等加速减速运动规律和余弦运动规律加速度产生突变，机构会受到<strong>柔性冲击</strong></p><h3 id="凸轮设计时的注意事项"><a href="#凸轮设计时的注意事项" class="headerlink" title="凸轮设计时的注意事项"></a>凸轮设计时的注意事项</h3><p>1.压力角随基圆半径的增大而减小</p><p>2.为了防止凸轮运动的失真，可以在滚子半径保持不变的状态下，将基圆半径变小</p><h2 id="齿轮机构"><a href="#齿轮机构" class="headerlink" title="齿轮机构"></a>齿轮机构</h2><blockquote><p>闲暇时做的视频</p></blockquote><iframe id=sbrxp src="//player.bilibili.com/player.html?aid=73314920&bvid=BV15E41117jt&cid=131041148&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width: 720px; height: 430px; max-width: 100%"> </iframe><h3 id="齿轮基本概念介绍"><a href="#齿轮基本概念介绍" class="headerlink" title="齿轮基本概念介绍"></a>齿轮基本概念介绍</h3><h4 id="齿廓"><a href="#齿廓" class="headerlink" title="齿廓"></a>齿廓</h4><p>我们的齿轮要求传动平稳。传动平稳，就是指在齿轮啮合中，传动比 i=ω1/ω2 为一常数。</p><p>由公式推导可得：要使传动比为常数，就需要齿轮轮廓能实现：无论在齿廓的哪一点接触（K点，未标出），过接触点（K）所作的两齿廓的公法线（n）必须与连心线（O1O2）交于一点（C）。这就是<strong>齿轮啮合基本定律</strong>，满足这个条件的齿廓叫共轭齿廓</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/bcedc069gy1fnpm91imvqj208c08cjro.jpg" alt="齿轮啮合基本定律"></p><p>这里提出一个概念：节圆。节圆是以O1、O2为圆心，以轮廓公法线与连心线交点（C）为半径的圆。</p><p>在机械中，常常使用渐开线，摆线或圆弧等等曲线作为轮廓线。而渐开线的运用最为广泛。</p><h5 id="渐开线"><a href="#渐开线" class="headerlink" title="渐开线"></a>渐开线</h5><p>渐开线是由直线沿圆作纯滚动时，直线上任意一点的轨迹。（我们把直线称为发生线，圆称为基圆，轨迹对应中心角叫展角。）</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/bcedc069gy1fnpm91ikd7j208c08c0t3.jpg" alt="渐开线"></p><p>其中：<br>1.直线长BK=弧长AB</p><p>2.渐开线任意法线与基圆相切（由此可推出渐开线符合齿轮啮合基本定律）</p><p>3.基圆越小，渐开线越弯曲</p><p>4.同一基圆任意两渐开线法向距离相等</p><p>5.压力角α=Rb（基圆半径）/OK，即基圆半径与向径的比值</p><p>6.基圆内无渐开线</p><p>7.渐开线方程：θ=tanα-α（这个式子也是求展角/压力角的式子）</p><h5 id="渐开线齿轮"><a href="#渐开线齿轮" class="headerlink" title="渐开线齿轮"></a>渐开线齿轮</h5><p>1.传动比=基圆半径的反比，即i12=r2/r1</p><p>2.可分性：在安装中即使有偏差，可可以保持传动比为定值（齿轮基圆半径不变，传动比不变）</p><p>3.啮合线：渐开线齿廓接触点轨迹</p><p>4.啮合角：啮合线与节圆公切线的夹角，用α’表示。</p><h5 id="齿轮基本参数"><a href="#齿轮基本参数" class="headerlink" title="齿轮基本参数"></a>齿轮基本参数</h5><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">代号</th><th style="text-align:center">计算公式</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">模数</td><td style="text-align:center">m</td><td style="text-align:center">根据强度计算或结构需要而定</td><td style="text-align:center">m为标准值</td></tr><tr><td style="text-align:center">齿数</td><td style="text-align:center">z</td><td style="text-align:center">根据强度计算或结构需要而定</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">中心距</td><td style="text-align:center">a</td><td style="text-align:center">a=m(z1+z2)/2</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">压力角</td><td style="text-align:center">α</td><td style="text-align:center">α=20°</td><td style="text-align:center">α为标准值</td></tr><tr><td style="text-align:center">分度圆直径</td><td style="text-align:center">d</td><td style="text-align:center">d1=mz1,d2=mz2</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">齿距</td><td style="text-align:center">p</td><td style="text-align:center">p=πm</td><td style="text-align:center">分度圆上</td></tr><tr><td style="text-align:center">齿厚</td><td style="text-align:center">s</td><td style="text-align:center">p=πm/2</td><td style="text-align:center">分度圆上</td></tr><tr><td style="text-align:center">齿槽宽</td><td style="text-align:center">e</td><td style="text-align:center">p=πm/2</td><td style="text-align:center">分度圆上</td></tr><tr><td style="text-align:center">基圆直径</td><td style="text-align:center">db</td><td style="text-align:center">db=dcosα=mzcosα</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">基圆齿距</td><td style="text-align:center">pb</td><td style="text-align:center">pb=πmcosα=mzcosα</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">齿顶圆直径</td><td style="text-align:center">da</td><td style="text-align:center">da=m(z+2)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">齿根圆直径</td><td style="text-align:center">df</td><td style="text-align:center">df=m(z-2.5)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">齿顶高</td><td style="text-align:center">ha</td><td style="text-align:center">ha=ha❀×m=m</td><td style="text-align:center">ha❀为标准值=1</td></tr><tr><td style="text-align:center">齿根高</td><td style="text-align:center">hf</td><td style="text-align:center">hf=（ha❀+c❀）m=1.25m</td><td style="text-align:center">c❀为标准值=0.25</td></tr></tbody></table></div><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/bcedc069gy1fnpm91luuoj209q09qgmm.jpg" alt="基本参数"></p><h5 id="齿条"><a href="#齿条" class="headerlink" title="齿条"></a>齿条</h5><p>没什么需要注意的……</p><h5 id="内齿轮"><a href="#内齿轮" class="headerlink" title="内齿轮"></a>内齿轮</h5><p>齿顶圆直径：da=d+2ha；齿顶圆直径：df=d-2hf（就是正负号换了一下而已）</p><p>对于内齿轮，齿顶圆必须大于基圆，为了使内齿轮齿廓全为渐开线</p><h4 id="渐开线标准直齿轮"><a href="#渐开线标准直齿轮" class="headerlink" title="渐开线标准直齿轮"></a>渐开线标准直齿轮</h4><h5 id="齿轮传动的正确啮合条件"><a href="#齿轮传动的正确啮合条件" class="headerlink" title="齿轮传动的正确啮合条件"></a>齿轮传动的正确啮合条件</h5><p>模数和压力角同时相等，即m1=m2,α1=α2<br><code>（正确啮合即齿距p相同 =&gt; p1=πm2cosα1=p2=πm2cosα2 =&gt; m1cosα1=m2cosα2）</code></p><h5 id="齿轮传动的连续性条件"><a href="#齿轮传动的连续性条件" class="headerlink" title="齿轮传动的连续性条件"></a>齿轮传动的连续性条件</h5><p>1.端面作用弧：从啮合开始到啮合结束，所转动的分度圆弧长（CD）</p><p>2.端面作用角φα=弧长CD/分度圆半径r：端面作用弧所对应的圆心角</p><p>3.齿距角τ=齿距p/分度圆半径r：齿距p所对圆心角</p><h5 id="重合度"><a href="#重合度" class="headerlink" title="重合度"></a>重合度</h5><p>1.定义式：εα=φα/τ，是实际啮合线与齿距的比值。</p><p>2.计算式：<strong>εα=[z1(tanαa1-tanα’)+z2(tanαa2-tanα’)]/2π</strong>。</p><p>其中αa1、αa2为1、2齿轮压力角，其值为αa1=acos(rb1/ra1)、αa2=acos(rb2/ra2)、α’=acos(rb/r’)</p><p>3.意义 ：εα越大，表示同时啮合的轮齿数越多。齿轮传动越平稳，承载能力越高</p><p>例如：εα=1.45表示平均1.45对齿轮参与啮合</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/bcedc069gy1fnpm91n4b7j209q09q0ti.jpg" alt="重合度"></p><h5 id="无侧隙啮合条件"><a href="#无侧隙啮合条件" class="headerlink" title="无侧隙啮合条件"></a>无侧隙啮合条件</h5><p>a’cosα’=acosα</p><p>其中：a为标准中心距，a’为实际中心距，α为压力角，α’为啮合角</p><ul><li>注：对于齿条而言，无论是否标准安装，啮合角等于分度圆压力角，齿轮节圆与分度圆恒重合</li></ul><h4 id="渐开线齿轮切齿原理"><a href="#渐开线齿轮切齿原理" class="headerlink" title="渐开线齿轮切齿原理"></a>渐开线齿轮切齿原理</h4><h5 id="加工方法"><a href="#加工方法" class="headerlink" title="加工方法"></a>加工方法</h5><p>1.仿形法：刀具的形状为齿槽齿廓的形状，然后直着切下去，形成渐开线齿廓<br>  缺点：齿轮精度低，生产率低，所需刀具多；优点：设备简单</p><p>2.范成法：利用一对齿轮啮合时其共轭齿廓互为包络线的原理，将刀具做成齿轮形状，让它一边上下运动进行切割，一边与齿坯啮合。该啮合运动称为展成运动。<br>  优点：加工精确，统一刀具加工的不同齿距的刀也可以正确啮合</p><h5 id="根切"><a href="#根切" class="headerlink" title="根切"></a>根切</h5><p>1.概念：范成法加工时，如果齿轮齿数过少，可能齿根的渐开线轮廓会被切去一部分</p><p>2.原因：刀具的齿顶线与啮合线的交点超过了理论啮合线的极限点N1。<br>  <code>（在保证齿坯分度圆与机床节线相切的前提下，如果齿数过小，会导致基圆半径过小；又因为模数一定，齿高也就确定了；这样的话会使刀具相对基圆切的更深，从而超过理论啮合线的极限点N1。在这种情况下，刀具过理论啮合线的极限点后，依然会切割，这样就产生了根切现象）</code></p><p>3.最少齿数z(min)=2·ha❀/sin²α=17<code>（推导过程：刀具高(ha❀·m)必须在理论啮合点下方 =&gt; ha❀·m&lt;mz·sinα·sinα =&gt; z(min)=2·ha❀/sin²α）</code><br>  即标准直齿轮不发生根切的最少齿数为17</p><h4 id="变位齿轮"><a href="#变位齿轮" class="headerlink" title="变位齿轮"></a>变位齿轮</h4><p>为了避免出现根切现象，我们改变刀具的位置，让刀具远离一段距离，从而解决这个问题。使用这种方法制造出的齿轮为<strong>变位齿轮</strong>。以标准齿轮的位置为基准，刀具沿径向改变的位置为xm，其中x为<strong>变位系数</strong>。规定刀具远离轮坯中心为正，靠近为负。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/bcedc069gy1fnpm9wuk8fj20j308cgmu.jpg" alt="变位齿轮"></p><p>如图，以正变位为例，刀具变位后：<br>p=(加工刀具齿距为定值)，Ra++(齿顶圆半径)，Rb=(基圆)，R=(分度圆)，Rf++(齿底圆半径)，ha++(齿顶高)，h=(加工刀具齿高为定值)，hf++(齿底高)，e—(齿槽宽)，s++(齿厚宽)，Ra++(齿顶圆半径)，Rf++(齿底圆半径)</p><h5 id="最小变位系数"><a href="#最小变位系数" class="headerlink" title="最小变位系数"></a>最小变位系数</h5><p>变位需要有一个数值，我们把避免根切的最小的变位系数称为<strong>最小变变位系数</strong></p><ul><li>经过推导得z(min)=(17-z)/17</li></ul><p>上式说明：当z<17时，为避免根切，刀具正变位量最小为x(min)m；当z>17时，必要时可以使用负变位（一般是在凑中心距时应用）</p><h5 id="无侧隙啮合方程"><a href="#无侧隙啮合方程" class="headerlink" title="无侧隙啮合方程"></a>无侧隙啮合方程</h5><p>变位之后，齿轮啮合中心距就发生了改变，而为了保证齿轮之间继续啮合，需要：一轮节圆的齿槽宽等于另一轮节圆的齿厚宽。</p><p>经过一系列推导得：<strong>tanα’-α’=2(x1+x2)/(z1+z2)·tanα+tanα-α</strong></p><p>这个式子常与a’cosα’=acosα结合起来求解</p><h5 id="变位齿轮传动类型"><a href="#变位齿轮传动类型" class="headerlink" title="变位齿轮传动类型"></a>变位齿轮传动类型</h5><ul><li>前排提示：小齿轮相比大齿轮更容易损耗，因此一般x1&gt;x2（1为小齿轮）<br>1.零传动 x1+x2=0</li></ul><p>1.1标准齿轮传动 x1=x2=0</p><p>1.2等变位齿轮 x1=-x2!=0</p><ul><li>注意：①齿数之和&gt;=34 ②实际中心距小于标准中心距</li></ul><p>2.正传动 x1+x2&gt;0</p><ul><li><p>注意：实际中心距大于标准中心距</p></li><li><p>当x2=0时，虽然变位系数为0，但大齿轮依然是变位齿轮。<br>（这是因为需要无侧隙安装，即需要一轮齿顶圆齿厚=另一轮齿根圆齿槽宽，解决这个的方法是将两轮的齿顶切去一些）</p></li><li><p>优点：减轻齿轮磨损；减少结构尺寸；提高强度</p></li><li><p>缺点：降低了重合度（啮合角增大）</p></li></ul><p>3.负传动 x1+x2&gt;0</p><ul><li><p>注意：实际中心距小于标准中心距</p></li><li><p>同理，当x1=0时，虽然变位系数为0，但小齿轮依然是变位齿轮。</p></li><li><p>负传动会加快齿轮损耗，不得以才为之</p></li></ul><h3 id="斜齿圆柱齿轮"><a href="#斜齿圆柱齿轮" class="headerlink" title="斜齿圆柱齿轮"></a>斜齿圆柱齿轮</h3><ul><li>优点：①传动稳定②重合度大③避免根切的最小尺寸小</li><li>缺点：有轴向力</li></ul><h4 id="齿廓-1"><a href="#齿廓-1" class="headerlink" title="齿廓"></a>齿廓</h4><p>渐开线螺旋面：与圆柱母线成βb角的斜直线KK’，与圆相切形成的发生面，在做纯滚动时形成的轮廓。其中斜直线KK’与母线的夹角为基圆螺旋角βb。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/bcedc069gy1fnpm9wwkbsj20p008cq4a.jpg" alt="斜齿轮齿廓"></p><p>由于是斜齿轮，当一个齿开始啮合时，齿的后部尚未啮合，此时，啮合线为一个点。随着啮合的进行，啮合线会逐渐增大，到某一位置后又会逐渐减少。，然后脱离啮合</p><h4 id="基本参数"><a href="#基本参数" class="headerlink" title="基本参数"></a>基本参数</h4><p>斜齿轮有两种参数：端面参数（垂直于轴线）、法面参数（垂直于分度圆上螺旋线）。</p><p>其中注意：法面齿廓不是渐开线，且法面”圆”为椭圆</p><p>根据斜齿轮的展开图（其中：b为齿宽）</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/bcedc069gy1fnpm9xb9b8j20hc08c406.jpg" alt="斜齿轮展开图"></p><p>端面参数与法面参数有以下关系</p><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">关系</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">齿距</td><td style="text-align:center">pt=pn/cosβ</td><td style="text-align:center">分度圆上</td></tr><tr><td style="text-align:center">模数</td><td style="text-align:center">mt=mn/cosβ</td><td style="text-align:center">分度圆上</td></tr><tr><td style="text-align:center">压力角</td><td style="text-align:center">tan(αt)=tan(αn)/cosβ</td><td style="text-align:center">分度圆上</td></tr></tbody></table></div><p>注：根据制造方式，法面尺寸为标准值</p><h4 id="齿轮正确啮合条件"><a href="#齿轮正确啮合条件" class="headerlink" title="齿轮正确啮合条件"></a>齿轮正确啮合条件</h4><p>模数和压力角分别相等，外啮合时螺旋角相反，内啮合时螺旋角相同。<br>即：</p><p>1.mt1=mt2(mn1=mn2);</p><p>2.αt1=αt2(αt1=αt2);</p><p>3.β1=-β2(外啮合)/β1=β2(内啮合)</p><ul><li>注：左旋：沿齿轮的轴向观察，〼为右旋，反之为左旋</li></ul><h4 id="重合度-1"><a href="#重合度-1" class="headerlink" title="重合度"></a>重合度</h4><p><strong>εγ=α（端面重合度）+εβ（纵向重合度）=εα + bsinβ/pn</strong>= [z1(tanαa1-tanα’)+z2(tanαa2-tanα’)]/2π + bsinβ/pn</p><h4 id="当量齿数"><a href="#当量齿数" class="headerlink" title="当量齿数"></a>当量齿数</h4><p>由于斜齿圆柱齿轮法向齿形不是渐开线就引入了当量齿轮的概念。当量齿轮是 刀具沿法向加工时 为了模拟出相似的齿形 而假想的直齿圆柱齿轮。<br>具体模拟方法如下：</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/bcedc069gy1fnpm9wuyqaj208c08c3z4.jpg" alt="当量齿轮"></p><p>其中上图中的椭圆为实际齿轮，与椭圆相切的圆为当量齿轮，由计算得ρ = a²/b = d/2cos²β</p><ul><li>①因此该当量齿轮的当量齿数<strong>zv = 2ρ/mn = z/cos³β</strong></li><li>②在判断是否<strong>根切</strong>时，需要运用到这个概念<h4 id="几何尺寸计算"><a href="#几何尺寸计算" class="headerlink" title="几何尺寸计算"></a>几何尺寸计算</h4></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">代号</th><th style="text-align:center">计算公式</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">端面模数</td><td style="text-align:center">mt</td><td style="text-align:center">mt=mncosβ</td><td style="text-align:center">mn根据强度计算或结构需要而定</td></tr><tr><td style="text-align:center">螺旋角</td><td style="text-align:center">β</td><td style="text-align:center">β一般取10°到25°</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">齿数</td><td style="text-align:center">z</td><td style="text-align:center">根据强度计算或结构需要而定</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">当量齿数</td><td style="text-align:center">zv</td><td style="text-align:center">zv=z/cos³β</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">中心距</td><td style="text-align:center">a</td><td style="text-align:center">a=mt(z1+z2)/2</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">端面压力角</td><td style="text-align:center">αt</td><td style="text-align:center">tan(αt)=tan(αn)/cosβ</td><td style="text-align:center">αn为标准值</td></tr><tr><td style="text-align:center">分度圆直径</td><td style="text-align:center">d</td><td style="text-align:center">d1=mtz1,d2=mtz2</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">法向齿距</td><td style="text-align:center">pn</td><td style="text-align:center">pn=πm</td><td style="text-align:center">分度圆上</td></tr><tr><td style="text-align:center">端面齿距</td><td style="text-align:center">pt</td><td style="text-align:center">pt=πm/cosβ</td><td style="text-align:center">分度圆上</td></tr><tr><td style="text-align:center">齿厚</td><td style="text-align:center">s</td><td style="text-align:center">p=πmt/2</td><td style="text-align:center">分度圆上</td></tr><tr><td style="text-align:center">齿槽宽</td><td style="text-align:center">e</td><td style="text-align:center">p=πmt/2</td><td style="text-align:center">分度圆上</td></tr><tr><td style="text-align:center">基圆直径</td><td style="text-align:center">db</td><td style="text-align:center">db=dcosα=mtzcosα</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">基圆齿距</td><td style="text-align:center">pb</td><td style="text-align:center">pb=πmtcosα=mtzcosα</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">齿顶圆直径</td><td style="text-align:center">da</td><td style="text-align:center">da=mn(z+2)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">齿根圆直径</td><td style="text-align:center">df</td><td style="text-align:center">df=mn(z-2.5)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">齿顶高</td><td style="text-align:center">ha</td><td style="text-align:center">ha=han❀×mn=mnn</td><td style="text-align:center">han❀为标准值=1</td></tr><tr><td style="text-align:center">齿根高</td><td style="text-align:center">hf</td><td style="text-align:center">hf=（han❀+cn❀）mn=1.25mn</td><td style="text-align:center">cn❀为标准值=0.25</td></tr></tbody></table></div><ul><li>注：β=0时，即为直齿圆柱齿轮</li></ul><h3 id="直齿锥齿轮"><a href="#直齿锥齿轮" class="headerlink" title="直齿锥齿轮"></a>直齿锥齿轮</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>1.直齿锥齿轮齿廓曲面的形成与直齿圆柱齿轮相似。如左图所示，当一扇形发生面S在基圆锥上作纯滚动时，发生面上过锥顶0的线段KK’所形成的轨迹AA’K’K即为锥齿轮的齿廓曲面。</p><p>2.因发生面沿基圆锥作纯滚动时，过0点的直线KK’上的K点至锥顶0点的距离不变，因此渐开线AK是在以点0为球心、OK为半径的球面上，故称渐开线AK为球面渐开线。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/bcedc069gy1fnpm9wx5xmj20kh08cmyi.jpg" alt="直齿锥齿轮">  </p><p>3.将背锥表面展开为一扇平面，以背锥锥矩rv为分度圆半径，补足为完整的直齿圆柱齿轮，齿数增加至zv1，这个直齿圆柱齿轮就是锥齿轮的当量齿轮。zv1为当量齿数。其中<strong>Zv1 = Z1 / cosδ1</strong></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/bcedc069gy1fnpm9ww2kzj207m08cgm7.jpg" alt="当量齿数">  </p><h4 id="等顶隙收缩齿轮"><a href="#等顶隙收缩齿轮" class="headerlink" title="等顶隙收缩齿轮"></a>等顶隙收缩齿轮</h4><p>1.下图左所示锥齿轮副，其两轮的顶锥、根锥与分度圆锥的锥顶点重合，齿顶间隙沿齿宽方向不相等，称为不等顶隙收缩齿锥齿轮传动。</p><p>2.而下图右所示两轮的根锥仍与分度圆锥的顶点重合，但两轮顶锥的顶点不再与分度圆锥的顶点重合，而是一轮的顶锥母线与另一轮的根锥母线平行，所以在整个齿宽方向齿顶间隙不变，故称为等顶隙收缩齿轮传动。</p><p>  <img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/bcedc069gy1fnpm9x2n5jj20oi0b4acu.jpg" alt="顶隙"></p><p>3.等顶隙收缩齿锥齿轮传动的优点是，能加大齿根和刀具的圆角半径，提高齿轮的弯曲强度和刀具的寿命有助于避免小端齿顶变尖等顶隙有利于齿轮的润滑等。因此其应用日益广泛。</p>]]></content>
    
    
    <categories>
      
      <category>机械相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机械</tag>
      
      <tag>机械原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>材料力学笔记</title>
    <link href="/2018/01/15/WHUT/MechanicsOfMaterials/"/>
    <url>/2018/01/15/WHUT/MechanicsOfMaterials/</url>
    
    <content type="html"><![CDATA[<p>材料力学是一门非常重要的课程，它的知识点可以说是贯穿了整个大学后半段。</p><p>基于《材料力学Ⅰ》（ISBN：978-7-04-030895-2）、《材料力学Ⅱ》（ISBN：978-7-04-030894-5）</p><span id="more"></span><h2 id="平面图形的几何性质"><a href="#平面图形的几何性质" class="headerlink" title="平面图形的几何性质"></a>平面图形的几何性质</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>1.静矩：<strong>Sz = ∫ydA(A)，Sy = ∫zdA(A)</strong>。其中：y为到z轴距离，z为到y轴距离</p><p>2.组合图形静矩：<strong>Sz = ∑(yi·Ai)(i=1,n)</strong>，各个部分对同一轴静矩的代数和</p><p>3.形心：<strong>y = ∫ydA(A) / A = Sz / A</strong>（由此可以看出：静矩为0，轴过形心）</p><p>4.组合图形形心：<strong>y =  ∑(yi·Ai)(i=1,n) / ∑Ai(i=1,n)</strong></p><p>5.惯性矩：<strong>Iz = ∫y²dA(A)</strong>。其中：y为到z轴距离。</p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823215313.png" alt=""></p><ol><li>①矩形惯性矩：<strong>Iz = hb³/12</strong> 。其中：h为∥边的高度，b为⊥边的高度，坐标原点为形心<br><code>Iz = ∫y²dA(A) = ∫(-b/2,b/2)dy∫z²(-h/2,h/2)dz = 1/3·(h/2)³·2·b = hb³/12</code></li><li>②圆惯性矩：<strong>Iz = πD^4/64</strong>，坐标原点为形心<br><code>Iz = ∫dθ(0,2π)∫ρ²cos²θ·ρ(0,D/2)dρ = 1/4·(D/2)³·π/2 = πD²/64</code></li><li>③圆环：<strong>Iz = π(D^4-d^4)/64</strong>，坐标原点为形心</li><li>④组合图形惯性矩：<strong>Iz = ∑Iz(i=1,n)</strong>，对同一根轴</li></ol><p>6.极惯性矩：<strong>Iρ = ∫ρ²dA(A) = Iy² + Iz²</strong>。其中，ρ为到原点距离。<code>Iρ = ∫ρ²dA(A) = ∫(y²+z²)dA(A) = Iy² + Iz²</code></p><p>7.惯性半径：Iz = iz²·A。即<strong>iz = sqrt(Iz/A)</strong>。圆截面惯性半径为D/4</p><p>8.惯性积：<strong>Iyz = ∫yzdA(A)</strong>。注：任意坐标轴为对称轴则<strong>Iyz=0</strong></p><h3 id="轴的变换"><a href="#轴的变换" class="headerlink" title="轴的变换"></a>轴的变换</h3><p>1.平行移轴公式：<strong>Izo = Izc + y(oc)²·A；Ixyo = Ixyc + x(oc)y(oc)·A</strong>。其中，O为新坐标轴，C为<strong>形心</strong>坐标轴。<code>∫y²dA(A) = ∫[y+y(oc)]²dA(A) = ∫y²dA(A) + ∫y(oc)²dA(A) + 2y(oc)·∫ydA(A)(值为0)</code><br>  （通过这个式子，可以很方便的计算组合图形的惯性轴）</p><p>2.转轴公式：</p><ol><li><strong>Iy1 = Iycos²α + Izsin²α - 2Iyzcosαsinα</strong> = <strong>(Iy+Iz)/2 + (Iy-Iz)/2·cos2α - Iyz·sin2α</strong>。其中：α为新轴y1,x1相对旧轴y,x转动的角度。（个人认为前面一个式子比较好记，所以加粗了）<br><code>新轴和旧轴之间的关系：y1=ycosα+zsinα；z1=zcosα-ysinα(由后图几何关系可知) -&gt; Iz1 = ∫y1²dA(A) = ∫(ycosα+zsinα)²dA(A) = Iycos²α + Izsin²α - 2Iyzcosαsinα</code></li><li><strong>Iz1 = Izcos²α + Iysin²α + 2Iyzcosαsinα</strong> = <strong>(Iz+Iy)/2 + (Iz-Iy)/2·cos2α + Iyz·sin2α</strong></li><li><strong>Ixy1 = (Iy-Iz)/2·sin2α + Iyz·cos2α</strong></li></ol><h3 id="形心主惯性轴"><a href="#形心主惯性轴" class="headerlink" title="形心主惯性轴"></a>形心主惯性轴</h3><p>1.用途：用于应力应变分析的计算</p><p>2.要素：①过形心②Iyz=0（满足这一点的称为主轴）</p><p>3.特点：两个主惯性距Iy，Iz分别为I的最大值和最小值</p><p>4.求解：</p><ol><li>形心主惯性轴与形心轴的夹角α0：tan2α0=-2Iyz/(Iy-Iz)<code>令转轴公式的Ixy1=0，化简可得</code></li><li>形心主惯性矩Iy0 = (Iy-Iz)/2 + sqrt{[(Iy-Iz)/2]²+Iyz²}；Iz0 = (Iy-Iz)/2 - sqrt{[(Iy-Iz)/2]²+Iyz²}<code>将α带入各表达式，化简可得</code></li></ol><h2 id="杆件变形的基本形式"><a href="#杆件变形的基本形式" class="headerlink" title="杆件变形的基本形式"></a>杆件变形的基本形式</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823215257.png" alt=""><br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823215240.png" alt=""></p><h4 id="总结及注意事项"><a href="#总结及注意事项" class="headerlink" title="总结及注意事项"></a>总结及注意事项</h4><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">正应力</th><th style="text-align:center">变形</th><th style="text-align:center">切应力</th><th style="text-align:center">转角</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">拉压</td><td style="text-align:center">σ=F/A</td><td style="text-align:center">∆l=Fl/EA</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">扭转</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">τ=T/Wt(圆轴) =Me/(2Aδ)(圆筒)</td><td style="text-align:center">ψ’=T/(GIp)</td><td style="text-align:center">δ为厚度ψ’为转角的倒数</td></tr><tr><td style="text-align:center">弯曲</td><td style="text-align:center">σ=My/Iz =M/W(最大)</td><td style="text-align:center">w’’=M/EI</td><td style="text-align:center">τ=FsSz/Izb</td><td style="text-align:center">θ=w’</td><td style="text-align:center">w为挠度，θ为转角，z为对中性轴，b为到中性轴距离</td></tr></tbody></table></div><p>1.应变不是长度，而是变化的长度/原始长度</p><p>2.三个弹性常数之间的关系：<strong>G=E/[2(1+μ)]</strong></p><p>3.抗扭截面系数<strong>Wt=Ip/R</strong>；抗弯截面系数<strong>W=Iz/y(max)</strong></p><p>4.圆轴扭转应力公式推导：①由于几何关系，距圆心为ρ处的切应变γ=ρ·dφ/dx（dφ为轴中长为dx的微端因扭转而转过的角度）<code>aa&#39;=ρdφ=γdx（aa&#39;为选取的一弧长）</code>②由物理关系τ=Gγ得τ=Gρ·dφ/dx③由静力关系扭矩T=∫ρτdA(A)=G·dφ/dx∫ρ²dA(A)=G·dφ/dx·Ip（Ip为极惯性矩），将τ=Gρ·dφ/dx带入上式得任一点切应力<strong>τ=Tρ/Ip</strong>（T为扭矩），因此最大切应力<strong>τ(max)=TR/Ip=T/Wt</strong>（Wt为抗扭截面系数，Wt=Ip/R）</p><p>5.计算弯曲变形有很多种方法，比如说积分法，叠加法，能量法等等</p><p>   <img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823215221.png" alt=""></p><h3 id="能量相关"><a href="#能量相关" class="headerlink" title="能量相关"></a>能量相关</h3><p>1.杆件变形能的计算</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">应变能</th></tr></thead><tbody><tr><td style="text-align:center">拉压</td><td style="text-align:center">Vε = ∫ F²(x)/2EA · dx(→l)</td></tr><tr><td style="text-align:center">纯剪切</td><td style="text-align:center">Vε = ∬ 1/2·τγ dA(→A)</td></tr><tr><td style="text-align:center">扭转</td><td style="text-align:center">Vε = ∫ T²(x)/2GIp · dx(→l)</td></tr><tr><td style="text-align:center">弯曲</td><td style="text-align:center">Vε = ∫ M²(x)/2EI · dx(→l)</td></tr></tbody></table></div><p>2.当位移与外力呈线性关系时，有 <strong>Vε = ∫ F²(x)/2EA · dx + ∫ T²(x)/2GIp · dx + ∫ M²(x)/2EI · dx</strong></p><p>3.功的互等定理：第一组力在第二组引起的位移上所作的功，等于第二组力在第一组引起的位移上所作个功Δ</p><p>4.莫尔积分：<strong>Δ = ∑ F(x)F‘(x)/EA · dx + ∫ T(x)T’(x)/GIp · dx + ∫ M(x)M‘(x)/EI · dx</strong> （F‘(x)、T’(x)、M‘(x)为在所求单位力作用下的力、扭矩、弯矩方程）</p><p>5.莫尔积分图乘法：Δ = ∫ ωM‘(C) / EI（其中ω为<u>M(x)图面积</u>，M‘(C)为<u>M(x)图形心</u>对应M’(x)的值）</p><h3 id="超静定相关"><a href="#超静定相关" class="headerlink" title="超静定相关"></a>超静定相关</h3><p>超静定问题主要分为两大类：外力超静定和内力超静定。</p><p>1.对于外力超静定：</p><p>  ①判定静不定次数</p><p>  ②选取并去除多余约束，以多余约束反力。选取基本静定基，在基本静定基加原载荷,并加多余约束反力X1，得到相当系统。</p><p>  ③画出两个图：原载荷图和单位力图。(或写出内力方程)</p><ol><li>在基本静定基上加原载荷，画原载荷图 (或写出内力方程)</li><li>在基本静定基上沿所求未知力方向加广义单位力，画单位力图  (或写出内力方程)    </li></ol><p>④计算正则方程的系数： Δ1p和δ11，两图互乘得Δ1p，单位力图自乘得δ11。或用莫尔积分求系数。</p><p>⑤建立力法正则方程和求解：Δ1p + δ11·X1 = 0</p><p>2.对内力超静定问题，是将上述第二点换为：将一段杆打断，用力X1代替，得到相当系统</p><h2 id="应力应变分析"><a href="#应力应变分析" class="headerlink" title="应力应变分析"></a>应力应变分析</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><p>1.应力应变分析研究的是一点处的应力状态，用单元体表示。一点有六个独立的应力分量</p><p>2.主平面：剪应力为零的截面。主应力：主平面上的正应力。</p><p>3.实例：</p><div class="table-container"><table><thead><tr><th style="text-align:center">变形类型</th><th style="text-align:center">应力状态</th></tr></thead><tbody><tr><td style="text-align:center">拉压</td><td style="text-align:center">←□→</td></tr><tr><td style="text-align:center">扭转</td><td style="text-align:center">↓□↑（上方→；下方←）</td></tr><tr><td style="text-align:center">弯曲</td><td style="text-align:center">→↓□↑←（上方→；下方←）（内部任意一点）</td></tr></tbody></table></div><h3 id="二向应力状态分析"><a href="#二向应力状态分析" class="headerlink" title="二向应力状态分析"></a>二向应力状态分析</h3><p>1.任意斜截面上的上的应力：</p><ol><li>①<strong>σα =  (σx + σy)/2 +  (σx - σy)/2·cos2α  - τxy·sin2α</strong></li><li><p>②<strong>τα = (σx - σy)/2·sin2α  + τxy·cos2α</strong></p><p>其中：α为斜截面外法线与x轴的夹角，逆时针为正；正应力拉为正压为负；切应力顺时针为正。τxy中的x表示作用平面的法线方向，y为平行的方向</p></li></ol><p>2.最大正应力和最小正应力</p><p>  <strong>σmax/σmin = (σx + σy)/2 ± sqrt{  [(σx - σy)/2]² + τxy² }</strong></p><p>3.主应力与主平面</p><p>  令上式 τα= 0 可以得到主平面的方位，即 <strong>tan2α0 = - 2τxy/(σx - σy)</strong></p><p>4.应力圆画法</p><ol><li>建立应力坐标系 τ-σ （注意选好比例尺）</li><li>在坐标系内画出点A(σx，τxy)和B(σy，τyx)</li><li>AB与σ轴的交点C为圆心，AC=BC为半径的圆为应力圆</li></ol><h3 id="三向应力状态分析"><a href="#三向应力状态分析" class="headerlink" title="三向应力状态分析"></a>三向应力状态分析</h3><p>1.一点的最大正应力 σmax = σ1</p><p>2.一点的最大切应力 τmax=  (σ1 - σ3)/2</p><h3 id="平面应变状态分析"><a href="#平面应变状态分析" class="headerlink" title="平面应变状态分析"></a>平面应变状态分析</h3><p>1.应力与应变的转化：广义胡克定理</p><ol><li>①εx =  1/E · [σx - μ( σy + σz ) ]；εy =  1/E · [σy - μ( σx + σz ) ]；εz =  1/E · [σz - μ( σy + σx ) ]</li><li>②γxy = τxy / G；γyz = τyz / G；γzx = τzx / G；</li></ol><p>因此可以得到<strong>主应力与主应变的关系</strong>：</p><ol><li>①<strong>ε1 =  1/E · [σ1 - μ( σ2 + σ3 ) ]</strong></li><li>②<strong>ε2 =  1/E · [σ2 - μ( σ3 + σ1 ) ]</strong></li><li>③<strong>ε3 =  1/E · [σ3 - μ( σ1+ σ2 ) ]</strong></li><li>④<strong>γxy = γyz = γzx = 0</strong></li></ol><p>2.主应力与主应变的计算公式完全相似，只是将式中的<code>正应力</code>改为<code>正应变</code>；<code>切应力</code>改为<code>切应变/2</code>即可</p><p>3.体应变 θ = ε1 + ε2 +ε3</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>切应力互等原理：在平衡的单元体内，如果存在切应力，则有切应力成对存在且数值相等；两者垂直于两个平面的交线，方向共同指向或背离这个交线。<br><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823215205.png" alt=""><br>（τ’产生的原因：为了保持单元体的平衡）</p><h2 id="强度理论"><a href="#强度理论" class="headerlink" title="强度理论"></a>强度理论</h2><p>强度理论是关于“构件发生强度失效起因”的假说，它是否正确，适用于什么情况，必须由生产实践来检验。强度理论分成两类：一类解释断裂失效：另一类解释屈服失效。</p><p>1.始种常见的强度理论</p><div class="table-container"><table><thead><tr><th style="text-align:center">强度理论</th><th style="text-align:center">相当应力</th><th style="text-align:center">说明</th><th style="text-align:center">适用范围</th></tr></thead><tbody><tr><td style="text-align:center">第一强度理论</td><td style="text-align:center">σr1 = σ1</td><td style="text-align:center">最大拉应力是引起材料脆断破坏的因素。</td><td style="text-align:center">脆性材料二轴拉伸；三向受拉</td></tr><tr><td style="text-align:center">第二强度理论</td><td style="text-align:center">σr2 = σ1 - μ( σ2 + σ3 )</td><td style="text-align:center">最大伸长线应变是引起材料脆断破坏的因素。</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">第三强度理论</td><td style="text-align:center">σr3 = σ1 - σ3</td><td style="text-align:center">最大切应力是引起材料屈服的因素。</td><td style="text-align:center">塑性材料；三向受压</td></tr><tr><td style="text-align:center">第四强度理论</td><td style="text-align:center">σr4 = sqrt{ 1/2·[ ( σ1 - σ2 )² + ( σ2 - σ3 )² + ( σ3 - σ1 )² ] }</td><td style="text-align:center">形状改变比能是引起材料屈服的因素。</td><td style="text-align:center">塑性材料；三向受压</td></tr><tr><td style="text-align:center">莫尔强度理论</td><td style="text-align:center">σrM = σ1 - [σt]/[σc] · σ3</td><td style="text-align:center">考虑了材料抗拉和抗压强度不相等的情况的第三强度理论。</td><td style="text-align:center">材料抗拉和抗压强度不等；脆性材料一拉一压</td></tr></tbody></table></div><p>2.对于典型二向应力状态：<strong>σr3 = sqrt( σ² + 4τ² )；σr4 = sqrt( σ² + 3τ² )</strong></p><h3 id="组合变形相关"><a href="#组合变形相关" class="headerlink" title="组合变形相关"></a>组合变形相关</h3><p>1.研究方法：</p><p>  ①外力分析：外力向形心简化并沿主惯性轴分解；</p><p>  ②内力分析：求每个外力分量对应的内力方程和内力图，确定危险面；</p><p>  ③应力分析：画危险面应力分布图，叠加，建立危险点的强度条件。</p><p>2.对于弯扭组合</p><ol><li>按照第三强度理论，有<strong>σr3 = 1/W · sqrt( M² + T² )</strong></li><li>按照第四强度理论，有<strong>σr4 = 1/W · sqrt( M² + 0.75T² )</strong></li></ol><h2 id="压杆稳定"><a href="#压杆稳定" class="headerlink" title="压杆稳定"></a>压杆稳定</h2><p>1.概念：工程中有些构件具有足够的强度、刚度，却不一定能安全可靠地工作，这是因为稳定性不够。细长杆件受压时轴线先开始是直线，接着必然是压弯。因此这里有一个极限值Fcr(临界压力)：由稳定平衡转化为不稳定平衡时所受轴向压力的界限值，称为临界压力。</p><p>2.临界压力：<strong>Fcr = π²EI / (μl)²</strong></p><p>  其中：μ 为长度系数，μl为相当长度</p><div class="table-container"><table><thead><tr><th style="text-align:center">两端铰支</th><th style="text-align:center">一段固定一端自由</th><th style="text-align:center">一端固定一段铰支</th><th style="text-align:center">两端固定</th></tr></thead><tbody><tr><td style="text-align:center">μ = 1</td><td style="text-align:center">μ = 2</td><td style="text-align:center">μ = 0.7</td><td style="text-align:center">μ = 0.5</td></tr></tbody></table></div><p>3.临界应力：</p><p>  <img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/20200823215148.png" alt=""></p><p>  其中：λ称为柔度；极惯性矩 i = sqrt(I / A)）</p><p>  欧拉公式<strong>σcr = π²E / λ²</strong>  <code>推导：σcr = Fcr / A = π²EI / A·(μl)² = π²E · (μl / i)²</code></p><p>  注：欧拉公式适用于大柔力杆（λ ≥ <strong>λ1 = π·sqrt( E/σp )</strong>）</p><p>4.安全因数 <strong>nst = Fcr / F</strong></p>]]></content>
    
    
    <categories>
      
      <category>机械相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机械</tag>
      
      <tag>材料力学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>毕业纪念：夷陵中学</title>
    <link href="/2016/09/01/CommemorationHighSchool/"/>
    <url>/2016/09/01/CommemorationHighSchool/</url>
    
    <content type="html"><![CDATA[<p>汇总一些高中四处玩的视频，图片资料。</p><span id="more"></span><h1 id="视频资源"><a href="#视频资源" class="headerlink" title="视频资源"></a>视频资源</h1><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/bilipic_202008292154396152.jpg" alt=""></p><p><a class="btn" href="https://www.bilibili.com/video/BV1Rx41117zv?p=1" title="https://www.bilibili.com/video/BV1Rx41117zv?p=1">2016年元旦晚会-正片</a>  <a class="btn" href="https://www.bilibili.com/video/BV1Rx41117zv?p=2" title="https://www.bilibili.com/video/BV1Rx41117zv?p=2">2016年元旦晚会-运动会图片篇</a>  <a class="btn" href="https://www.bilibili.com/video/BV1Rx41117zv?p=3" title="https://www.bilibili.com/video/BV1Rx41117zv?p=3">2016年元旦晚会-运动会视频篇</a>  <a class="btn" href="https://www.bilibili.com/video/BV1Rx41117zv?p=4" title="https://www.bilibili.com/video/BV1Rx41117zv?p=4">2016年元旦晚会-压轴好戏晚会篇</a>  <a class="btn" href="https://www.bilibili.com/video/BV1Rx41117zv?p=5" title="https://www.bilibili.com/video/BV1Rx41117zv?p=5">2016年元旦晚会-终极十班</a>  <a class="btn" href="https://www.bilibili.com/video/BV1Rx41117zv?p=6" title="https://www.bilibili.com/video/BV1Rx41117zv?p=6">2016年元旦晚会-夷陵达人秀</a>  <a class="btn" href="https://www.bilibili.com/video/BV1Rx41117zv?p=7" title="https://www.bilibili.com/video/BV1Rx41117zv?p=7">2016年元旦晚会-子轩传媒</a>  <a class="btn" href="https://www.bilibili.com/video/BV1Rx41117zv?p=8" title="https://www.bilibili.com/video/BV1Rx41117zv?p=8">2016年元旦晚会-综艺首秀</a>  <a class="btn" href="https://www.bilibili.com/video/BV1Rx41117zv?p=9" title="https://www.bilibili.com/video/BV1Rx41117zv?p=9">2016年元旦晚会-部分考场布置</a>  <a class="btn" href="https://www.bilibili.com/video/BV1Rx41117zv?p=10" title="https://www.bilibili.com/video/BV1Rx41117zv?p=10">2016年元旦晚会-预告</a>  <a class="btn" href="https://www.bilibili.com/video/BV1Rx41117zv?p=11" title="https://www.bilibili.com/video/BV1Rx41117zv?p=11">2015年元旦晚会</a></p><h2 id="离线下载"><a href="#离线下载" class="headerlink" title="离线下载"></a>离线下载</h2><p><a class="btn" href="https://mp.weixin.qq.com/s/c9IUJJZFw-ypWzbaJgXwWg" title="https://mp.weixin.qq.com/s/c9IUJJZFw-ypWzbaJgXwWg">转向下载链接</a></p><h1 id="文件资源"><a href="#文件资源" class="headerlink" title="文件资源"></a>文件资源</h1><p class="note note-primary">移动端好像看不到PDF，我就加了个按钮导向</p><h2 id="夷陵中学毕业纪念册1310版"><a href="#夷陵中学毕业纪念册1310版" class="headerlink" title="夷陵中学毕业纪念册1310版"></a>夷陵中学毕业纪念册1310版</h2><p><a class="btn" href="https://fuqingchen.top/pdf/PictureBook.pdf" title="https://fuqingchen.top/pdf/PictureBook.pdf">转向PDF链接</a></p><div class="row">    <embed src="/pdf/PictureBook.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="2016元旦晚会视频设定集"><a href="#2016元旦晚会视频设定集" class="headerlink" title="2016元旦晚会视频设定集"></a>2016元旦晚会视频设定集</h2><p><a class="btn" href="https://fuqingchen.top/pdf/VideoBook.pdf" title="https://fuqingchen.top/pdf/VideoBook.pdf">转向PDF链接</a></p><div class="row">    <embed src="/pdf/VideoBook.pdf" width="100%" height="550" type="application/pdf"></div><h1 id="图片资源"><a href="#图片资源" class="headerlink" title="图片资源"></a>图片资源</h1><h2 id="夷陵中学1310班蹭饭图（2016版）"><a href="#夷陵中学1310班蹭饭图（2016版）" class="headerlink" title="夷陵中学1310班蹭饭图（2016版）"></a>夷陵中学1310班蹭饭图（2016版）</h2><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/夷陵中学1310分布图.jpg" alt=""></p><p><a class="btn" href="https://fuqingchen.top/img/hbylzx1310.png" title="https://fuqingchen.top/img/hbylzx1310.png">原图下载</a></p><h2 id="照片集锦"><a href="#照片集锦" class="headerlink" title="照片集锦"></a>照片集锦</h2><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/夷陵中学1310班纪念册_Page_1_Image_0001.jpg" alt=""></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/夷陵中学1310班纪念册_Page_1_Image_0002.jpg" alt=""></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/夷陵中学1310班纪念册_Page_1_Image_0003.jpg" alt=""></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/夷陵中学1310班纪念册_Page_2_Image_0002.jpg" alt=""></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/夷陵中学1310班纪念册_Page_2_Image_0003.jpg" alt=""></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/夷陵中学1310班纪念册_Page_2_Image_0004.jpg" alt=""></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/夷陵中学1310班纪念册_Page_3_Image_0001.jpg" alt=""></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/夷陵中学1310班纪念册_Page_3_Image_0002.jpg" alt=""></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/夷陵中学1310班纪念册_Page_3_Image_0003.jpg" alt=""></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/夷陵中学1310班纪念册_Page_3_Image_0004.jpg" alt=""></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/夷陵中学1310班纪念册_Page_4_Image_0001.jpg" alt=""></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/夷陵中学1310班纪念册_Page_4_Image_0002.jpg" alt=""></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/夷陵中学1310班纪念册_Page_4_Image_0003.jpg" alt=""></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/夷陵中学1310班纪念册_Page_4_Image_0004.jpg" alt=""></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/夷陵中学1310班纪念册_Page_5_Image_0001.jpg" alt=""></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/夷陵中学1310班纪念册_Page_5_Image_0002.jpg" alt=""></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/夷陵中学1310班纪念册_Page_5_Image_0003.jpg" alt=""></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/夷陵中学1310班纪念册_Page_5_Image_0004.jpg" alt=""></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/夷陵中学1310班纪念册_Page_6_Image_0002.jpg" alt=""></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/夷陵中学1310班纪念册_Page_6_Image_0003.jpg" alt=""></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/夷陵中学1310班纪念册_Page_6_Image_0004.jpg" alt=""></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/夷陵中学1310班纪念册_Page_7_Image_0001.jpg" alt=""></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/夷陵中学1310班纪念册_Page_7_Image_0002.jpg" alt=""></p><p><img src="https://cquf-piclib.oss-cn-hangzhou.aliyuncs.com/夷陵中学1310班纪念册_Page_7_Image_0003.jpg" alt=""></p><h2 id="全景照片（老校区）"><a href="#全景照片（老校区）" class="headerlink" title="全景照片（老校区）"></a>全景照片（老校区）</h2><h3 id="逸夫教学楼"><a href="#逸夫教学楼" class="headerlink" title="逸夫教学楼"></a>逸夫教学楼</h3><p><a class="btn" href="https://fuqingchen.top/t/f3vkOw8bzq7" title="https://720yun.com/t/f3vkOw8bzq7">转向720yun全景平台</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>毕业纪念</tag>
      
      <tag>夷陵中学</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
